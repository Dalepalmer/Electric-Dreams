/***************************************************************************
 * Forge is custom code generated by Reverie ( Brad Triem ) to accomplish
 * forging through the mining of minerals.
 ***************************************************************************/

#if defined(macintosh)
#include <types.h>
#include <time.h>
#else
#include <sys/types.h>
#include <sys/time.h>
#endif
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "merc.h"

void do_forge_golem( CHAR_DATA *ch, char *argument )
{
    OBJ_DATA *hammer;
    CHAR_DATA *forged_golem = NULL;
    sh_int race;
    int skill, level, value, total, x, i;
    int alabaster_magic, ruby_magic, diamond_magic, platinum_magic, silver_magic, mithril_magic;
    int titanium_magic, adamantite_magic, copper_magic, bronze_magic, iron_magic, gold_magic;
    int obsidian_magic, emerald_magic, sapphire_magic, steel_magic, gem_magic;

    if ( !IS_SET( ch->in_room->room_flags, ROOM_FORGE ) )
    {
	send_to_char( "You need to be in a forge to make golems.\n\r", ch );
	return;
    }

    if ( ( skill = get_skill( ch, gsn_golem_making ) ) <= 0 )
    {
        send_to_char("You don't know how to make golems.\n\r", ch );
        return;
    }

    for ( hammer = ch->carrying; hammer != NULL && !IS_SET( hammer->extra_flags, ITEM_HAMMER ); hammer = hammer->next_content );

    if ( hammer == NULL )
    {
	send_to_char( "You need a hammer to make golems.\n\r", ch );
	return;
    }
    
    if ( hammer->pIndexData->vnum != VNUM_HAMMER_1 )
    {
	send_to_char( "You do not have the correct hammer to make golems.\n\r", ch );
	return;
    }

    if ( ch->pet != NULL )
    {
	send_to_char( "You already have control over another golem or pet.  You cannot have more than one at a time.\n\r", ch );
	return;
    }

    steel_magic = ch->pcdata->forge[MINERAL_STEEL];
    gold_magic = ch->pcdata->forge[MINERAL_GOLD];
    diamond_magic = ch->pcdata->forge[MINERAL_DIAMOND];
    silver_magic = ch->pcdata->forge[MINERAL_SILVER];
    sapphire_magic = ch->pcdata->forge[MINERAL_SAPPHIRE];
    ruby_magic = ch->pcdata->forge[MINERAL_RUBY];
    emerald_magic = ch->pcdata->forge[MINERAL_EMERALD];
    mithril_magic = ch->pcdata->forge[MINERAL_MITHRIL];
    obsidian_magic = ch->pcdata->forge[MINERAL_OBSIDIAN];
    platinum_magic = ch->pcdata->forge[MINERAL_PLATINUM];
    copper_magic = ch->pcdata->forge[MINERAL_COPPER];
    iron_magic = ch->pcdata->forge[MINERAL_IRON];
    bronze_magic = ch->pcdata->forge[MINERAL_BRONZE];
    adamantite_magic = ch->pcdata->forge[MINERAL_ADAMANTITE];
    titanium_magic = ch->pcdata->forge[MINERAL_TITANIUM];
    alabaster_magic = ch->pcdata->forge[MINERAL_ALABASTER];
    gem_magic = gold_magic + copper_magic + iron_magic + bronze_magic + adamantite_magic + alabaster_magic + ruby_magic + sapphire_magic + emerald_magic + silver_magic + diamond_magic;
    if ( steel_magic < ( ch->level * 5 ) )
    {
    	send_to_char( "There isn't enough magical steel in the forge.\n\r", ch );
    	return;
    }
	
    if ( gem_magic < ( ( ch->level * 3 ) * 3 / 2 ) )
    {
	send_to_char( "There isn't enough magical gems in the forge.\n\r", ch );
	return;
    }

    if ( !IS_SET(ch->forge_flags, FORGE_COMPLETE ) )
    {
        act( "$n is pounding away at a forge trying to finish making a golem.", ch, NULL, NULL, TO_ROOM );
	SET_BIT(ch->forge_flags, IS_FORGING );
	strncpy( ch->forge_item, "golem", 10 );
	ch->forge_from = 3;
	ch->forge_count = 5;
	send_to_char("You prepare the oven and the anvil for forging.\n\r",ch);
	return;
    }

    REMOVE_BIT(ch->forge_flags, FORGE_COMPLETE );
    extract_mineral( ch );
    if ( number_range( 1, 101 ) > skill )
    {
    	send_to_char( "You failed at your attemped at making a golem.\n\r", ch );
        check_improve( ch, gsn_golem_making, FALSE, 1 );
	return;
    }

	if ( gem_magic > 0 )
	{
	    if ( silver_magic >= ( ( ch->level * 3 ) * 3 / 2 ) )
	    {
		forged_golem = create_mobile( get_mob_index( SILVER_GOLEM ) );
		if ( forged_golem == NULL )
		{
		    bug ( "Not valid vnum for a golem.", 0 );
		    return;
		}

		level 					= ch->level;
		if ( obsidian_magic >= 50 )
		    for ( x = obsidian_magic ; x > 49 ; x -= 50 )
			level += 1;

    		value 					= level * level;
    		value 					= value + ( -1 * value ) % 10;
		forged_golem->level 			= UMIN( 100, level );
        	total 					= 100;
        	for ( x = 0 ; x < level ; x++ )
            	    total 				-= roll_dice( 2, 3 ) + 2;

		if ( adamantite_magic >= 50 )
		    for ( x = adamantite_magic ; x > 49 ; x -= 50 )
			total -= 15;

    		forged_golem->armor 			= total;
    		forged_golem->hitroll 			= level * 3 / 2;
    		forged_golem->damroll 			= level / 3;
    		forged_golem->damage[ 0 ] 		= ( ( 2 * ( level + 1 ) * ( level + 1 ) ) / ( 4 * level + 3 ) ) / 3 + 1;
    		forged_golem->damage[ 1 ] 		= ( ( 2 * ( level + 1 ) * ( level + 1 ) ) / ( 4 * level + 3 ) ) / 3 + 3;
    		forged_golem->damage[ 2 ] 		= level / 5;
    		forged_golem->hit 			= number_range( ch->max_hit - 100, ch->max_hit + 100 );
		if ( platinum_magic >= 20 )
		    for ( x = platinum_magic ; x > 19 ; x -= 20 )
			forged_golem->hit += 100;

    		forged_golem->max_hit 			= forged_golem->hit;
    		forged_golem->move 			= value;
    		forged_golem->max_move 			= value;
    		forged_golem->pIndexData->prac_skills 	= level * 2;
    		forged_golem->pIndexData->prac_spells 	= 0;
		if ( IS_SET( ch->guilds, MAJHERE ) )
		{
		    if ( race_table[ ch->race ][ ch->sex ].world == 0 )
		    {
			x = number_range( 1, 3 );
			switch ( x )
			{
			    case 1:
			    {
				SET_BIT( forged_golem->guilds, SCHRIES );
				break;    
			    }
			    case 2:
			    {
				SET_BIT( forged_golem->guilds, TATH );
				break;
			    }
			    case 3:
			    {
				SET_BIT( forged_golem->guilds, SUUR );
				break;
			    }
			}
		    }
		    if ( race_table[ ch->race ][ ch->sex ].world == 1 )
		    {
			x = number_range( 1, 3 );
			switch ( x )
			{
			    case 1:
			    {
				SET_BIT( forged_golem->guilds, TOH_KO_MERE );
				break;    
			    }
			    case 2:
			    {
				SET_BIT( forged_golem->guilds, MAR_TUUR );
				break;
			    }
			    case 3:
			    {
				SET_BIT( forged_golem->guilds, TOR_VAL );
				break;
			    }
			}
		    }
		    if ( race_table[ ch->race ][ ch->sex ].world == 0 )
		    {
			x = number_range( 1, 3 );
			switch ( x )
			{
			    case 1:
			    {
				SET_BIT( forged_golem->guilds, MIZUDAN );
				break;    
			    }
			    case 2:
			    {
				SET_BIT( forged_golem->guilds, CLANNGUARD );
				break;
			    }
			    case 3:
			    {
				SET_BIT( forged_golem->guilds, DHOZAN );
				break;
			    }
			}
		    }
		}
		else
		    forged_golem->guilds		= ch->guilds;
    		value /= 2;
    		for ( i = 0; i < MAX_STATS; i ++ )
        	    forged_golem->perm_stat[ i ]	= UMIN( 25, 11 + level / 4 );
	    }
	    else if ( gold_magic >= ( ( ch->level * 3 ) * 3 / 2 ) )
	    {
		forged_golem = create_mobile( get_mob_index( GOLD_GOLEM ) );
		if ( forged_golem == NULL )
		{
		    bug ( "Not valid vnum for a golem.", 0 );
		    return;
		}

		level 					= ch->level;
		if ( obsidian_magic >= 50 )
		    for ( x = obsidian_magic ; x > 49 ; x -= 50 )
			level += 1;

    		value 					= level * level;
    		value 					= value + ( -1 * value ) % 10;
		forged_golem->level 			= UMIN( 100, level );
        	total 					= 100;
        	for ( x = 0 ; x < level ; x++ )
            	    total 				-= roll_dice( 2, 3 ) + 2;

		if ( adamantite_magic >= 50 )
		    for ( x = adamantite_magic ; x > 49 ; x -= 50 )
			total -= 15;

    		forged_golem->armor 			= total;
    		forged_golem->hitroll 			= level * 2 / 3;
    		forged_golem->damroll 			= level / 3;
    		forged_golem->damage[ 0 ] 		= ( ( 2 * ( level + 1 ) * ( level + 1 ) ) / ( 4 * level + 3 ) ) / 3 + 1;
    		forged_golem->damage[ 1 ] 		= ( ( 2 * ( level + 1 ) * ( level + 1 ) ) / ( 4 * level + 3 ) ) / 3 + 3;
    		forged_golem->damage[ 2 ] 		= level / 5;
    		forged_golem->hit 			= number_range( ch->max_hit - 100, ch->max_hit + 100 );
		if ( platinum_magic >= 20 )
		    for ( x = platinum_magic ; x > 19 ; x -= 20 )
			forged_golem->hit += 100;

    		forged_golem->max_hit 			= forged_golem->hit;
    		forged_golem->move 			= value;
    		forged_golem->max_move 			= value;
    		forged_golem->pIndexData->prac_skills 	= level * 2;
    		forged_golem->pIndexData->prac_spells 	= 0;
		if ( IS_SET( ch->guilds, MAJHERE ) )
		{
		    if ( race_table[ ch->race ][ ch->sex ].world == 0 )
		    {
			x = number_range( 1, 3 );
			switch ( x )
			{
			    case 1:
			    {
				SET_BIT( forged_golem->guilds, SCHRIES );
				break;    
			    }
			    case 2:
			    {
				SET_BIT( forged_golem->guilds, TATH );
				break;
			    }
			    case 3:
			    {
				SET_BIT( forged_golem->guilds, SUUR );
				break;
			    }
			}
		    }
		    if ( race_table[ ch->race ][ ch->sex ].world == 1 )
		    {
			x = number_range( 1, 3 );
			switch ( x )
			{
			    case 1:
			    {
				SET_BIT( forged_golem->guilds, TOH_KO_MERE );
				break;    
			    }
			    case 2:
			    {
				SET_BIT( forged_golem->guilds, MAR_TUUR );
				break;
			    }
			    case 3:
			    {
				SET_BIT( forged_golem->guilds, TOR_VAL );
				break;
			    }
			}
		    }
		    if ( race_table[ ch->race ][ ch->sex ].world == 0 )
		    {
			x = number_range( 1, 3 );
			switch ( x )
			{
			    case 1:
			    {
				SET_BIT( forged_golem->guilds, MIZUDAN );
				break;    
			    }
			    case 2:
			    {
				SET_BIT( forged_golem->guilds, CLANNGUARD );
				break;
			    }
			    case 3:
			    {
				SET_BIT( forged_golem->guilds, DHOZAN );
				break;
			    }
			}
		    }
		}
		else
		    forged_golem->guilds		= ch->guilds;
    		value /= 2;
    		for ( i = 0; i < MAX_STATS; i ++ )
        	    forged_golem->perm_stat[ i ]	= UMIN( 25, 11 + level / 4 );
	    }
	    else if ( copper_magic >= ( ( ch->level * 3 ) * 3 / 2 ) )
	    {
		forged_golem = create_mobile( get_mob_index( COPPER_GOLEM ) );
		if ( forged_golem == NULL )
		{
		    bug ( "Not valid vnum for a golem.", 0 );
		    return;
		}

		level 					= ch->level;
		if ( obsidian_magic >= 50 )
		    for ( x = obsidian_magic ; x > 49 ; x -= 50 )
			level += 1;

    		value 					= level * level;
    		value 					= value + ( -1 * value ) % 10;
		forged_golem->level 			= UMIN( 100, level );
        	total 					= 100;
        	for ( x = 0 ; x < level ; x++ )
            	    total 				-= roll_dice( 2, 3 ) + 2;

		if ( adamantite_magic >= 50 )
		    for ( x = adamantite_magic ; x > 49 ; x -= 50 )
			total -= 15;

    		forged_golem->armor 			= total;
    		forged_golem->hitroll 			= level * 2 / 3;
    		forged_golem->damroll 			= level / 3;
    		forged_golem->damage[ 0 ] 		= ( ( 2 * ( level + 1 ) * ( level + 1 ) ) / ( 4 * level + 3 ) ) / 3 + 1;
    		forged_golem->damage[ 1 ] 		= ( ( 2 * ( level + 1 ) * ( level + 1 ) ) / ( 4 * level + 3 ) ) / 3 + 3;
    		forged_golem->damage[ 2 ] 		= level / 5;
    		forged_golem->hit 			= number_range( ch->max_hit - 100, ch->max_hit + 100 );
		if ( platinum_magic >= 20 )
		    for ( x = platinum_magic ; x > 19 ; x -= 20 )
			forged_golem->hit += 100;

    		forged_golem->max_hit 			= forged_golem->hit;
    		forged_golem->move 			= value;
    		forged_golem->max_move 			= value;
    		forged_golem->pIndexData->prac_skills 	= level * 2;
    		forged_golem->pIndexData->prac_spells 	= 0;
		if ( IS_SET( ch->guilds, MAJHERE ) )
		{
		    if ( race_table[ ch->race ][ ch->sex ].world == 0 )
		    {
			x = number_range( 1, 3 );
			switch ( x )
			{
			    case 1:
			    {
				SET_BIT( forged_golem->guilds, SCHRIES );
				break;    
			    }
			    case 2:
			    {
				SET_BIT( forged_golem->guilds, TATH );
				break;
			    }
			    case 3:
			    {
				SET_BIT( forged_golem->guilds, SUUR );
				break;
			    }
			}
		    }
		    if ( race_table[ ch->race ][ ch->sex ].world == 1 )
		    {
			x = number_range( 1, 3 );
			switch ( x )
			{
			    case 1:
			    {
				SET_BIT( forged_golem->guilds, TOH_KO_MERE );
				break;    
			    }
			    case 2:
			    {
				SET_BIT( forged_golem->guilds, MAR_TUUR );
				break;
			    }
			    case 3:
			    {
				SET_BIT( forged_golem->guilds, TOR_VAL );
				break;
			    }
			}
		    }
		    if ( race_table[ ch->race ][ ch->sex ].world == 0 )
		    {
			x = number_range( 1, 3 );
			switch ( x )
			{
			    case 1:
			    {
				SET_BIT( forged_golem->guilds, MIZUDAN );
				break;    
			    }
			    case 2:
			    {
				SET_BIT( forged_golem->guilds, CLANNGUARD );
				break;
			    }
			    case 3:
			    {
				SET_BIT( forged_golem->guilds, DHOZAN );
				break;
			    }
			}
		    }
		}
		else
		    forged_golem->guilds		= ch->guilds;
    		value /= 2;
    		for ( i = 0; i < MAX_STATS; i ++ )
        	    forged_golem->perm_stat[ i ]	= UMIN( 25, 11 + level / 4 );

		forged_golem->perm_stat[ STAT_DEX ] = UMIN( 25, forged_golem->perm_stat[ STAT_DEX ] + 5 );
	    }
	    else if ( iron_magic >= ( ( ch->level * 3 ) * 3 / 2 ) )
	    {
		forged_golem = create_mobile( get_mob_index( IRON_GOLEM ) );
		if ( forged_golem == NULL )
		{
		    bug ( "Not valid vnum for a golem.", 0 );
		    return;
		}

		level 					= ch->level;
		if ( obsidian_magic >= 50 )
		    for ( x = obsidian_magic ; x > 49 ; x -= 50 )
			level += 1;

    		value 					= level * level;
    		value 					= value + ( -1 * value ) % 10;
		forged_golem->level 			= UMIN( 100, level );
        	total 					= 100;
        	for ( x = 0 ; x < level ; x++ )
            	    total 				-= roll_dice( 2, 3 ) + 2;

		if ( adamantite_magic >= 50 )
		    for ( x = adamantite_magic ; x > 49 ; x -= 50 )
			total -= 15;

    		forged_golem->armor 			= total;
    		forged_golem->hitroll 			= level * 2 / 3;
    		forged_golem->damroll 			= level / 3;
    		forged_golem->damage[ 0 ] 		= ( ( 2 * ( level + 1 ) * ( level + 1 ) ) / ( 4 * level + 3 ) ) / 3 + 1;
    		forged_golem->damage[ 1 ] 		= ( ( 2 * ( level + 1 ) * ( level + 1 ) ) / ( 4 * level + 3 ) ) / 3 + 3;
    		forged_golem->damage[ 2 ] 		= level / 5;
    		forged_golem->hit 			= number_range( ch->max_hit - 100, ch->max_hit + 100 );
		if ( platinum_magic >= 20 )
		    for ( x = platinum_magic ; x > 19 ; x -= 20 )
			forged_golem->hit += 100;

    		forged_golem->max_hit 			= forged_golem->hit;
    		forged_golem->move 			= value;
    		forged_golem->max_move 			= value;
    		forged_golem->pIndexData->prac_skills 	= level * 2;
    		forged_golem->pIndexData->prac_spells 	= 0;
		if ( IS_SET( ch->guilds, MAJHERE ) )
		{
		    if ( race_table[ ch->race ][ ch->sex ].world == 0 )
		    {
			x = number_range( 1, 3 );
			switch ( x )
			{
			    case 1:
			    {
				SET_BIT( forged_golem->guilds, SCHRIES );
				break;    
			    }
			    case 2:
			    {
				SET_BIT( forged_golem->guilds, TATH );
				break;
			    }
			    case 3:
			    {
				SET_BIT( forged_golem->guilds, SUUR );
				break;
			    }
			}
		    }
		    if ( race_table[ ch->race ][ ch->sex ].world == 1 )
		    {
			x = number_range( 1, 3 );
			switch ( x )
			{
			    case 1:
			    {
				SET_BIT( forged_golem->guilds, TOH_KO_MERE );
				break;    
			    }
			    case 2:
			    {
				SET_BIT( forged_golem->guilds, MAR_TUUR );
				break;
			    }
			    case 3:
			    {
				SET_BIT( forged_golem->guilds, TOR_VAL );
				break;
			    }
			}
		    }
		    if ( race_table[ ch->race ][ ch->sex ].world == 0 )
		    {
			x = number_range( 1, 3 );
			switch ( x )
			{
			    case 1:
			    {
				SET_BIT( forged_golem->guilds, MIZUDAN );
				break;    
			    }
			    case 2:
			    {
				SET_BIT( forged_golem->guilds, CLANNGUARD );
				break;
			    }
			    case 3:
			    {
				SET_BIT( forged_golem->guilds, DHOZAN );
				break;
			    }
			}
		    }
		}
		else
		    forged_golem->guilds		= ch->guilds;
    		value /= 2;
    		for ( i = 0; i < MAX_STATS; i ++ )
        	    forged_golem->perm_stat[ i ]	= UMIN( 25, 11 + level / 4 );

		forged_golem->perm_stat[ STAT_STR ] = UMIN( 25, forged_golem->perm_stat[ STAT_STR ] + 5 );
	    }
	    else if ( bronze_magic >= ( ( ch->level * 3 ) * 3 / 2 ) )
	    {
		forged_golem = create_mobile( get_mob_index( BRONZE_GOLEM ) );
		if ( forged_golem == NULL )
		{
		    bug ( "Not valid vnum for a golem.", 0 );
		    return;
		}

		level 					= ch->level;
		if ( obsidian_magic >= 50 )
		    for ( x = obsidian_magic ; x > 49 ; x -= 50 )
			level += 1;

    		value 					= level * level;
    		value 					= value + ( -1 * value ) % 10;
		forged_golem->level 			= UMIN( 100, level );
        	total 					= 100;
        	for ( x = 0 ; x < level ; x++ )
            	    total 				-= roll_dice( 2, 3 ) + 2;

		if ( adamantite_magic >= 50 )
		    for ( x = adamantite_magic ; x > 49 ; x -= 50 )
			total -= 15;

    		forged_golem->armor 			= total;
    		forged_golem->hitroll 			= level * 2 / 3;
    		forged_golem->damroll 			= level / 3;
    		forged_golem->damage[ 0 ] 		= ( ( 2 * ( level + 1 ) * ( level + 1 ) ) / ( 4 * level + 3 ) ) / 3 + 1;
    		forged_golem->damage[ 1 ] 		= ( ( 2 * ( level + 1 ) * ( level + 1 ) ) / ( 4 * level + 3 ) ) / 3 + 3;
    		forged_golem->damage[ 2 ] 		= level / 5;
    		forged_golem->hit 			= number_range( ch->max_hit - 100, ch->max_hit + 100 );
		if ( platinum_magic >= 20 )
		    for ( x = platinum_magic ; x > 19 ; x -= 20 )
			forged_golem->hit += 100;

    		forged_golem->max_hit 			= forged_golem->hit;
    		forged_golem->move 			= value;
    		forged_golem->max_move 			= value;
    		forged_golem->pIndexData->prac_skills 	= level * 2;
    		forged_golem->pIndexData->prac_spells 	= 0;
		if ( IS_SET( ch->guilds, MAJHERE ) )
		{
		    if ( race_table[ ch->race ][ ch->sex ].world == 0 )
		    {
			x = number_range( 1, 3 );
			switch ( x )
			{
			    case 1:
			    {
				SET_BIT( forged_golem->guilds, SCHRIES );
				break;    
			    }
			    case 2:
			    {
				SET_BIT( forged_golem->guilds, TATH );
				break;
			    }
			    case 3:
			    {
				SET_BIT( forged_golem->guilds, SUUR );
				break;
			    }
			}
		    }
		    if ( race_table[ ch->race ][ ch->sex ].world == 1 )
		    {
			x = number_range( 1, 3 );
			switch ( x )
			{
			    case 1:
			    {
				SET_BIT( forged_golem->guilds, TOH_KO_MERE );
				break;    
			    }
			    case 2:
			    {
				SET_BIT( forged_golem->guilds, MAR_TUUR );
				break;
			    }
			    case 3:
			    {
				SET_BIT( forged_golem->guilds, TOR_VAL );
				break;
			    }
			}
		    }
		    if ( race_table[ ch->race ][ ch->sex ].world == 0 )
		    {
			x = number_range( 1, 3 );
			switch ( x )
			{
			    case 1:
			    {
				SET_BIT( forged_golem->guilds, MIZUDAN );
				break;    
			    }
			    case 2:
			    {
				SET_BIT( forged_golem->guilds, CLANNGUARD );
				break;
			    }
			    case 3:
			    {
				SET_BIT( forged_golem->guilds, DHOZAN );
				break;
			    }
			}
		    }
		}
		else
		    forged_golem->guilds		= ch->guilds;
    		value /= 2;
    		for ( i = 0; i < MAX_STATS; i ++ )
        	    forged_golem->perm_stat[ i ]	= UMIN( 25, 11 + level / 4 );

		forged_golem->perm_stat[ STAT_CON ] = UMIN( 25, forged_golem->perm_stat[ STAT_CON ] + 5 );
	    }
	    else if ( ruby_magic >= ( ( ch->level * 3 ) * 3 / 2 ) )
	    {
		forged_golem = create_mobile( get_mob_index( RUBY_GOLEM ) );
		if ( forged_golem == NULL )
		{
		    bug ( "Not valid vnum for a golem.", 0 );
		    return;
		}

		level 					= ch->level;
		if ( obsidian_magic >= 50 )
		    for ( x = obsidian_magic ; x > 49 ; x -= 50 )
			level += 1;

    		value 					= level * level;
    		value 					= value + ( -1 * value ) % 10;
		forged_golem->level 			= UMIN( 100, level );
        	total 					= 100;
        	for ( x = 0 ; x < level ; x++ )
            	    total 				-= roll_dice( 2, 3 ) + 2;

		if ( adamantite_magic >= 50 )
		    for ( x = adamantite_magic ; x > 49 ; x -= 50 )
			total -= 15;

    		forged_golem->armor 			= total;
    		forged_golem->hitroll 			= level * 2 / 3;
    		forged_golem->damroll 			= level / 3;
    		forged_golem->damage[ 0 ] 		= ( ( 2 * ( level + 1 ) * ( level + 1 ) ) / ( 4 * level + 3 ) ) / 3 + 1;
    		forged_golem->damage[ 1 ] 		= ( ( 2 * ( level + 1 ) * ( level + 1 ) ) / ( 4 * level + 3 ) ) / 3 + 3;
    		forged_golem->damage[ 2 ] 		= level / 5;
    		forged_golem->hit 			= number_range( ch->max_hit - 100, ch->max_hit + 100 );
		if ( platinum_magic >= 20 )
		    for ( x = platinum_magic ; x > 19 ; x -= 20 )
			forged_golem->hit += 100;

    		forged_golem->max_hit 			= forged_golem->hit;
    		forged_golem->move 			= value;
    		forged_golem->max_move 			= value;
    		forged_golem->pIndexData->prac_skills 	= level * 2;
    		forged_golem->pIndexData->prac_spells 	= level * 5;
		if ( race_table[ ch->race ][ ch->sex ].world == 0 )
		    SET_BIT( forged_golem->guilds, DHOZAN );
		else if ( race_table[ ch->race ][ ch->sex ].world == 1 )
		    SET_BIT( forged_golem->guilds, TOH_KO_MERE );
		else if ( race_table[ ch->race ][ ch->sex ].world == 2 )
		    SET_BIT( forged_golem->guilds, MIZUDAN );

    		value /= 2;
    		for ( i = 0; i < MAX_STATS; i ++ )
        	    forged_golem->perm_stat[ i ]	= UMIN( 25, 11 + level / 4 );

        	forged_golem->pIndexData->mana[ 0 ][ ELEMENT_FIRE ] 	= race_table[ forged_golem->race ][ forged_golem->sex ].mana_dice[ ELEMENT_FIRE ] * level;
       	    	forged_golem->pIndexData->mana[ 1 ][ ELEMENT_FIRE ] 	= race_table[ forged_golem->race ][ forged_golem->sex ].mana_die[ ELEMENT_FIRE ];
        	forged_golem->pIndexData->mana[ 2 ][ ELEMENT_FIRE ] 	= race_table[ forged_golem->race ][ forged_golem->sex ].mana_bonus[ ELEMENT_FIRE ] * level + 100;

        	forged_golem->max_mana[ ELEMENT_FIRE ] = roll_dice( forged_golem->pIndexData->mana[ DICE_NUMBER ][ ELEMENT_FIRE ], forged_golem->pIndexData->mana[ DICE_TYPE ][ ELEMENT_FIRE ] ) + forged_golem->pIndexData->mana[ DICE_BONUS ][ ELEMENT_FIRE ];
		if ( mithril_magic >= 50 )
		    for ( x = mithril_magic ; x > 49 ; x -= 50 )
			forged_golem->max_mana[ ELEMENT_FIRE ] += 250;

        	forged_golem->mana[ ELEMENT_FIRE ]            = forged_golem->max_mana[ ELEMENT_FIRE ];
	    }
	    else if ( sapphire_magic >= ( ( ch->level * 3 ) * 3 / 2 ) )
	    {
		forged_golem = create_mobile( get_mob_index( SAPPHIRE_GOLEM ) );
		if ( forged_golem == NULL )
		{
		    bug ( "Not valid vnum for a golem.", 0 );
		    return;
		}

		level 					= ch->level;
		if ( obsidian_magic >= 50 )
		    for ( x = obsidian_magic ; x > 49 ; x -= 50 )
			level += 1;

    		value 					= level * level;
    		value 					= value + ( -1 * value ) % 10;
		forged_golem->level 			= UMIN( 100, level );
        	total 					= 100;
        	for ( x = 0 ; x < level ; x++ )
            	    total 				-= roll_dice( 2, 3 ) + 2;

		if ( adamantite_magic >= 50 )
		    for ( x = adamantite_magic ; x > 49 ; x -= 50 )
			total -= 15;

    		forged_golem->armor 			= total;
    		forged_golem->hitroll 			= level * 2 / 3;
    		forged_golem->damroll 			= level / 3;
    		forged_golem->damage[ 0 ] 		= ( ( 2 * ( level + 1 ) * ( level + 1 ) ) / ( 4 * level + 3 ) ) / 3 + 1;
    		forged_golem->damage[ 1 ] 		= ( ( 2 * ( level + 1 ) * ( level + 1 ) ) / ( 4 * level + 3 ) ) / 3 + 3;
    		forged_golem->damage[ 2 ] 		= level / 5;
    		forged_golem->hit 			= number_range( ch->max_hit - 100, ch->max_hit + 100 );
		if ( platinum_magic >= 20 )
		    for ( x = platinum_magic ; x > 19 ; x -= 20 )
			forged_golem->hit += 100;

    		forged_golem->max_hit 			= forged_golem->hit;
    		forged_golem->move 			= value;
    		forged_golem->max_move 			= value;
    		forged_golem->pIndexData->prac_skills 	= level * 2;
    		forged_golem->pIndexData->prac_spells 	= level * 5;
		if ( race_table[ ch->race ][ ch->sex ].world == 0 )
		    SET_BIT( forged_golem->guilds, TATH );
		else if ( race_table[ ch->race ][ ch->sex ].world == 1 )
		    SET_BIT( forged_golem->guilds, TOR_VAL );
		else if ( race_table[ ch->race ][ ch->sex ].world == 2 )
		    SET_BIT( forged_golem->guilds, SUUR );

    		value /= 2;
    		for ( i = 0; i < MAX_STATS; i ++ )
        	    forged_golem->perm_stat[ i ]	= UMIN( 25, 11 + level / 4 );

        	forged_golem->pIndexData->mana[ 0 ][ ELEMENT_WATER ] 	= race_table[ forged_golem->race ][ forged_golem->sex ].mana_dice[ ELEMENT_WATER ] * level;
       	    	forged_golem->pIndexData->mana[ 1 ][ ELEMENT_WATER ] 	= race_table[ forged_golem->race ][ forged_golem->sex ].mana_die[ ELEMENT_WATER ];
        	forged_golem->pIndexData->mana[ 2 ][ ELEMENT_WATER ] 	= race_table[ forged_golem->race ][ forged_golem->sex ].mana_bonus[ ELEMENT_WATER ] * level + 100;

        	forged_golem->max_mana[ ELEMENT_WATER ] = roll_dice( forged_golem->pIndexData->mana[ DICE_NUMBER ][ ELEMENT_WATER ], forged_golem->pIndexData->mana[ DICE_TYPE ][ ELEMENT_WATER ] ) + forged_golem->pIndexData->mana[ DICE_BONUS ][ ELEMENT_WATER ];
		if ( mithril_magic >= 50 )
		    for ( x = mithril_magic ; x > 49 ; x -= 50 )
			forged_golem->max_mana[ ELEMENT_WATER ] += 250;

        	forged_golem->mana[ ELEMENT_WATER ]            = forged_golem->max_mana[ ELEMENT_WATER ];
	    }
	    else if ( emerald_magic >= ( ( ch->level * 3 ) * 3 / 2 ) )
	    {
		forged_golem = create_mobile( get_mob_index( EMERALD_GOLEM ) );
		if ( forged_golem == NULL )
		{
		    bug ( "Not valid vnum for a golem.", 0 );
		    return;
		}

		level 					= ch->level;
		if ( obsidian_magic >= 50 )
		    for ( x = obsidian_magic ; x > 49 ; x -= 50 )
			level += 1;

    		value 					= level * level;
    		value 					= value + ( -1 * value ) % 10;
		forged_golem->level 			= UMIN( 100, level );
        	total 					= 100;
        	for ( x = 0 ; x < level ; x++ )
            	    total 				-= roll_dice( 2, 3 ) + 2;

		if ( adamantite_magic >= 50 )
		    for ( x = adamantite_magic ; x > 49 ; x -= 50 )
			total -= 15;

    		forged_golem->armor 			= total;
    		forged_golem->hitroll 			= level * 2 / 3;
    		forged_golem->damroll 			= level / 3;
    		forged_golem->damage[ 0 ] 		= ( ( 2 * ( level + 1 ) * ( level + 1 ) ) / ( 4 * level + 3 ) ) / 3 + 1;
    		forged_golem->damage[ 1 ] 		= ( ( 2 * ( level + 1 ) * ( level + 1 ) ) / ( 4 * level + 3 ) ) / 3 + 3;
    		forged_golem->damage[ 2 ] 		= level / 5;
    		forged_golem->hit 			= number_range( ch->max_hit - 100, ch->max_hit + 100 );
		if ( platinum_magic >= 20 )
		    for ( x = platinum_magic ; x > 19 ; x -= 20 )
			forged_golem->hit += 100;

    		forged_golem->max_hit 			= forged_golem->hit;
    		forged_golem->move 			= value;
    		forged_golem->max_move 			= value;
    		forged_golem->pIndexData->prac_skills 	= level * 2;
    		forged_golem->pIndexData->prac_spells 	= level * 5;
		if ( race_table[ ch->race ][ ch->sex ].world == 0 )
		    SET_BIT( forged_golem->guilds, SUUR );
		else if ( race_table[ ch->race ][ ch->sex ].world == 1 )
		    SET_BIT( forged_golem->guilds, MAR_TUUR );
		else if ( race_table[ ch->race ][ ch->sex ].world == 2 )
		    SET_BIT( forged_golem->guilds, MIZUDAN );

    		value /= 2;
    		for ( i = 0; i < MAX_STATS; i ++ )
        	    forged_golem->perm_stat[ i ]	= UMIN( 25, 11 + level / 4 );

        	forged_golem->pIndexData->mana[ 0 ][ ELEMENT_EARTH ] 	= race_table[ forged_golem->race ][ forged_golem->sex ].mana_dice[ ELEMENT_EARTH ] * level;
       	    	forged_golem->pIndexData->mana[ 1 ][ ELEMENT_EARTH ] 	= race_table[ forged_golem->race ][ forged_golem->sex ].mana_die[ ELEMENT_EARTH ];
        	forged_golem->pIndexData->mana[ 2 ][ ELEMENT_EARTH ] 	= race_table[ forged_golem->race ][ forged_golem->sex ].mana_bonus[ ELEMENT_EARTH ] * level + 100;

        	forged_golem->max_mana[ ELEMENT_EARTH ] = roll_dice( forged_golem->pIndexData->mana[ DICE_NUMBER ][ ELEMENT_EARTH ], forged_golem->pIndexData->mana[ DICE_TYPE ][ ELEMENT_EARTH ] ) + forged_golem->pIndexData->mana[ DICE_BONUS ][ ELEMENT_EARTH ];
		if ( mithril_magic >= 50 )
		    for ( x = mithril_magic ; x > 49 ; x -= 50 )
			forged_golem->max_mana[ ELEMENT_EARTH ] += 250;

        	forged_golem->mana[ ELEMENT_EARTH ]            = forged_golem->max_mana[ ELEMENT_EARTH ];
	    }
	    else if ( diamond_magic >= ( ( ch->level * 3 ) * 3 / 2 ) )
	    {
		forged_golem = create_mobile( get_mob_index( DIAMOND_GOLEM ) );
		if ( forged_golem == NULL )
		{
		    bug ( "Not valid vnum for a golem.", 0 );
		    return;
		}

		level 					= ch->level;
		if ( obsidian_magic >= 50 )
		    for ( x = obsidian_magic ; x > 49 ; x -= 50 )
			level += 1;

    		value 					= level * level;
    		value 					= value + ( -1 * value ) % 10;
		forged_golem->level 			= UMIN( 100, level );
        	total 					= 100;
        	for ( x = 0 ; x < level ; x++ )
            	    total 				-= roll_dice( 2, 3 ) + 2;

		if ( adamantite_magic >= 50 )
		    for ( x = adamantite_magic ; x > 49 ; x -= 50 )
			total -= 15;

    		forged_golem->armor 			= total;
    		forged_golem->hitroll 			= level * 2 / 3;
    		forged_golem->damroll 			= level / 3;
    		forged_golem->damage[ 0 ] 		= ( ( 2 * ( level + 1 ) * ( level + 1 ) ) / ( 4 * level + 3 ) ) / 3 + 1;
    		forged_golem->damage[ 1 ] 		= ( ( 2 * ( level + 1 ) * ( level + 1 ) ) / ( 4 * level + 3 ) ) / 3 + 3;
    		forged_golem->damage[ 2 ] 		= level / 5;
    		forged_golem->hit 			= number_range( ch->max_hit - 100, ch->max_hit + 100 );
		if ( platinum_magic >= 20 )
		    for ( x = platinum_magic ; x > 19 ; x -= 20 )
			forged_golem->hit += 100;

    		forged_golem->max_hit 			= forged_golem->hit;
    		forged_golem->move 			= value;
    		forged_golem->max_move 			= value;
    		forged_golem->pIndexData->prac_skills 	= level * 2;
    		forged_golem->pIndexData->prac_spells 	= level * 5;
		if ( race_table[ ch->race ][ ch->sex ].world == 0 )
		    SET_BIT( forged_golem->guilds, SCHRIES );
		else if ( race_table[ ch->race ][ ch->sex ].world == 1 )
		    SET_BIT( forged_golem->guilds, TOR_VAL );
		else if ( race_table[ ch->race ][ ch->sex ].world == 2 )
		    SET_BIT( forged_golem->guilds, CLANNGUARD );

    		value /= 2;
    		for ( i = 0; i < MAX_STATS; i ++ )
        	    forged_golem->perm_stat[ i ]	= UMIN( 25, 11 + level / 4 );

        	forged_golem->pIndexData->mana[ 0 ][ ELEMENT_WIND ] 	= race_table[ forged_golem->race ][ forged_golem->sex ].mana_dice[ ELEMENT_WIND ] * level;
       	    	forged_golem->pIndexData->mana[ 1 ][ ELEMENT_WIND ] 	= race_table[ forged_golem->race ][ forged_golem->sex ].mana_die[ ELEMENT_WIND ];
        	forged_golem->pIndexData->mana[ 2 ][ ELEMENT_WIND ] 	= race_table[ forged_golem->race ][ forged_golem->sex ].mana_bonus[ ELEMENT_WIND ] * level + 100;

        	forged_golem->max_mana[ ELEMENT_WIND ] = roll_dice( forged_golem->pIndexData->mana[ DICE_NUMBER ][ ELEMENT_WIND ], forged_golem->pIndexData->mana[ DICE_TYPE ][ ELEMENT_WIND ] ) + forged_golem->pIndexData->mana[ DICE_BONUS ][ ELEMENT_WIND ];
		if ( mithril_magic >= 50 )
		    for ( x = mithril_magic ; x > 49 ; x -= 50 )
			forged_golem->max_mana[ ELEMENT_WIND ] += 250;

        	forged_golem->mana[ ELEMENT_WIND ]            = forged_golem->max_mana[ ELEMENT_WIND ];
            }
	    else if ( alabaster_magic >= ( ( ch->level * 3 ) * 3 / 2 ) )
	    {
		forged_golem = create_mobile( get_mob_index( ALABASTER_GOLEM ) );
		if ( forged_golem == NULL )
		{
		    bug ( "Not valid vnum for a golem.", 0 );
		    return;
		}

		level 					= ch->level;
		if ( obsidian_magic >= 50 )
		    for ( x = obsidian_magic ; x > 49 ; x -= 50 )
			level += 1;

    		value 					= level * level;
    		value 					= value + ( -1 * value ) % 10;
		forged_golem->level 			= UMIN( 100, level );
        	total 					= 100;
        	for ( x = 0 ; x < level ; x++ )
            	    total 				-= roll_dice( 2, 3 ) + 2;

		if ( adamantite_magic >= 50 )
		    for ( x = adamantite_magic ; x > 49 ; x -= 50 )
			total -= 15;

    		forged_golem->armor 			= total;
    		forged_golem->hitroll 			= level * 2 / 3;
    		forged_golem->damroll 			= level / 3;
    		forged_golem->damage[ 0 ] 		= ( ( 2 * ( level + 1 ) * ( level + 1 ) ) / ( 4 * level + 3 ) ) / 3 + 1;
    		forged_golem->damage[ 1 ] 		= ( ( 2 * ( level + 1 ) * ( level + 1 ) ) / ( 4 * level + 3 ) ) / 3 + 3;
    		forged_golem->damage[ 2 ] 		= level / 5;
    		forged_golem->hit 			= number_range( ch->max_hit - 100, ch->max_hit + 100 );
		if ( platinum_magic >= 20 )
		    for ( x = platinum_magic ; x > 19 ; x -= 20 )
			forged_golem->hit += 100;

    		forged_golem->max_hit 			= forged_golem->hit;
    		forged_golem->move 			= value;
    		forged_golem->max_move 			= value;
    		forged_golem->pIndexData->prac_skills 	= level * 2;
    		forged_golem->pIndexData->prac_spells 	= level * 5;
		SET_BIT( forged_golem->guilds, MAJHERE );
    		value /= 2;
    		for ( i = 0; i < MAX_STATS; i ++ )
        	    forged_golem->perm_stat[ i ]	= UMIN( 25, 11 + level / 4 );

        	for ( i = 0 ; i < MAX_ELEMENT_TYPE ; i++ )
        	{
        	    forged_golem->pIndexData->mana[ 0 ][ i ] 	= race_table[ forged_golem->race ][ forged_golem->sex ].mana_dice[ i ] * level;
        	    forged_golem->pIndexData->mana[ 1 ][ i ] 	= race_table[ forged_golem->race ][ forged_golem->sex ].mana_die[ i ];
        	    forged_golem->pIndexData->mana[ 2 ][ i ] 	= race_table[ forged_golem->race ][ forged_golem->sex ].mana_bonus[ i ] * level + 100;
		}

        	for ( i = 0 ; i < MAX_ELEMENT_TYPE ; i++ )
        	{
        	    forged_golem->max_mana[ i ] = roll_dice( forged_golem->pIndexData->mana[ DICE_NUMBER ][ i ], forged_golem->pIndexData->mana[ DICE_TYPE ][ i ] ) + forged_golem->pIndexData->mana[ DICE_BONUS ][ i ];
        	    forged_golem->mana[ i ]            = forged_golem->max_mana[ i ];
        	}
	    }
	    else if ( adamantite_magic >= ( ( ch->level * 3 ) * 3 / 2 ) )
	    {
		forged_golem = create_mobile( get_mob_index( ADAMANTITE_GOLEM ) );
		if ( forged_golem == NULL )
		{
		    bug ( "Not valid vnum for a golem.", 0 );
		    return;
		}

		level 					= ch->level;
		if ( obsidian_magic >= 50 )
		    for ( x = obsidian_magic ; x > 49 ; x -= 50 )
			level += 1;

    		value 					= level * level;
    		value 					= value + ( -1 * value ) % 10;
		forged_golem->level 			= UMIN( 100, level );
        	total 					= 100;
        	for ( x = 0 ; x < level ; x++ )
            	    total 				-= roll_dice( 2, 3 ) + 2;

		if ( adamantite_magic >= 50 )
		    for ( x = adamantite_magic ; x > 49 ; x -= 50 )
			total -= 15;

    		forged_golem->armor 			= total;
    		forged_golem->hitroll 			= level * 2 / 3;
    		forged_golem->damroll 			= level / 3;
    		forged_golem->damage[ 0 ] 		= ( ( 2 * ( level + 1 ) * ( level + 1 ) ) / ( 4 * level + 3 ) ) / 3 + 1;
    		forged_golem->damage[ 1 ] 		= ( ( 2 * ( level + 1 ) * ( level + 1 ) ) / ( 4 * level + 3 ) ) / 3 + 3;
    		forged_golem->damage[ 2 ] 		= level / 5;
    		forged_golem->hit 			= number_range( ch->max_hit - 100, ch->max_hit + 100 );
		if ( platinum_magic >= 20 )
		    for ( x = platinum_magic ; x > 19 ; x -= 20 )
			forged_golem->hit += 100;

    		forged_golem->max_hit 			= forged_golem->hit;
    		forged_golem->move 			= value;
    		forged_golem->max_move 			= value;
    		forged_golem->pIndexData->prac_skills 	= level * 2;
    		forged_golem->pIndexData->prac_spells 	= 0;
		if ( IS_SET( ch->guilds, MAJHERE ) )
		{
		    if ( race_table[ ch->race ][ ch->sex ].world == 0 )
		    {
			x = number_range( 1, 3 );
			switch ( x )
			{
			    case 1:
			    {
				SET_BIT( forged_golem->guilds, SCHRIES );
				break;    
			    }
			    case 2:
			    {
				SET_BIT( forged_golem->guilds, TATH );
				break;
			    }
			    case 3:
			    {
				SET_BIT( forged_golem->guilds, SUUR );
				break;
			    }
			}
		    }
		    if ( race_table[ ch->race ][ ch->sex ].world == 1 )
		    {
			x = number_range( 1, 3 );
			switch ( x )
			{
			    case 1:
			    {
				SET_BIT( forged_golem->guilds, TOH_KO_MERE );
				break;    
			    }
			    case 2:
			    {
				SET_BIT( forged_golem->guilds, MAR_TUUR );
				break;
			    }
			    case 3:
			    {
				SET_BIT( forged_golem->guilds, TOR_VAL );
				break;
			    }
			}
		    }
		    if ( race_table[ ch->race ][ ch->sex ].world == 0 )
		    {
			x = number_range( 1, 3 );
			switch ( x )
			{
			    case 1:
			    {
				SET_BIT( forged_golem->guilds, MIZUDAN );
				break;    
			    }
			    case 2:
			    {
				SET_BIT( forged_golem->guilds, CLANNGUARD );
				break;
			    }
			    case 3:
			    {
				SET_BIT( forged_golem->guilds, DHOZAN );
				break;
			    }
			}
		    }
		}
		else
		    forged_golem->guilds		= ch->guilds;
    		value /= 2;
    		for ( i = 0; i < MAX_STATS; i ++ )
        	    forged_golem->perm_stat[ i ]	= UMIN( 25, 11 + level / 4 );
	    }
	    else if ( titanium_magic >= ( ( ch->level * 3 ) * 3 / 2 ) )
	    {
		forged_golem = create_mobile( get_mob_index( TITANIUM_GOLEM ) );
		if ( forged_golem == NULL )
		{
		    bug ( "Not valid vnum for a golem.", 0 );
		    return;
		}

		level 					= ch->level;
		if ( obsidian_magic >= 50 )
		    for ( x = obsidian_magic ; x > 49 ; x -= 50 )
			level += 1;

    		value 					= level * level;
    		value 					= value + ( -1 * value ) % 10;
		forged_golem->level 			= UMIN( 100, level );
        	total 					= 100;
        	for ( x = 0 ; x < level ; x++ )
            	    total 				-= roll_dice( 2, 3 ) + 2;

		if ( adamantite_magic >= 50 )
		    for ( x = adamantite_magic ; x > 49 ; x -= 50 )
			total -= 15;

    		forged_golem->armor 			= total;
    		forged_golem->hitroll 			= level * 2 / 3;
    		forged_golem->damroll 			= level / 3;
    		forged_golem->damage[ 0 ] 		= ( ( 2 * ( level + 1 ) * ( level + 1 ) ) / ( 4 * level + 3 ) ) / 3 + 1;
    		forged_golem->damage[ 1 ] 		= ( ( 2 * ( level + 1 ) * ( level + 1 ) ) / ( 4 * level + 3 ) ) / 3 + 3;
    		forged_golem->damage[ 2 ] 		= level / 5;
    		forged_golem->hit 			= number_range( ch->max_hit - 100, ch->max_hit + 100 );
		if ( platinum_magic >= 20 )
		    for ( x = platinum_magic ; x > 19 ; x -= 20 )
			forged_golem->hit += 100;

    		forged_golem->max_hit 			= forged_golem->hit;
    		forged_golem->move 			= value;
    		forged_golem->max_move 			= value;
    		forged_golem->pIndexData->prac_skills 	= level * 2;
    		forged_golem->pIndexData->prac_spells 	= 0;
		if ( IS_SET( ch->guilds, MAJHERE ) )
		{
		    if ( race_table[ ch->race ][ ch->sex ].world == 0 )
		    {
			x = number_range( 1, 3 );
			switch ( x )
			{
			    case 1:
			    {
				SET_BIT( forged_golem->guilds, SCHRIES );
				break;    
			    }
			    case 2:
			    {
				SET_BIT( forged_golem->guilds, TATH );
				break;
			    }
			    case 3:
			    {
				SET_BIT( forged_golem->guilds, SUUR );
				break;
			    }
			}
		    }
		    if ( race_table[ ch->race ][ ch->sex ].world == 1 )
		    {
			x = number_range( 1, 3 );
			switch ( x )
			{
			    case 1:
			    {
				SET_BIT( forged_golem->guilds, TOH_KO_MERE );
				break;    
			    }
			    case 2:
			    {
				SET_BIT( forged_golem->guilds, MAR_TUUR );
				break;
			    }
			    case 3:
			    {
				SET_BIT( forged_golem->guilds, TOR_VAL );
				break;
			    }
			}
		    }
		    if ( race_table[ ch->race ][ ch->sex ].world == 0 )
		    {
			x = number_range( 1, 3 );
			switch ( x )
			{
			    case 1:
			    {
				SET_BIT( forged_golem->guilds, MIZUDAN );
				break;    
			    }
			    case 2:
			    {
				SET_BIT( forged_golem->guilds, CLANNGUARD );
				break;
			    }
			    case 3:
			    {
				SET_BIT( forged_golem->guilds, DHOZAN );
				break;
			    }
			}
		    }
		}
		else
		    forged_golem->guilds		= ch->guilds;
    		value /= 2;
    		for ( i = 0; i < MAX_STATS; i ++ )
        	    forged_golem->perm_stat[ i ]	= UMIN( 25, 11 + level / 4 );

        	for ( i = 0 ; i < MAX_ELEMENT_TYPE ; i++ )
        	{
        	    forged_golem->pIndexData->mana[ 0 ][ i ] 	= race_table[ forged_golem->race ][ forged_golem->sex ].mana_dice[ i ] * level;
        	    forged_golem->pIndexData->mana[ 1 ][ i ] 	= race_table[ forged_golem->race ][ forged_golem->sex ].mana_die[ i ];
        	    forged_golem->pIndexData->mana[ 2 ][ i ] 	= race_table[ forged_golem->race ][ forged_golem->sex ].mana_bonus[ i ] * level + 100;
		}

        	for ( i = 0 ; i < MAX_ELEMENT_TYPE ; i++ )
        	{
        	    forged_golem->max_mana[ i ] = roll_dice( forged_golem->pIndexData->mana[ DICE_NUMBER ][ i ], forged_golem->pIndexData->mana[ DICE_TYPE ][ i ] ) + forged_golem->pIndexData->mana[ DICE_BONUS ][ i ];
        	    forged_golem->mana[ i ]            = forged_golem->max_mana[ i ];
        	}
	    }
	    else if ( obsidian_magic >= ( ( ch->level * 3 ) * 3 / 2 ) )
	    {
		forged_golem = create_mobile( get_mob_index( OBSIDIAN_GOLEM ) );
		if ( forged_golem == NULL )
		{
		    bug ( "Not valid vnum for a golem.", 0 );
		    return;
		}

		level 					= ch->level;
		if ( obsidian_magic >= 50 )
		    for ( x = obsidian_magic ; x > 49 ; x -= 50 )
			level += 1;

    		value 					= level * level;
    		value 					= value + ( -1 * value ) % 10;
		forged_golem->level 			= UMIN( 100, level );
        	total 					= 100;
        	for ( x = 0 ; x < level ; x++ )
            	    total 				-= roll_dice( 2, 3 ) + 2;

		if ( adamantite_magic >= 50 )
		    for ( x = adamantite_magic ; x > 49 ; x -= 50 )
			total -= 15;

    		forged_golem->armor 			= total;
    		forged_golem->hitroll 			= level * 2 / 3;
    		forged_golem->damroll 			= level / 3;
    		forged_golem->damage[ 0 ] 		= ( ( 2 * ( level + 1 ) * ( level + 1 ) ) / ( 4 * level + 3 ) ) / 3 + 1;
    		forged_golem->damage[ 1 ] 		= ( ( 2 * ( level + 1 ) * ( level + 1 ) ) / ( 4 * level + 3 ) ) / 3 + 3;
    		forged_golem->damage[ 2 ] 		= level / 5;
    		forged_golem->hit 			= number_range( ch->max_hit - 100, ch->max_hit + 100 );
		if ( platinum_magic >= 20 )
		    for ( x = platinum_magic ; x > 19 ; x -= 20 )
			forged_golem->hit += 100;

    		forged_golem->max_hit 			= forged_golem->hit;
    		forged_golem->move 			= value;
    		forged_golem->max_move 			= value;
    		forged_golem->pIndexData->prac_skills 	= level * 2;
    		forged_golem->pIndexData->prac_spells 	= 0;
		if ( IS_SET( ch->guilds, MAJHERE ) )
		{
		    if ( race_table[ ch->race ][ ch->sex ].world == 0 )
		    {
			x = number_range( 1, 3 );
			switch ( x )
			{
			    case 1:
			    {
				SET_BIT( forged_golem->guilds, SCHRIES );
				break;    
			    }
			    case 2:
			    {
				SET_BIT( forged_golem->guilds, TATH );
				break;
			    }
			    case 3:
			    {
				SET_BIT( forged_golem->guilds, SUUR );
				break;
			    }
			}
		    }
		    if ( race_table[ ch->race ][ ch->sex ].world == 1 )
		    {
			x = number_range( 1, 3 );
			switch ( x )
			{
			    case 1:
			    {
				SET_BIT( forged_golem->guilds, TOH_KO_MERE );
				break;    
			    }
			    case 2:
			    {
				SET_BIT( forged_golem->guilds, MAR_TUUR );
				break;
			    }
			    case 3:
			    {
				SET_BIT( forged_golem->guilds, TOR_VAL );
				break;
			    }
			}
		    }
		    if ( race_table[ ch->race ][ ch->sex ].world == 0 )
		    {
			x = number_range( 1, 3 );
			switch ( x )
			{
			    case 1:
			    {
				SET_BIT( forged_golem->guilds, MIZUDAN );
				break;    
			    }
			    case 2:
			    {
				SET_BIT( forged_golem->guilds, CLANNGUARD );
				break;
			    }
			    case 3:
			    {
				SET_BIT( forged_golem->guilds, DHOZAN );
				break;
			    }
			}
		    }
		}
		else
		    forged_golem->guilds		= ch->guilds;
    		value /= 2;
    		for ( i = 0; i < MAX_STATS; i ++ )
        	    forged_golem->perm_stat[ i ]	= UMIN( 25, 11 + level / 4 );
	    }
	    else if ( mithril_magic >= ( ( ch->level * 3 ) * 3 / 2 ) )
	    {
		forged_golem = create_mobile( get_mob_index( MITHRIL_GOLEM ) );
		if ( forged_golem == NULL )
		{
		    bug ( "Not valid vnum for a golem.", 0 );
		    return;
		}

		level 					= ch->level;
		if ( obsidian_magic >= 50 )
		    for ( x = obsidian_magic ; x > 49 ; x -= 50 )
			level += 1;

    		value 					= level * level;
    		value 					= value + ( -1 * value ) % 10;
		forged_golem->level 			= UMIN( 100, level );
        	total 					= 100;
        	for ( x = 0 ; x < level ; x++ )
            	    total 				-= roll_dice( 2, 3 ) + 2;

		if ( adamantite_magic >= 50 )
		    for ( x = adamantite_magic ; x > 49 ; x -= 50 )
			total -= 15;

    		forged_golem->armor 			= total;
    		forged_golem->hitroll 			= level * 2 / 3;
    		forged_golem->damroll 			= level / 3;
    		forged_golem->damage[ 0 ] 		= ( ( 2 * ( level + 1 ) * ( level + 1 ) ) / ( 4 * level + 3 ) ) / 3 + 1;
    		forged_golem->damage[ 1 ] 		= ( ( 2 * ( level + 1 ) * ( level + 1 ) ) / ( 4 * level + 3 ) ) / 3 + 3;
    		forged_golem->damage[ 2 ] 		= level / 5;
    		forged_golem->hit 			= number_range( ch->max_hit - 100, ch->max_hit + 100 );
		if ( platinum_magic >= 20 )
		    for ( x = platinum_magic ; x > 19 ; x -= 20 )
			forged_golem->hit += 100;

    		forged_golem->max_hit 			= forged_golem->hit;
    		forged_golem->move 			= value;
    		forged_golem->max_move 			= value;
    		forged_golem->pIndexData->prac_skills 	= level * 2;
    		forged_golem->pIndexData->prac_spells 	= level * 2;
    		value /= 2;
    		for ( i = 0; i < MAX_STATS; i ++ )
        	    forged_golem->perm_stat[ i ]	= UMIN( 25, 11 + level / 4 );

        	for ( i = 0 ; i < MAX_ELEMENT_TYPE ; i++ )
        	{
        	    forged_golem->pIndexData->mana[ 0 ][ i ] 	= race_table[ forged_golem->race ][ forged_golem->sex ].mana_dice[ i ] * level;
        	    forged_golem->pIndexData->mana[ 1 ][ i ] 	= race_table[ forged_golem->race ][ forged_golem->sex ].mana_die[ i ];
        	    forged_golem->pIndexData->mana[ 2 ][ i ] 	= race_table[ forged_golem->race ][ forged_golem->sex ].mana_bonus[ i ] * level + 100;
		}

        	for ( i = 0 ; i < MAX_ELEMENT_TYPE ; i++ )
        	{
        	    forged_golem->max_mana[ i ] = roll_dice( forged_golem->pIndexData->mana[ DICE_NUMBER ][ i ], forged_golem->pIndexData->mana[ DICE_TYPE ][ i ] ) + forged_golem->pIndexData->mana[ DICE_BONUS ][ i ];
		    if ( mithril_magic >= 50 )
			for ( x = mithril_magic ; x > 49 ; x -= 50 )
			    forged_golem->max_mana[ i ] += 250;

        	    forged_golem->mana[ i ]            = forged_golem->max_mana[ i ];
        	}
	    }
	    else if ( platinum_magic >= ( ( ch->level * 3 ) * 3 / 2 ) )
	    {
		forged_golem = create_mobile( get_mob_index( PLATINUM_GOLEM ) );
		if ( forged_golem == NULL )
		{
		    bug ( "Not valid vnum for a golem.", 0 );
		    return;
		}

		level 					= ch->level;
		if ( obsidian_magic >= 50 )
		    for ( x = obsidian_magic ; x > 49 ; x -= 50 )
			level += 1;

    		value 					= level * level;
    		value 					= value + ( -1 * value ) % 10;
		forged_golem->level 			= UMIN( 100, level );
        	total 					= 100;
        	for ( x = 0 ; x < level ; x++ )
            	    total 				-= roll_dice( 2, 3 ) + 2;

		if ( adamantite_magic >= 50 )
		    for ( x = adamantite_magic ; x > 49 ; x -= 50 )
			total -= 15;

    		forged_golem->armor 			= total;
    		forged_golem->hitroll 			= level * 2 / 3;
    		forged_golem->damroll 			= level / 3;
    		forged_golem->damage[ 0 ] 		= ( ( 2 * ( level + 1 ) * ( level + 1 ) ) / ( 4 * level + 3 ) ) / 3 + 1;
    		forged_golem->damage[ 1 ] 		= ( ( 2 * ( level + 1 ) * ( level + 1 ) ) / ( 4 * level + 3 ) ) / 3 + 3;
    		forged_golem->damage[ 2 ] 		= level / 5;
    		forged_golem->hit 			= number_range( ch->max_hit - 100, ch->max_hit + 100 );
		if ( platinum_magic >= 20 )
		    for ( x = platinum_magic ; x > 19 ; x -= 20 )
			forged_golem->hit += 100;

    		forged_golem->max_hit 			= forged_golem->hit;
    		forged_golem->move 			= value;
    		forged_golem->max_move 			= value;
    		forged_golem->pIndexData->prac_skills 	= level * 2;
    		forged_golem->pIndexData->prac_spells 	= 0;
		if ( IS_SET( ch->guilds, MAJHERE ) )
		{
		    if ( race_table[ ch->race ][ ch->sex ].world == 0 )
		    {
			x = number_range( 1, 3 );
			switch ( x )
			{
			    case 1:
			    {
				SET_BIT( forged_golem->guilds, SCHRIES );
				break;    
			    }
			    case 2:
			    {
				SET_BIT( forged_golem->guilds, TATH );
				break;
			    }
			    case 3:
			    {
				SET_BIT( forged_golem->guilds, SUUR );
				break;
			    }
			}
		    }
		    if ( race_table[ ch->race ][ ch->sex ].world == 1 )
		    {
			x = number_range( 1, 3 );
			switch ( x )
			{
			    case 1:
			    {
				SET_BIT( forged_golem->guilds, TOH_KO_MERE );
				break;    
			    }
			    case 2:
			    {
				SET_BIT( forged_golem->guilds, MAR_TUUR );
				break;
			    }
			    case 3:
			    {
				SET_BIT( forged_golem->guilds, TOR_VAL );
				break;
			    }
			}
		    }
		    if ( race_table[ ch->race ][ ch->sex ].world == 0 )
		    {
			x = number_range( 1, 3 );
			switch ( x )
			{
			    case 1:
			    {
				SET_BIT( forged_golem->guilds, MIZUDAN );
				break;    
			    }
			    case 2:
			    {
				SET_BIT( forged_golem->guilds, CLANNGUARD );
				break;
			    }
			    case 3:
			    {
				SET_BIT( forged_golem->guilds, DHOZAN );
				break;
			    }
			}
		    }
		}
		else
		    forged_golem->guilds		= ch->guilds;
    		value /= 2;
    		for ( i = 0; i < MAX_STATS; i ++ )
        	    forged_golem->perm_stat[ i ]	= UMIN( 25, 11 + level / 4 );
	    }
	}
	else if ( steel_magic >= ( ( ch->level * 3 ) * 2 / 3 ) )
	{
		forged_golem = create_mobile( get_mob_index( STEEL_GOLEM ) );
		if ( forged_golem == NULL )
		{
		    bug ( "Not valid vnum for a golem.", 0 );
		    return;
		}

		level 					= ch->level;
		if ( obsidian_magic >= 50 )
		    for ( x = obsidian_magic ; x > 49 ; x -= 50 )
			level += 1;

    		value 					= level * level;
    		value 					= value + ( -1 * value ) % 10;
		forged_golem->level 			= UMIN( 100, level );
        	total 					= 100;
        	for ( x = 0 ; x < level ; x++ )
            	    total 				-= roll_dice( 2, 3 ) + 2;

		if ( adamantite_magic >= 50 )
		    for ( x = adamantite_magic ; x > 49 ; x -= 50 )
			total -= 15;

    		forged_golem->armor 			= total;
    		forged_golem->hitroll 			= level * 2 / 3;
    		forged_golem->damroll 			= level / 3;
    		forged_golem->damage[ 0 ] 		= ( ( 2 * ( level + 1 ) * ( level + 1 ) ) / ( 4 * level + 3 ) ) / 3 + 1;
    		forged_golem->damage[ 1 ] 		= ( ( 2 * ( level + 1 ) * ( level + 1 ) ) / ( 4 * level + 3 ) ) / 3 + 3;
    		forged_golem->damage[ 2 ] 		= level / 5;
    		forged_golem->hit 			= number_range( ch->max_hit - 100, ch->max_hit + 100 );
		if ( platinum_magic >= 20 )
		    for ( x = platinum_magic ; x > 19 ; x -= 20 )
			forged_golem->hit += 100;

    		forged_golem->max_hit 			= forged_golem->hit;
    		forged_golem->move 			= value;
    		forged_golem->max_move 			= value;
    		value /= 2;
    		for ( i = 0; i < MAX_STATS; i ++ )
        	    forged_golem->perm_stat[ i ]	= UMIN( 25, 11 + level / 4 );
	}

    if ( forged_golem == NULL )
	return;

    pick_skills( forged_golem );
    if ( race_table[ ch->race ][ ch->sex ].world == 0 )
    {
	x = number_range( 1, 3 );
	switch ( x )
        {
	    case 1:
	    {
    		if ( ( race = race_lookup( "nenkemen" ) ) == -1 )
    		{
    		    send_to_char( "Invalid race\n\r",ch);
		    extract_char( forged_golem, TRUE );
    		    return;
    		}
    		forged_golem->race = race;
		break;    
	    }
	    case 2:
	    {
    		if ( ( race = race_lookup( "maegmenel" ) ) == -1 )
    		{
    		    send_to_char( "Invalid race\n\r",ch);
		    extract_char( forged_golem, TRUE );
    		    return;
    		}
    		forged_golem->race = race;
		break;
	    }
	    case 3:
	    {
    		if ( ( race = race_lookup( "lithdor" ) ) == -1 )
    		{
    		    send_to_char( "Invalid race\n\r",ch);
		    extract_char( forged_golem, TRUE );
    		    return;
    		}
    		forged_golem->race = race;
		break;
	    }
	}
    }

    char_to_room( forged_golem, ch->in_room );
    if ( adamantite_magic >= 50 )
	send_to_char( "You made your golem tougher.\n\r", ch );

    if ( obsidian_magic >= 50 )
	send_to_char( "You made your golem bigger.\n\r", ch );

    if ( mithril_magic >= 50 )
	send_to_char( "You made your golem more magically inclined.\n\r", ch );

    if ( platinum_magic >= 50 )
	send_to_char( "You made your golem hardier.\n\r", ch );

    send_to_char( "\n\rYou finished making your golem.\n\r", ch );
    if ( skill > number_range( 1, 101 ) || titanium_magic > 0 )
    {
    	add_follower( forged_golem, ch );
    	forged_golem->leader = ch;
	SET_BIT( forged_golem->act, ACT_PET );
	SET_BIT( forged_golem->affected_by, AFF_CONTROL_MIND );
	forged_golem->comm = COMM_NOTELL|COMM_NOSHOUT|COMM_NOCHANNELS;
	ch->pet = forged_golem;
    }
    else
    {
	if ( number_range( 1, 10 ) == 1 )
	{
	    send_to_char( "Uh Oh!  The golem has turned on you!\n\r", ch );
            strncpy( forged_golem->dislikes, ch->name,30 );
            strncpy( forged_golem->hunting, ch->name,30 );
	}
    }

    check_improve( ch, gsn_golem_making, TRUE, 1 );
    return;
}

void do_forge_armor( CHAR_DATA *ch, char * argument )
{
    char short1[MAX_STRING_LENGTH];
    char short2[MAX_STRING_LENGTH];
    char short3[MAX_STRING_LENGTH];
    char name[MAX_STRING_LENGTH];
    char arg[MAX_INPUT_LENGTH];
    OBJ_DATA *hammer;
    OBJ_DATA *forged_armor;
    AFFECT_DATA *paf;
    int added, skill;
    int alabaster_magic, ruby_magic, diamond_magic, platinum_magic, silver_magic, mithril_magic;
    int titanium_magic, adamantite_magic, copper_magic, bronze_magic, iron_magic;
    int obsidian_magic, emerald_magic, sapphire_magic, steel_magic, total_magic, gem_magic;
    int bonus, max, max2, mana_chance, shortcheck = 0;

    one_argument( argument, arg );
    if ( !IS_SET( ch->in_room->room_flags, ROOM_FORGE ) )
    {
	send_to_char( "You need to be in a forge to forge armor.\n\r", ch );
	return;
    }

    if ( ( skill = get_skill( ch, gsn_armor_smithing ) ) <= 0 )
    {
        send_to_char("You don't know how to forge armor.\n\r", ch );
        return;
    }

    if ( arg[0] == '\0' )
    {
	send_to_char( "What kind of armor do you want to forge?(head, body, arms, legs, feet, hands, shield)\n\r", ch );
        return;
    }

    for ( hammer = ch->carrying; hammer != NULL && !IS_SET( hammer->extra_flags, ITEM_HAMMER ); hammer = hammer->next_content );

    if ( hammer == NULL )
    {
	send_to_char( "You need a hammer to forge.\n\r", ch );
	return;
    }

    if ( !IS_SET(ch->forge_flags, FORGE_COMPLETE ) )
    {
        act( "$n is pounding away at a forge trying to finish forging some armor.", ch, NULL, NULL, TO_ROOM );
	SET_BIT(ch->forge_flags, IS_FORGING );
	strncpy( ch->forge_item, arg, 10 );
	ch->forge_from = 2;
	ch->forge_count = 5;
	send_to_char("You prepare the oven and the anvil for forging.\n\r",ch);
	return;
    }

    REMOVE_BIT(ch->forge_flags, FORGE_COMPLETE );

    steel_magic = ch->pcdata->forge[MINERAL_STEEL];
    diamond_magic = ch->pcdata->forge[MINERAL_DIAMOND];
    silver_magic = ch->pcdata->forge[MINERAL_SILVER];
    sapphire_magic = ch->pcdata->forge[MINERAL_SAPPHIRE];
    ruby_magic = ch->pcdata->forge[MINERAL_RUBY];
    emerald_magic = ch->pcdata->forge[MINERAL_EMERALD];
    mithril_magic = ch->pcdata->forge[MINERAL_MITHRIL];
    obsidian_magic = ch->pcdata->forge[MINERAL_OBSIDIAN];
    platinum_magic = ch->pcdata->forge[MINERAL_PLATINUM];
    copper_magic = ch->pcdata->forge[MINERAL_COPPER];
    iron_magic = ch->pcdata->forge[MINERAL_IRON];
    bronze_magic = ch->pcdata->forge[MINERAL_BRONZE];
    adamantite_magic = ch->pcdata->forge[MINERAL_ADAMANTITE];
    titanium_magic = ch->pcdata->forge[MINERAL_TITANIUM];
    alabaster_magic = ch->pcdata->forge[MINERAL_ALABASTER];
    total_magic = copper_magic + iron_magic + bronze_magic + adamantite_magic + alabaster_magic + steel_magic + ruby_magic + sapphire_magic + emerald_magic + silver_magic + diamond_magic;
    gem_magic = copper_magic + iron_magic + bronze_magic + adamantite_magic + alabaster_magic + ruby_magic + sapphire_magic + emerald_magic + silver_magic + diamond_magic;

    if ( !str_cmp( arg, "head" ) )
    {
	if ( steel_magic < 10 )
	{
	    send_to_char( "There isn't enough steel in the forge.\n\r", ch );
	    return;
	}
	
	extract_mineral( ch );
	
	if ( skill > number_range( 1, 101 ) )
	    forged_armor = create_object( get_obj_index( OBJ_VNUM_FORGE_HEAD ) );
	else
	{
	    send_to_char( "You failed at your attemped at making head armor.\n\r", ch );
            check_improve( ch, gsn_armor_smithing, FALSE, 1 );
	    return;
	}


	if ( steel_magic >= 60 )
	{
	    forged_armor->wear_data->ac = 12;
	    forged_armor->wear_data->weight = 15;
	    sprintf(short1, "a full plate helm");
	    strncpy( forged_armor->description, "A full plate helm lies here.\n\r", 80 );
	}
	else if ( steel_magic >=50 )
	{
	    forged_armor->wear_data->ac = 10;
	    forged_armor->wear_data->weight = 12;
	    sprintf(short1, "a field plate helm");
	    strncpy( forged_armor->description, "A field plate helm lies here.\n\r", 80 );
	}
	else if ( steel_magic >= 40 )
	{
	    forged_armor->wear_data->ac = 8;
	    forged_armor->wear_data->weight = 10;
	    sprintf(short1,"a plate helm");
	    strncpy( forged_armor->description, "A plate helm lies here.\n\r", 80 );
	}
	else if ( steel_magic >= 30 )
	{
	    forged_armor->wear_data->ac = 7;
	    forged_armor->wear_data->weight = 8;
	    sprintf(short1, "a scale mail helm");
	    strncpy( forged_armor->description, "A scail mail helm lies here.\n\r", 80 );
	}
	else if ( steel_magic >= 20 )
	{
	    forged_armor->wear_data->ac = 6;
	    forged_armor->wear_data->weight = 4;
	    sprintf(short1, "a ring mail coif");
	    strncpy( forged_armor->description, "A ring mail coif lies here.\n\r", 80 );
	}
	else
	{
	    sprintf(short1, "a chain mail coif");
	    strncpy( forged_armor->description, "A chain mail coif lies here.\n\r", 80 );
	}
    }
    else if ( !str_cmp( arg, "body" ) )
    {
	if ( steel_magic < 100 )
	{
	    send_to_char( "There isn't enough steel in the forge.\n\r", ch );
	    return;
	}
	
	extract_mineral( ch );
	
	if ( skill > number_range( 1, 101 ) )
	    forged_armor = create_object( get_obj_index( OBJ_VNUM_FORGE_BODY ) );
	else
	{
	    send_to_char( "You failed at your attemped at making body armor.\n\r", ch );
            check_improve( ch, gsn_armor_smithing, FALSE, 1 );
	    return;
	}

	if ( steel_magic >= 350 )
	{
	    forged_armor->wear_data->ac = 12;
	    forged_armor->wear_data->weight = 80;
	    sprintf(short1, "a full body plate");
	    strncpy( forged_armor->description, "A full body plate lies here.\n\r", 80 );
	}
	else if ( steel_magic >= 300 )
	{
	    forged_armor->wear_data->ac = 10;
	    forged_armor->wear_data->weight = 70;
	    sprintf(short1, "a field body plate");
	    strncpy( forged_armor->description, "A field body plate lies here.\n\r", 80 );
	}
	else if ( steel_magic >= 250 )
	{
	    forged_armor->wear_data->ac = 8;
	    forged_armor->wear_data->weight = 50;
	    sprintf(short1, "a body plate");
	    strncpy( forged_armor->description, "A body plate lies here.\n\r", 80 );
	}
	else if ( steel_magic >= 200 )
	{
	    forged_armor->wear_data->ac = 7;
	    forged_armor->wear_data->weight = 40;
	    sprintf(short1, "a scale mail vest");
	    strncpy( forged_armor->description, "A scale mail vest lies here.\n\r", 80 );
	}
	else if ( steel_magic >= 150 )
	{
	    forged_armor->wear_data->ac = 6;
	    forged_armor->wear_data->weight = 30;
	    sprintf(short1, "a ring mail vest");
	    strncpy( forged_armor->description , "A ring mail vest lies here.\n\r", 80 );
	}
	else
	{
	    sprintf(short1, "a chain mail vest");
	    strncpy( forged_armor->description, "A chain mail vest lies here.\n\r", 80 );
	}
    }
    else if ( !str_cmp( arg, "arms" ) )
    {
	if ( steel_magic < 10 )
	{
	    send_to_char( "There isn't enough steel in the forge.\n\r", ch );
	    return;
	}
	
	extract_mineral( ch );
	
	if ( skill > number_range( 1, 101 ) )
	    forged_armor = create_object( get_obj_index( OBJ_VNUM_FORGE_ARMS ) );
	else
	{
	    send_to_char( "You failed at your attemped at making arm armor.\n\r", ch );
            check_improve( ch, gsn_armor_smithing, FALSE, 1 );
	    return;
	}

	if ( steel_magic >= 60 )
	{
	    forged_armor->wear_data->ac = 12;
	    forged_armor->wear_data->weight = 50;
	    sprintf(short1, "a pair of full plate vambraces");
	    strncpy( forged_armor->description, "A pair of full plate vambraces lie here.\n\r", 80 );
	}
	else if ( steel_magic >= 50 )
	{
	    forged_armor->wear_data->ac = 10;
	    forged_armor->wear_data->weight = 40;
	    sprintf(short1, "a pair of field plate vambraces");
	    strncpy( forged_armor->description, "A pair of field plate vambraces lie here.\n\r", 80 );
	}
	else if ( steel_magic >= 40 )
	{
	    forged_armor->wear_data->ac = 8;
	    forged_armor->wear_data->weight = 30;
	    sprintf(short1, "a pair of plate vambraces");
	    strncpy( forged_armor->description, "A pair of plate vambraces lie here.\n\r", 80 );
	}
	else if ( steel_magic >= 30 )
	{
	    forged_armor->wear_data->ac = 7;
	    forged_armor->wear_data->weight = 20;
	    sprintf(short1, "a pair of scale sleeves");
	    strncpy( forged_armor->description, "A pair of scale sleeves lie here.\n\r", 80 );
	}
	else if ( steel_magic >= 20 )
	{
	    forged_armor->wear_data->ac = 6;
	    forged_armor->wear_data->weight = 15;
	    sprintf(short1, "a pair of ring mail sleeves");
	    strncpy( forged_armor->description, "A pair of ring mail sleeves lie here.\n\r", 80 );
	}
	else
	{
	    sprintf(short1, "a pair of chain mail sleeves");
	    strncpy( forged_armor->description, "A pair of chain mail sleeves lie here.\n\r", 80 );
	}
    }
    else if ( !str_cmp( arg, "legs" ) )
    {
	if ( steel_magic < 150 )
	{
	    send_to_char( "There isn't enough steel in the forge.\n\r", ch );
	    return;
	}
	
	extract_mineral( ch );
	
	if ( skill > number_range( 1, 101 ) )
	    forged_armor = create_object( get_obj_index( OBJ_VNUM_FORGE_LEGS ) );
	else
	{
	    send_to_char( "You failed at your attemped at making leg armor.\n\r", ch );
            check_improve( ch, gsn_armor_smithing, FALSE, 1 );
	    return;
	}

	if ( steel_magic >= 200 )
	{
	    forged_armor->wear_data->ac = 12;
	    forged_armor->wear_data->weight = 50;
	    sprintf(short1, "a pair of full plate greaves");
	    strncpy( forged_armor->description, "A pair of full plate greaves lie here.\n\r", 80 );
	}
	else if ( steel_magic >= 190 )
	{
	    forged_armor->wear_data->ac = 10;
	    forged_armor->wear_data->weight = 40;
	    sprintf(short1, "a pair of field plate greaves");
	    strncpy( forged_armor->description, "A pair of field plate greaves lie here.\n\r", 80 );
	}
	else if ( steel_magic >= 180 )
	{
	    forged_armor->wear_data->ac = 8;
	    forged_armor->wear_data->weight = 30;
	    sprintf(short1, "a pair of plate greaves");
	    strncpy( forged_armor->description, "A pair of plate greaves lie here.\n\r", 80 );
	}
	else if ( steel_magic >= 170 )
	{
	    forged_armor->wear_data->ac = 7;
	    forged_armor->wear_data->weight = 20;
	    sprintf(short1, "a pair of scale pants");
	    strncpy( forged_armor->description, "A pair of scale pants lie here.\n\r", 80 );
	}
	else if ( steel_magic >= 160 )
	{
	    forged_armor->wear_data->ac = 6;
	    forged_armor->wear_data->weight = 15;
	    sprintf(short1, "a pair of ring mail pants");
	    strncpy( forged_armor->description, "A pair of ring mail pants lie here.\n\r", 80 );
	}
	else
	{
	    sprintf(short1, "a pair of chain mail pants");
	    strncpy( forged_armor->description, "A pair of chain mail pants lie here.\n\r", 80 );
	}
    }
    else if ( !str_cmp( arg, "feet" ) )
    {
	if ( steel_magic < 60 )
	{
	    send_to_char( "There isn't enough steel in the forge.\n\r", ch );
	    return;
	}
	
	extract_mineral( ch );
	
	if ( skill > number_range( 1, 101 ) )
	    forged_armor = create_object( get_obj_index( OBJ_VNUM_FORGE_FEET ) );
	else
	{
	    send_to_char( "You failed at your attemped at making foot armor.\n\r", ch );
            check_improve( ch, gsn_armor_smithing, FALSE, 1 );
	    return;
	}

	if ( steel_magic >= 110 )
	{
	    forged_armor->wear_data->ac = 12;
	    forged_armor->wear_data->weight = 30;
	    sprintf(short1, "a pair of full plate boots");
	    strncpy( forged_armor->description, "A pair of full plate boots lie here.\n\r", 80 );
	}
	else if ( steel_magic >= 100 )
	{
	    forged_armor->wear_data->ac = 10;
	    forged_armor->wear_data->weight = 25;
	    sprintf(short1, "a pair of field plate boots");
	    strncpy( forged_armor->description, "A pair of field plate boots lie here.\n\r", 80 );
	}
	else if ( steel_magic >= 90 )
	{
	    forged_armor->wear_data->ac = 8;
	    forged_armor->wear_data->weight = 20;
	    sprintf(short1, "a pair of plate boots");
	    strncpy( forged_armor->description, "A pair of plate boots lie here.\n\r", 80 );
	}
	else if ( steel_magic >= 80 )
	{
	    forged_armor->wear_data->ac = 7;
	    forged_armor->wear_data->weight = 15;
	    sprintf(short1, "a pair of scale boots");
	    strncpy( forged_armor->description, "A pair of scale boots lie here.\n\r", 80 );
	}
	else if ( steel_magic >= 70 )
	{
	    forged_armor->wear_data->ac = 6;
	    forged_armor->wear_data->weight = 10;
	    sprintf(short1, "a pair of ring mail boots");
	    strncpy( forged_armor->description, "A pair of ring mail boots lie here.\n\r", 80 );
	}
	else
	{
	    sprintf(short1, "a pair of chain mail boots");
	    strncpy( forged_armor->description, "A pair of chain mail boots lie here.\n\r", 80 );
	}
    }
    else if ( !str_cmp( arg, "shield" ) )
    {
	if ( steel_magic < 50 )
	{
	    send_to_char( "There isn't enough steel in the forge.\n\r", ch );
	    return;
	}
	
	extract_mineral( ch );
	
	if ( skill > number_range( 1, 101 ) )
	    forged_armor = create_object( get_obj_index( OBJ_VNUM_FORGE_SHIELD ) );
	else
	{
	    send_to_char( "You failed at your attemped at making a shield.\n\r", ch );
            check_improve( ch, gsn_armor_smithing, FALSE, 1 );
	    return;
	}

	if ( steel_magic >= 150 )
	{
	    forged_armor->wear_data->ac = 7;
	    forged_armor->wear_data->weight = 50;
	    sprintf(short1, "a tower shield");
	    strncpy( forged_armor->description, "A tower shield lies here.\n\r", 80 );
	}
	else if ( steel_magic >= 130 )
	{
	    forged_armor->wear_data->ac = 5;
	    forged_armor->wear_data->weight = 40;
	    sprintf(short1, "a large shield");
	    strncpy( forged_armor->description, "A large shield lies here.\n\r", 80 );
	}
	else if ( steel_magic >= 110 )
	{
	    forged_armor->wear_data->ac = 4;
	    forged_armor->wear_data->weight = 30;
	    sprintf(short1, "a medium shield");
	    strncpy( forged_armor->description, "A medium shield lies here.\n\r", 80 );
	}
	else if ( steel_magic >= 90 )
	{
	    forged_armor->wear_data->ac = 3;
	    forged_armor->wear_data->weight = 15;
	    sprintf(short1, "a small shield");
	    strncpy( forged_armor->description, "A small shield lies here.\n\r", 80 );
	}
	else
	{
	    sprintf(short1, "a buckler");
	    strncpy( forged_armor->description, "A buckler lies here.\n\r", 80 );
	    SET_BIT( forged_armor->extra_flags, ITEM_BUCKLER );
	}
    }
    else if ( !str_cmp( arg, "hands" ) )
    {
	if ( steel_magic < 15 )
	{
	    send_to_char( "There isn't enough steel in the forge.\n\r", ch );
	    return;
	}
	
	extract_mineral( ch );
	
	if ( skill > number_range( 1, 101 ) )
	    forged_armor = create_object( get_obj_index( OBJ_VNUM_FORGE_HANDS ) );
	else
	{
	    send_to_char( "You failed at your attemped at making hand armor.\n\r", ch );
            check_improve( ch, gsn_armor_smithing, FALSE, 1 );
	    return;
	}

	if ( steel_magic >= 65 )
	{
	    forged_armor->wear_data->ac = 12;
	    forged_armor->wear_data->weight = 15;
	    sprintf(short1, "a pair of full plate gauntlets");
	    strncpy( forged_armor->description, "A pair of full plate gauntlets lie here.\n\r", 80 );
	}
	else if ( steel_magic >= 55 )
	{
	    forged_armor->wear_data->ac = 10;
	    forged_armor->wear_data->weight = 13;
	    sprintf(short1, "a pair of field plate gauntlets");
	    strncpy( forged_armor->description, "A pair of field plate gauntlets lie here.\n\r", 80 );
	}
	else if ( steel_magic >= 45 )
	{
	    forged_armor->wear_data->ac = 8;
	    forged_armor->wear_data->weight = 11;
	    sprintf(short1, "a pair of plate gauntlets");
	    strncpy( forged_armor->description, "A pair of plate gauntlets lie here.\n\r", 80 );
	}
	else if ( steel_magic >= 34 )
	{
	    forged_armor->wear_data->ac = 7;
	    forged_armor->wear_data->weight = 9;
	    sprintf(short1, "a pair of scale gloves");
	    strncpy( forged_armor->description, "A pair of scale gloves lie here.\n\r", 80 );
	}
	else if ( steel_magic >= 25 )
	{
	    forged_armor->wear_data->ac = 6;
	    forged_armor->wear_data->weight = 7;
	    sprintf(short1, "a pair of ring mail gloves");
	    strncpy( forged_armor->description, "A pair of ring mail gloves lie here.\n\r", 80 );
	}
	else
	{
	    sprintf(short1, "a pair of chain mail gloves");
	    strncpy( forged_armor->description, "A pair of chain mail gloves lie here.\n\r", 80 );
	}
    }
    else
    {
	send_to_char( "What kind of armor do you want to forge?(head, arms, body, legs, feet, hands, shield)\n\r", ch );
	return;
    }

    bonus = skill; 
    max = 0;
    max2 = 0;
    if ( hammer->pIndexData->vnum == VNUM_HAMMER_1 )
	bonus += 25;

    if ( total_magic > 0 )
    {
	if ( gem_magic > 0 )
	{
	    bonus = bonus + obsidian_magic + platinum_magic + mithril_magic;

	    if ( silver_magic >= ( ( steel_magic ) * 2 / 3 ) && max < 2 )
	    {
		if ( titanium_magic > 0 || bonus > number_range( 1, 125 ) )
		{
		    titanium_magic = 0;
		    max++;
		    sprintf(short2, " of precision");
		    shortcheck++;
		    added = number_range(1, 5);

	    	    if ( number_range( 1, 102 - skill ) == 2 )
			added = added + number_range( 1, 5 );

	    	    paf = new_affect(FALSE);
            	    paf->type       = -1;
            	    paf->duration   = -1;
            	    paf->location   = APPLY_HITROLL;
            	    paf->modifier   = added;
            	    paf->bitvector  = 0;
		    paf->next	= forged_armor->wear_data->affected;
            	    forged_armor->wear_data->affected	= paf;
		    SET_BIT( forged_armor->extra_flags, ITEM_MAGIC );
		}
	    }

	    if ( copper_magic >= ( ( steel_magic ) * 2 / 3 ) && max < 2 )
	    {
		if ( titanium_magic > 0 || bonus > number_range( 1, 125 ) )
		{
		    titanium_magic = 0;
		    if ( number_range( 1, 102 - skill ) == 1 )
		    {
		    	max++;
			if ( shortcheck == 1 )
			    sprintf(short3, " and agility");
			else sprintf(short2, " of agility");
			shortcheck++;

	    	    	paf = new_affect(FALSE);
            	    	paf->duration   = -1;
            	    	paf->location   = APPLY_DEX;
			paf->type	= -1;
            	        paf->bitvector = 0;

			if ( number_range( 1, URANGE( 2, 200 - ( bonus + ch->level ), 200 ) ) == 1 )
            	    	    paf->modifier   = 3;
			else
            	    	    paf->modifier   = number_range(1, 2);

		    	paf->next	= forged_armor->wear_data->affected;
            	    	forged_armor->wear_data->affected = paf;
		    	SET_BIT( forged_armor->extra_flags, ITEM_MAGIC );
		    }
		}
	    }

	    if ( iron_magic >= ( ( steel_magic ) * 2 / 3 ) && max < 2 )
	    {
		if ( titanium_magic > 0 || bonus > number_range( 1, 125 ) )
		{
		    titanium_magic = 0;
		    if ( number_range( 1, 102 - skill ) == 1 )
		    {
		    	max++;
			if ( shortcheck == 1 )
			    sprintf(short3, " and giant strength");
			else sprintf(short2, " of giant strength");
			shortcheck++;
	    	    	paf = new_affect(FALSE);
            	    	paf->duration   = -1;
            	    	paf->location   = APPLY_STR;
			paf->type	= -1;
            	    	paf->bitvector = 0;

			if ( number_range( 1, URANGE( 2, 200 - ( bonus + ch->level ), 200 ) ) == 1 )
            	    	    paf->modifier   = 3;
			else
            	    	    paf->modifier   = number_range(1, 2);

		    	paf->next	= forged_armor->wear_data->affected;
            	    	forged_armor->wear_data->affected = paf;
		    	SET_BIT( forged_armor->extra_flags, ITEM_MAGIC );
		    }
		}
	    }

	    if ( bronze_magic >= ( ( steel_magic ) * 2 / 3 ) && max < 2 )
	    {
		if ( titanium_magic > 0 || bonus > number_range( 1, 125 ) )
		{
		    titanium_magic = 0;
		    if ( number_range( 1, 102 - skill ) == 1 )
		    {
		    	max++;
			if ( shortcheck == 1 )
			    sprintf(short3, " and endurance");
			else sprintf(short2, " of endurance");
			shortcheck++;
	    	    	paf = new_affect(FALSE);
            	    	paf->duration   = -1;
            	    	paf->location   = APPLY_CON;
			paf->type	= -1;
            	    	paf->bitvector = 0;

			if ( number_range( 1, URANGE( 2, 200 - ( bonus + ch->level ), 200 ) ) == 1 )
            	    	    paf->modifier   = 3;
			else
            	    	    paf->modifier   = number_range(1, 2);

		    	paf->next	= forged_armor->wear_data->affected;
            	    	forged_armor->wear_data->affected = paf;
		    	SET_BIT( forged_armor->extra_flags, ITEM_MAGIC );
		    }
		}
	    }

	    if ( ruby_magic >= ( ( steel_magic ) * 2 / 3 ) && max < 2 )
	    {
		if ( titanium_magic > 0 || bonus > number_range( 1, 125 ) )
		{
		    titanium_magic = 0;
		    if ( number_range( 1, 102 - skill ) == 1 )
		    {
		    	max++;
			if ( shortcheck == 1 )
			    sprintf(short3, " and fire resistance");
			else sprintf(short2, " of fire resistance");
			shortcheck++;
	    	    	paf = new_affect(FALSE);
            	    	paf->duration   = -1;
            	    	paf->location   = APPLY_AFFECT;
            	    	paf->modifier   = 0;
			paf->type	= -1;

			if ( number_range( 1, URANGE( 2, 200 - ( bonus + ch->level ), 200 ) ) == 1 )
			{
			    SET_BIT(forged_armor->extra_flags, ITEM_HUM);
			    paf->bit_type	= BIT_IMM;
            	    	    paf->bitvector = IMM_FIRE;
			}
			else
			{
			    paf->bit_type  = BIT_RES;
			    paf->bitvector = RES_FIRE;
			}

		    	paf->next	= forged_armor->wear_data->affected;
            	    	forged_armor->wear_data->affected = paf;
		    	SET_BIT( forged_armor->extra_flags, ITEM_MAGIC );
		    }
		}
	    }

	    if ( sapphire_magic >= ( ( steel_magic ) * 2 / 3 ) && max < 2 )
	    {
		if ( titanium_magic > 0 || bonus > number_range( 1, 125 ) )
		{
		    titanium_magic = 0;
		    if ( number_range( 1, 102 - skill ) == 1 )
		    {
		    	max++;
			if ( shortcheck == 1 )
			    sprintf(short3, " and water resistance");
			else sprintf(short2, " of water resistance");
			shortcheck++;
	    	    	paf = new_affect(FALSE);
            	    	paf->duration   = -1;
            	    	paf->location   = APPLY_AFFECT;
            	    	paf->modifier   = 0;
			paf->type	= -1;

			if ( number_range( 1, URANGE( 2, 200 - ( bonus + ch->level ), 200 ) ) == 1 )
			{
			    SET_BIT(forged_armor->extra_flags, ITEM_HUM);
			    paf->bit_type	= BIT_IMM;
            	    	    paf->bitvector = IMM_WATER;
			}
			else
			{
			    paf->bit_type  = BIT_RES;
			    paf->bitvector = RES_WATER;
			}

		    	paf->next	= forged_armor->wear_data->affected;
            	    	forged_armor->wear_data->affected = paf;
		    	SET_BIT( forged_armor->extra_flags, ITEM_MAGIC );
		    }
		}
	    }

	    if ( emerald_magic >= ( ( steel_magic ) * 2 / 3 ) && max < 2 )
	    {
		if ( titanium_magic > 0 || bonus > number_range( 1, 125 ) )
		{
		    titanium_magic = 0;
		    max++;
		    added = URANGE( 1, number_range( 2 * ch->level, skill * 3 ), 250 );
			if ( shortcheck == 1 )
			    sprintf(short3, " and mana");
			else sprintf(short2, " of mana");
		    shortcheck++;
	    	    if ( number_range( 1, 102 - skill ) == 2 )
			added = added + number_range( 50, 100 );

	    	    paf = new_affect(FALSE);
            	    paf->type       = -1;
            	    paf->duration   = -1;
		    mana_chance = number_range(1, 5);
		    if ( mana_chance == 1 )
			paf->location = APPLY_MANA_FIRE;
		    else if ( mana_chance == 2 )
			paf->location = APPLY_MANA_WATER;
		    else if ( mana_chance == 3 )
			paf->location = APPLY_MANA_EARTH;
		    else if ( mana_chance == 4 )
			paf->location = APPLY_MANA_WIND;
		    else
			paf->location = APPLY_MANA_SPIRIT;
            	    paf->modifier   = added;
            	    paf->bitvector  = 0;
		    paf->next	= forged_armor->wear_data->affected;
            	    forged_armor->wear_data->affected	= paf;
		    SET_BIT( forged_armor->extra_flags, ITEM_MAGIC );
		}
	    }

	    if ( diamond_magic >= ( ( steel_magic ) * 2 / 3 ) && max < 2 )
	    {
		if ( titanium_magic > 0 || bonus > number_range( 1, 125 ) )
		{
		    titanium_magic = 0;
                    max++;
			if ( shortcheck == 1 )
			    sprintf(short3, " and diamond spikes");
			else sprintf(short2, " of diamond spikes");
		    shortcheck++;
                    added = URANGE( 1, skill / 15, 4 );

                    if ( number_range( 1, 102 - skill ) == 2 )
                        added = added + number_range( 1, 2 );

                    paf = new_affect(FALSE);
                    paf->type       = -1;
                    paf->duration   = -1;
                    paf->location   = APPLY_DAMROLL;
                    paf->modifier   = added;
                    paf->bitvector  = 0;
                    paf->next   = forged_armor->wear_data->affected;
                    forged_armor->wear_data->affected  = paf;
                    SET_BIT( forged_armor->extra_flags, ITEM_MAGIC );
                }
            }

	    if ( alabaster_magic >= ( ( steel_magic ) * 2 / 3 ) && max < 2 )
	    {
		if ( titanium_magic > 0 || bonus > number_range( 1, 125 ) )
		{
		    if ( ( titanium_magic > 0 || number_range( 1, URANGE( 1, 200 - ( bonus + ch->level ), 200 ) ) == 1 ) && max2 < 1 && alabaster_magic >= ( steel_magic ) * 3 / 2 )
		    {
		    	titanium_magic = 0;
			if ( number_range(1, 100) > 30 )
			{
		    	    added = URANGE( 1, number_range( 5 * ch->level, skill * 3 ), 250 );

	    	    	    if ( number_range( 1, 102 - skill ) == 2 )
			    	added = added + number_range( 50, 100 );

	    	    	    paf = new_affect(FALSE);
            	    	    paf->type       = -1;
            	    	     paf->duration   = -1;
            	    	    paf->location   = APPLY_MANA;
            	    	    paf->modifier   = added;
            	    	    paf->bitvector  = 0;
		    	    paf->next	= forged_armor->wear_data->affected;
            	    	    forged_armor->wear_data->affected	= paf;
		    	    SET_BIT( forged_armor->extra_flags, ITEM_MAGIC );
			    SET_BIT( forged_armor->extra_flags, ITEM_HUM );
			    max2++;
			}
		    }
		
		    max++;
			if ( shortcheck == 1 )
			    sprintf(short3, " and the majhere");
			else sprintf(short2, " of the majhere");
		    shortcheck++;
		    added = URANGE( 1, number_range( 5 * ch->level, skill * 2 ), 200 );

	    	    if ( number_range( 1, 102 - skill ) == 2 )
			added = added + number_range( 50, 100 );

	    	    paf = new_affect(FALSE);
            	    paf->type       = -1;
            	    paf->duration   = -1;
            	    paf->location   = APPLY_MANA;
            	    paf->modifier   = added;
            	    paf->bitvector  = 0;
		    paf->next	= forged_armor->wear_data->affected;
            	    forged_armor->wear_data->affected	= paf;
		    SET_BIT( forged_armor->extra_flags, ITEM_MAGIC );
		}
	    }

	    if ( adamantite_magic >= ( ( steel_magic ) * 2 / 3 ) && max < 2 )
	    {
		if ( titanium_magic > 0 || bonus > number_range( 1, 125 ) )
		{
		    if ( ( titanium_magic > 0 || number_range( 1, URANGE( 1, 200 - ( bonus + ch->level ), 200 ) ) == 1 ) && max2 < 1 && adamantite_magic >= ( steel_magic ) * 3 / 2 )
		    {
		    	titanium_magic = 0;
			if ( number_range(1, 100) > 30 )
			{
			    SET_BIT(forged_armor->extra_flags, ITEM_HUM );
			    send_to_char( "You feel strong magic working with your forging!\n\r", ch );
			    forged_armor->wear_data->ac = forged_armor->wear_data->ac + 10;
			    max2++;
			}
		    }
		
		    max++;
			if ( shortcheck == 1  )
			    sprintf(short3, " and protection");
			else sprintf(short2, " of protection");
		    shortcheck++;
	    	    added = URANGE( 1, skill / 15, 4 );

	    	    if ( number_range( 1, 102 - skill ) == 2 )
			added = added + number_range( 1, 2 );
		    forged_armor->wear_data->ac = forged_armor->wear_data->ac + added;
		    SET_BIT( forged_armor->extra_flags, ITEM_MAGIC );
		}
	    }
	}

    }

    if ( shortcheck >= 1 )
	strcat( short1, short2 );
    if ( shortcheck >= 2 )
	strcat( short1, short3 );

    sprintf( name, " `Rforged by %s`w", ch->name );
    strcat( short1, name );
    strncpy( forged_armor->short_descr, short1, 80 );
    forged_armor->wear_data->cost = 0;
    obj_to_char( forged_armor, ch );
    send_to_char( "\n\rYou finished forging your new armor.\n\r", ch );
    check_improve( ch, gsn_armor_smithing, TRUE, 1 );
    return;
}

void do_forge_weapon( CHAR_DATA *ch, char * argument )
{
    char short1[MAX_STRING_LENGTH];
    char short2[MAX_STRING_LENGTH];
    char short3[MAX_STRING_LENGTH];
    char short4[MAX_STRING_LENGTH];
    char name[MAX_STRING_LENGTH];
    char arg[MAX_INPUT_LENGTH];
    OBJ_DATA *hammer;
    OBJ_DATA *forged_weapon;
    AFFECT_DATA *paf;
    int added, skill;
    int alabaster_magic, ruby_magic, diamond_magic, platinum_magic, silver_magic, mithril_magic;
    int titanium_magic, adamantite_magic, copper_magic, bronze_magic, iron_magic;
    int obsidian_magic, emerald_magic, sapphire_magic, steel_magic, total_magic, gem_magic;
    int bonus, max, max2, mana_chance, shortcheck = 0;

    one_argument( argument, arg );
    if ( !IS_SET( ch->in_room->room_flags, ROOM_FORGE ) )
    {
	send_to_char( "You need to be in a forge to forge a weapon.\n\r", ch );
	return;
    }

    if ( ( skill = get_skill( ch, gsn_weapon_smithing ) ) <= 0 )
    {
        send_to_char("You don't know how to forge weapons.\n\r", ch );
        return;
    }

    if ( arg[0] == '\0' )
    {
	send_to_char( "What kind of weapon do you want to forge?(sword, dagger, polearm, mace, axe, spear)\n\r", ch );
        return;
    }

    for ( hammer = ch->carrying; hammer != NULL && !IS_SET( hammer->extra_flags, ITEM_HAMMER ); hammer = hammer->next_content );

    if ( hammer == NULL )
    {
	send_to_char( "You need a hammer to forge.\n\r", ch );
	return;
    }

    if ( !IS_SET(ch->forge_flags, FORGE_COMPLETE ) )
    {
        act( "$n is pounding away at a forge trying to finish forging a weapon.", ch, NULL, NULL, TO_ROOM );
	SET_BIT(ch->forge_flags, IS_FORGING );
	strncpy( ch->forge_item, arg, 10 );
	ch->forge_from = 1;
	ch->forge_count = 5;
	send_to_char("You prepare the oven and the anvil for forging.\n\r",ch);
	return;
    }

    REMOVE_BIT(ch->forge_flags, FORGE_COMPLETE );

    steel_magic = ch->pcdata->forge[MINERAL_STEEL];
    diamond_magic = ch->pcdata->forge[MINERAL_DIAMOND];
    silver_magic = ch->pcdata->forge[MINERAL_SILVER];
    sapphire_magic = ch->pcdata->forge[MINERAL_SAPPHIRE];
    ruby_magic = ch->pcdata->forge[MINERAL_RUBY];
    emerald_magic = ch->pcdata->forge[MINERAL_EMERALD];
    mithril_magic = ch->pcdata->forge[MINERAL_MITHRIL];
    obsidian_magic = ch->pcdata->forge[MINERAL_OBSIDIAN];
    platinum_magic = ch->pcdata->forge[MINERAL_PLATINUM];
    copper_magic = ch->pcdata->forge[MINERAL_COPPER];
    iron_magic = ch->pcdata->forge[MINERAL_IRON];
    bronze_magic = ch->pcdata->forge[MINERAL_BRONZE];
    adamantite_magic = ch->pcdata->forge[MINERAL_ADAMANTITE];
    titanium_magic = ch->pcdata->forge[MINERAL_TITANIUM];
    alabaster_magic = ch->pcdata->forge[MINERAL_ALABASTER];
    total_magic = copper_magic + iron_magic + bronze_magic + adamantite_magic + alabaster_magic + steel_magic + ruby_magic + sapphire_magic + emerald_magic + silver_magic + diamond_magic;
    gem_magic = copper_magic + iron_magic + bronze_magic + adamantite_magic + alabaster_magic + ruby_magic + sapphire_magic + emerald_magic + silver_magic + diamond_magic;
    if ( !str_cmp( arg, "mace" ) )
    {
	if ( steel_magic < 10 )
	{
	    send_to_char( "There isn't enough steel in the forge.\n\r", ch );
	    return;
	}
	
	extract_mineral( ch );
	
	if ( skill > number_range( 1, 101 ) )
	    forged_weapon = create_object( get_obj_index( OBJ_VNUM_FORGE_MACE ) );
	else
	{
	    send_to_char( "You failed at your attemped at making a mace.\n\r", ch );
            check_improve( ch, gsn_weapon_smithing, FALSE, 1 );
	    return;
	}

	if ( steel_magic >= 20 )
	{
	    SET_BIT( forged_weapon->wear_data->weapon_data->flags, WEAPON_TWO_HANDS );
	    SET_BIT( forged_weapon->wear_data->wear_flags, ITEM_TWO_HANDS );
	    forged_weapon->wear_data->weapon_data->dice = 2;
	    forged_weapon->wear_data->weapon_data->die = 5;
	    forged_weapon->wear_data->weight = 15;
	    strncpy( forged_weapon->short_descr, "a two-handed mace", 80 );
	    strncpy( forged_weapon->description, "A two-handed mace lies here.\n\r", 80 );
	}
    }
    else if ( !str_cmp( arg, "polearm" ) )
    {
	if ( steel_magic < 20 )
	{
	    send_to_char( "There isn't enough steel in the forge.\n\r", ch );
	    return;
	}
	
	extract_mineral( ch );
	
	if ( skill > number_range( 1, 101 ) )
	    forged_weapon = create_object( get_obj_index( OBJ_VNUM_FORGE_POLEARM ) );
	else
	{
	    send_to_char( "You failed at your attemped at making a polearm.\n\r", ch );
            check_improve( ch, gsn_weapon_smithing, FALSE, 1 );
	    return;
	}
    }
    else if ( !str_cmp( arg, "sword" ) )
    {
	if ( steel_magic < 10 )
	{
	    send_to_char( "There isn't enough steel in the forge.\n\r", ch );
	    return;
	}
	
	extract_mineral( ch );
	
	if ( skill > number_range( 1, 101 ) )
	    forged_weapon = create_object( get_obj_index( OBJ_VNUM_FORGE_SWORD ) );
	else
	{
	    send_to_char( "You failed at your attemped at making a sword.\n\r", ch );
            check_improve( ch, gsn_weapon_smithing, FALSE, 1 );
	    return;
	}

	if ( steel_magic >= 50 )
	{
	    SET_BIT( forged_weapon->wear_data->weapon_data->flags, WEAPON_TWO_HANDS );
	    SET_BIT( forged_weapon->wear_data->wear_flags, ITEM_TWO_HANDS );
	    forged_weapon->wear_data->weapon_data->dice = 1;
	    forged_weapon->wear_data->weapon_data->die = 12;
	    forged_weapon->wear_data->weight = 30;
	    strncpy( forged_weapon->short_descr, "a two-handed sword", 80 );
	    strncpy( forged_weapon->description, "A two-handed sword lies here.\n\r", 80 );
	}
    }
    else if ( !str_cmp( arg, "axe" ) )
    {
	if ( steel_magic < 10 )
	{
	    send_to_char( "There isn't enough steel in the forge.\n\r", ch );
	    return;
	}
	
	extract_mineral( ch );
	
	if ( skill > number_range( 1, 101 ) )
	    forged_weapon = create_object( get_obj_index( OBJ_VNUM_FORGE_AXE ) );
	else
	{
	    send_to_char( "You failed at your attemped at making an axe.\n\r", ch );
            check_improve( ch, gsn_weapon_smithing, FALSE, 1 );
	    return;
	}

	if ( steel_magic >= 40 )
	{
	    SET_BIT( forged_weapon->wear_data->weapon_data->flags, WEAPON_TWO_HANDS );
	    SET_BIT( forged_weapon->wear_data->wear_flags, ITEM_TWO_HANDS );
	    forged_weapon->wear_data->weapon_data->dice = 2;
	    forged_weapon->wear_data->weapon_data->die = 6;
	    forged_weapon->wear_data->weight = 30;
	    strncpy( forged_weapon->short_descr, "a two-handed axe", 80);
	    strncpy( forged_weapon->description, "A two-handed axe lies here.\n\r", 80 );
	}
    }
    else if ( !str_cmp( arg, "dagger" ) )
    {
	if ( steel_magic < 2 )
	{
	    send_to_char( "There isn't enough steel in the forge.\n\r", ch );
	    return;
	}
	
	extract_mineral( ch );
	
	if ( skill > number_range( 1, 101 ) )
	    forged_weapon = create_object( get_obj_index( OBJ_VNUM_FORGE_DAGGER ) );
	else
	{
	    send_to_char( "You failed at your attemped at making a dagger.\n\r", ch );
            check_improve( ch, gsn_weapon_smithing, FALSE, 1 );
	    return;
	}
    }
    else if ( !str_cmp( arg, "spear" ) )
    {
	if ( steel_magic < 5 )
	{
	    send_to_char( "There isn't enough steel in the forge.\n\r", ch );
	    return;
	}
	
	extract_mineral( ch );
	
	if ( skill > number_range( 1, 101 ) )
	    forged_weapon = create_object( get_obj_index( OBJ_VNUM_FORGE_SPEAR ) );
	else
	{
	    send_to_char( "You failed at your attemped at making a spear.\n\r", ch );
            check_improve( ch, gsn_weapon_smithing, FALSE, 1 );
	    return;
	}

	if ( steel_magic >= 15 )
	{
	    SET_BIT( forged_weapon->wear_data->weapon_data->flags, WEAPON_TWO_HANDS );
	    SET_BIT( forged_weapon->wear_data->wear_flags, ITEM_TWO_HANDS );
	    forged_weapon->wear_data->weapon_data->dice = 2;
	    forged_weapon->wear_data->weapon_data->die = 4;
	    forged_weapon->wear_data->weight = 10;
	    strncpy( forged_weapon->short_descr, "a long spear", 80 );
	    strncpy( forged_weapon->description, "A long spear lies here.\n\r", 80 );
	}
    }
    else
    {
	send_to_char( "What kind of weapon do you want to forge?(sword, dagger, polearm, mace, axe, spear)\n\r", ch );
	return;
    }

    if ( skill - number_range( 1, 20 ) > number_range( 50, 125 ) || number_range( 1, 100 ) > 95 )
	SET_BIT( forged_weapon->wear_data->weapon_data->flags, WEAPON_SHARP );

    bonus = skill; 
    max = 0;
    max2 = 0;
    if ( hammer->pIndexData->vnum == VNUM_HAMMER_1 )
	bonus += 25;

    if ( total_magic > 0 )
    {
	if ( gem_magic > 0 )
	{
	    bonus += obsidian_magic + platinum_magic + mithril_magic;

	    if ( silver_magic >= 10 && max < 2 )
	    {
		if ( bonus > number_range( 1, 125 ) || titanium_magic > 0 )
		{
		    if ( ( titanium_magic > 0 || number_range( 1, URANGE( 1, 200 - ( bonus + ch->level ), 200 ) ) == 1 ) && max2 < 1 && silver_magic >= 20 )
		    {
		    	titanium_magic = 0;
			if ( number_range(1, 100) > 30 )
			{
			    SET_BIT( forged_weapon->wear_data->weapon_data->flags, WEAPON_VAMPIRIC );
			    send_to_char( "You feel strong magic working with your forging!\n\r", ch );
			    max2++;
			    sprintf(short2, " of draining");
			    shortcheck++;
			}
		    }

		    max++;
		    if ( shortcheck == 1 )
			sprintf(short3, " and precision");	
		    else sprintf(short2, " of precision");
			shortcheck++;
		    added = number_range(1, 5);

	    	    if ( number_range( 1, 102 - skill ) == 2 )
			added = added + number_range( 1, 5 );

	    	    paf = new_affect(FALSE);
            	    paf->type       = -1;
            	    paf->duration   = -1;
            	    paf->location   = APPLY_HITROLL;
            	    paf->modifier   = added;
            	    paf->bitvector  = 0;
		    paf->next	= forged_weapon->wear_data->affected;
            	    forged_weapon->wear_data->affected	= paf;
		    SET_BIT( forged_weapon->extra_flags, ITEM_MAGIC );
		}
	    }

	    if ( copper_magic >= 10 && max < 2 )
	    {
		if ( bonus > number_range( 1, 125 ) || titanium_magic > 0 )
		{
		    titanium_magic = 0;
		    if ( number_range( 1, 101 - skill ) == 1 )
		    {
		    	max++;

			if ( shortcheck == 2 )
			    sprintf(short4, " and agility");
			else if ( shortcheck == 1 )
			    sprintf(short3, " and agility");
			else
			    sprintf(short2, " of agility");

			shortcheck++;
	    	    	paf = new_affect(FALSE);
            	    	paf->duration   = -1;
            	    	paf->location   = APPLY_DEX;
			paf->type	= -1;
            	        paf->bitvector = 0;

			if ( number_range( 1, URANGE( 2, 200 - ( bonus + ch->level ), 200 ) ) == 1 )
            	    	    paf->modifier   = 3;
			else
            	    	    paf->modifier   = number_range(1, 2);

		    	paf->next	= forged_weapon->wear_data->affected;
            	    	forged_weapon->wear_data->affected = paf;
		    	SET_BIT( forged_weapon->extra_flags, ITEM_MAGIC );
		    }
		}
	    }

	    if ( iron_magic >= 10 && max < 2 )
	    {
		if ( bonus > number_range( 1, 125 ) || titanium_magic > 0 )
		{
		    titanium_magic = 0;
		    if ( number_range( 1, 102 - skill ) == 1 )
		    {
		    	max++;
			if ( shortcheck == 2 )
			    sprintf(short4, " and giant strength");
			else if ( shortcheck == 1 )
			    sprintf(short3, " and giant strength");
			else
			    sprintf(short2, " of giant strength");
			shortcheck++;
	    	    	paf = new_affect(FALSE);
            	    	paf->duration   = -1;
            	    	paf->location   = APPLY_STR;
			paf->type	= -1;
            	    	paf->bitvector = 0;

			if ( number_range( 1, URANGE( 2, 200 - ( bonus + ch->level ), 200 ) ) == 1 )
            	    	    paf->modifier   = 3;
			else
            	    	    paf->modifier   = number_range(1, 2);

		    	paf->next	= forged_weapon->wear_data->affected;
            	    	forged_weapon->wear_data->affected = paf;
		    	SET_BIT( forged_weapon->extra_flags, ITEM_MAGIC );
		    }
		}
	    }

	    if ( bronze_magic >= 10 && max < 2 )
	    {
		if ( bonus > number_range( 1, 125 ) || titanium_magic > 0 )
		{
		    titanium_magic = 0;
		    if ( number_range( 1, 102 - skill ) == 1 )
		    {
		    	max++;
			if ( shortcheck == 2 )
			    sprintf(short4, " and endurance");
			else if ( shortcheck == 1 )
			    sprintf(short3, " and endurance");
			else
			    sprintf(short2, " of endurance");
			shortcheck++;
	    	    	paf = new_affect(FALSE);
            	    	paf->duration   = -1;
            	    	paf->location   = APPLY_CON;
			paf->type	= -1;
            	    	paf->bitvector = 0;

			if ( number_range( 1, URANGE( 2, 200 - ( bonus + ch->level ), 200 ) ) == 1 )
            	    	    paf->modifier   = 3;
			else
            	    	    paf->modifier   = number_range(1, 2);

		    	paf->next	= forged_weapon->wear_data->affected;
            	    	forged_weapon->wear_data->affected = paf;
		    	SET_BIT( forged_weapon->extra_flags, ITEM_MAGIC );
		    }
		}
	    }

	    if ( ruby_magic >= 10 && max < 2 )
	    {
		if ( bonus > number_range( 1, 125 ) || titanium_magic > 0 )
		{
		    if ( ( titanium_magic > 0 || number_range( 1, URANGE( 1, 200 - ( bonus + ch->level ), 200 ) ) == 1 ) && max2 < 1 && ruby_magic >= 20 )
		    {
		    	titanium_magic = 0;
			if ( number_range(1, 100) > 30 )
			{
			    SET_BIT( forged_weapon->wear_data->weapon_data->flags, WEAPON_FLAMING );
			    send_to_char( "You feel strong magic working with your forging!\n\r", ch );
		    	    SET_BIT( forged_weapon->extra_flags, ITEM_MAGIC );
			    max2++;
			    if ( shortcheck == 1 )
			        sprintf(short3, " and flame");
			    else if ( shortcheck == 2 )
			        sprintf(short4, " and flame");
			    else
			        sprintf(short2, " of flame");
			    shortcheck++;
			}
		    }
		
		    if ( number_range( 1, 102 - skill ) == 1 )
		    {
		    	max++;
			if ( shortcheck == 2 )
			    sprintf(short4, " and fire resistance");
			else if ( shortcheck == 1 )
			    sprintf(short3, " and fire resistance");
			else
			    sprintf(short2, " of fire resistance");
			shortcheck++;
	    	    	paf = new_affect(FALSE);
            	    	paf->duration   = -1;
            	    	paf->location   = APPLY_AFFECT;
            	    	paf->modifier   = 0;
			paf->type	= -1;

			if ( number_range( 1, URANGE( 2, 200 - ( bonus + ch->level ), 200 ) ) == 1 )
			{
			    SET_BIT(forged_weapon->extra_flags, ITEM_HUM );
			    paf->bit_type	= BIT_IMM;
            	    	    paf->bitvector = IMM_FIRE;
			}
			else
			{
			    paf->bit_type  = BIT_RES;
			    paf->bitvector = RES_FIRE;
			}

		    	paf->next	= forged_weapon->wear_data->affected;
            	    	forged_weapon->wear_data->affected = paf;
		    	SET_BIT( forged_weapon->extra_flags, ITEM_MAGIC );
		    }
		}
	    }

	    if ( sapphire_magic >= 10 && max < 2 )
	    {
		if ( bonus > number_range( 1, 125 ) || titanium_magic > 0 )
		{
		    if ( ( titanium_magic > 0 || number_range( 1, URANGE( 1, 200 - ( bonus + ch->level ), 200 ) ) == 1 ) && max2 < 1 && sapphire_magic >= 20 )
		    {
		    	titanium_magic = 0;
			if ( number_range(1, 100) > 30 )
			{
			    SET_BIT( forged_weapon->wear_data->weapon_data->flags, WEAPON_FROST );
			    send_to_char( "You feel strong magic working with your forging!\n\r", ch );
		    	    SET_BIT( forged_weapon->extra_flags, ITEM_MAGIC );
			    max2++;
			    if ( shortcheck == 1 )
			        sprintf(short3, " and frost");
			    else if ( shortcheck == 2 )
			        sprintf(short4, " and frost");
			    else
			        sprintf(short2, " of frost");
			    shortcheck++;
			}
		    }
		
		    if ( number_range( 1, 102 - skill ) == 1 )
		    {
		    	max++;
			if ( shortcheck == 2 )
			    sprintf(short4, " and water resistance");
			else if ( shortcheck == 1 )
			    sprintf(short3, " and water resistance");
			else
			    sprintf(short2, " of water resistance");
			shortcheck++;
	    	    	paf = new_affect(FALSE);
            	    	paf->duration   = -1;
            	    	paf->location   = APPLY_AFFECT;
            	    	paf->modifier   = 0;
			paf->type	= -1;

			if ( number_range( 1, URANGE( 2, 200 - ( bonus + ch->level ), 200 ) ) == 1 )
			{
			    SET_BIT( forged_weapon->extra_flags, ITEM_HUM );
			    paf->bit_type	= BIT_IMM;
            	    	    paf->bitvector = IMM_WATER;
			}
			else
			{
			    paf->bit_type  = BIT_RES;
			    paf->bitvector = RES_WATER;
			}

		    	paf->next	= forged_weapon->wear_data->affected;
            	    	forged_weapon->wear_data->affected = paf;
		    	SET_BIT( forged_weapon->extra_flags, ITEM_MAGIC );
		    }
		}
	    }

	    if ( emerald_magic >= 10 && max < 2 )
	    {
		if ( bonus > number_range( 1, 125 ) || titanium_magic > 0 )
		{
		    if ( ( titanium_magic > 0 || number_range( 1, URANGE( 1, 200 - ( bonus + ch->level ), 200 ) ) == 1 ) && max2 < 1 && emerald_magic >= 20 )
		    {
		    	titanium_magic = 0;
			if ( number_range(1, 100 ) > 30 )
			{
			    SET_BIT( forged_weapon->wear_data->weapon_data->flags, WEAPON_POISON );
			    send_to_char( "You feel strong magic working with your forging!\n\r", ch );
			    max2++;
			    if ( shortcheck == 1 )
			        sprintf(short3, " and poison");
			    else if ( shortcheck == 2 )
			        sprintf(short4, " and poison");
			    else
			        sprintf(short2, " of poison");
			    shortcheck++;
			}
		    }

		    max++;
			if ( shortcheck == 2 )
			    sprintf(short4, " and mana");
			else if ( shortcheck == 1 )
			    sprintf(short3, " and mana");
			else
			    sprintf(short2, " of mana");
		    shortcheck++;
		    added = URANGE( 1, number_range( 2 * ch->level, skill * 3 ), 250 );

	    	    if ( number_range( 1, 102 - skill ) == 2 )
			added = added + number_range( 50, 100 );

	    	    paf = new_affect(FALSE);
            	    paf->type       = -1;
            	    paf->duration   = -1;
		    mana_chance = number_range(1, 5);
		    if ( mana_chance == 1 )
			paf->location = APPLY_MANA_FIRE;
		    else if ( mana_chance == 2 )
			paf->location = APPLY_MANA_WATER;
		    else if ( mana_chance == 3 )
			paf->location = APPLY_MANA_EARTH;
		    else if ( mana_chance == 4 )
			paf->location = APPLY_MANA_WIND;
		    else
			paf->location = APPLY_MANA_SPIRIT;
            	    paf->modifier   = added;
            	    paf->bitvector  = 0;
		    paf->next	= forged_weapon->wear_data->affected;
            	    forged_weapon->wear_data->affected	= paf;
		    SET_BIT( forged_weapon->extra_flags, ITEM_MAGIC );
		}
	    }

	    if ( diamond_magic >= 10 && max < 2 )
	    {
		if ( bonus > number_range( 1, 125 ) || titanium_magic > 0 )
		{
                if ( ( titanium_magic > 0 || number_range( 1, URANGE( 1, 200 - ( bonus + ch->level ), 200 ) ) == 1 ) && max2 < 1 && diamond_magic >= 20 )
                {
		    titanium_magic = 0;
		    if ( number_range(1, 100) > 30 )
		    {
                    	SET_BIT( forged_weapon->wear_data->weapon_data->flags, WEAPON_VORPAL );
                    	send_to_char( "You feel strong magic working with your forging!\n\r", ch );
                    	forged_weapon->wear_data->cost = forged_weapon->wear_data->cost * 500;
                    	max2++;
			if ( shortcheck == 1 )
			    sprintf(short3, ", VORPAL");
			else if ( shortcheck == 2 )
			    sprintf(short4, ", VORPAL");
			else
			    sprintf(short2, ", VORPAL");
		    	shortcheck++;
		    }
                }

                max++;
		if ( shortcheck == 2 )
		    sprintf(short4, " and sharpness");
		else if ( shortcheck == 1 )
		    sprintf(short3, " and sharpness");
		else
		    sprintf(short2, " of sharpness");
		shortcheck++;
                added = URANGE( 1, skill / 15, 4 );

                if ( number_range( 1, 102 - skill ) == 2 )
                    added = added + number_range( 1, 2 );

                paf = new_affect(FALSE);
                paf->type       = -1;
                paf->duration   = -1;
                paf->location   = APPLY_DAMROLL;
                paf->modifier   = added;
                paf->bitvector  = 0;
                paf->next   = forged_weapon->wear_data->affected;
                forged_weapon->wear_data->affected  = paf;
                forged_weapon->wear_data->cost = forged_weapon->wear_data->cost * added;
                SET_BIT( forged_weapon->extra_flags, ITEM_MAGIC );
            }
	    }

	    if ( alabaster_magic >= 10 && max < 2 )
	    {
		if ( bonus > number_range( 1, 125 ) || titanium_magic > 0 )
		{
		    if ( ( titanium_magic > 0 || number_range( 1, URANGE( 1, 200 - ( bonus + ch->level ), 200 ) ) == 1 ) && max2 < 1 && alabaster_magic >= 20 )
		    {
		    	titanium_magic = 0;
			if ( number_range(1, 100) > 30 )
			{
		    	    added = URANGE( 1, number_range( 5 * ch->level, skill * 5 ), 500 );
    
	    	    	    if ( number_range( 1, 102 - skill ) == 2 )
			    	added = added + number_range( 50, 100 );

	    	    	    paf = new_affect(FALSE);
            	    	    paf->type       = -1;
            	    	    paf->duration   = -1;
            	    	    paf->location   = APPLY_MANA;
            	    	    paf->modifier   = added;
            	    	    paf->bitvector  = 0;
		    	    paf->next	= forged_weapon->wear_data->affected;
            	    	    forged_weapon->wear_data->affected	= paf;
		    	    SET_BIT( forged_weapon->extra_flags, ITEM_MAGIC );
			    max2++;
			    SET_BIT( forged_weapon->extra_flags, ITEM_HUM );
			}
		    }
		
		    max++;
		    if ( shortcheck == 2 )
		    	sprintf(short4, " and the majhere");
		    else if ( shortcheck == 1 )
		    	sprintf(short3, " and the majhere");
		    else
		    	sprintf(short2, " of the majhere");
		    shortcheck++;
		    added = URANGE( 1, number_range( 5 * ch->level, skill * 2 ), 200 );

	    	    if ( number_range( 1, 102 - skill ) == 2 )
			added = added + number_range( 50, 100 );

	    	    paf = new_affect(FALSE);
            	    paf->type       = -1;
            	    paf->duration   = -1;
            	    paf->location   = APPLY_MANA;
            	    paf->modifier   = added;
            	    paf->bitvector  = 0;
		    paf->next	= forged_weapon->wear_data->affected;
            	    forged_weapon->wear_data->affected	= paf;
		    SET_BIT( forged_weapon->extra_flags, ITEM_MAGIC );
		}
	    }

	    if ( adamantite_magic >= 10 && max < 2 )
	    {
		if ( bonus > number_range( 1, 125 ) || titanium_magic > 0 )
		{
		    if ( ( titanium_magic > 0 || number_range( 1, URANGE( 1, 200 - ( bonus + ch->level ), 200 ) ) == 1 ) && max2 < 1 && adamantite_magic >= 20 )
		    {
		    	titanium_magic = 0;
			if ( number_range(1, 100) > 30 )
			{
			    send_to_char( "You feel strong magic working with your forging!\n\r", ch );
			    forged_weapon->wear_data->ac = 10;
			    max2++;
			    SET_BIT( forged_weapon->extra_flags, ITEM_HUM );
			}
		    }
		
		    max++;
			if ( shortcheck == 2 )
			    sprintf(short4, " and protection");
			else if ( shortcheck == 1 )
			    sprintf(short3, " and protection");
			else
			    sprintf(short2, " of protection");
		    shortcheck++;
	    	    added = URANGE( 1, skill / 15, 4 );

	    	    if ( number_range( 1, 102 - skill ) == 2 )
			added = added + number_range( 1, 2 );
		    forged_weapon->wear_data->ac = added;
		    SET_BIT( forged_weapon->extra_flags, ITEM_MAGIC );
		}
	    }
	}
    }

    forged_weapon->wear_data->cost = 0;
    strcpy(short1, forged_weapon->short_descr );
    sprintf( name, " `Rforged by %s`w", ch->name );
    if ( shortcheck >= 1 )
    {
	strcat(short1, short2);

	if ( shortcheck >= 2 )
	    strcat(short1, short3);

	if ( shortcheck >= 3 )
	    strcat(short1, short4);
    }

    strcat( short1, name );
    strncpy( forged_weapon->short_descr, short1, 80 );
    obj_to_char( forged_weapon, ch );
    send_to_char( "\n\rYou finished forging your new weapon.\n\r", ch );

    check_improve( ch, gsn_weapon_smithing, TRUE, 1 );
    return;
}

void do_extract( CHAR_DATA *ch, char * argument )
{
    char arg[MAX_INPUT_LENGTH];
    OBJ_DATA *ore;
    OBJ_DATA *kit;
    int ore_chance, ore_chance_2, skill;

    one_argument( argument, arg );

    if ( ( skill = get_skill( ch, gsn_metallurgy ) ) <= 0 )
    {
        send_to_char("You don't know how to extract minerals.\n\r", ch );
        return;
    }

    for ( kit = ch->carrying; kit != NULL && kit->pIndexData->vnum != OBJ_VNUM_EXTRACTING_KIT ; kit = kit->next_content );
    if ( kit == NULL )
    {
        send_to_char( "You need a mineral extracting kit.\n\r", ch );
        return;
    }

    if ( arg[0] == '\0' )
    {
        send_to_char( "Extract minerals from what?\n\r", ch );
        return;
    }

    if ( ( ore = get_obj_carry( ch, arg ) ) == NULL )
    {
        send_to_char( "You do not have that item.\n\r", ch );
        return;
    }

    if ( ore->pIndexData->vnum != OBJ_VNUM_ORE_LARGE
        && ore->pIndexData->vnum != OBJ_VNUM_ORE_MEDIUM
        && ore->pIndexData->vnum != OBJ_VNUM_ORE_SMALL )
    {
        send_to_char( "You can't extract from that ore.\n\r", ch );
        return;
    }

    if ( skill <= number_range( 1, 75 ) )
    {
        send_to_char( "You find nothing in this ore sample.\n\r", ch );
        check_improve(ch,gsn_metallurgy,FALSE,1);
        extract_obj( ore );
        return;
    }
	  
    if ( ore->pIndexData->vnum == OBJ_VNUM_ORE_LARGE && !IS_SET( ore->extra_flags, ITEM_NO_IDENTIFY ) )
    {
        check_improve(ch,gsn_metallurgy,TRUE,1);
        ore_chance = number_range( 1, 200 );

	if ( IS_IMMORTAL(ch) && ore_chance > 20 && ore_chance <= 180 )
	{
	    if ( number_range(1, 2) == 1 )
	    	ore_chance = 200;
	    else
		ore_chance = 1;
	}

        if ( ore_chance == 1 )
        {
            if ( ch->in_room->area->world == 0 )
            {
                send_to_char("You extracted platinum from the ore.\n\r", ch );
		if ( ch->pcdata->minerals[MINERAL_PLATINUM] >= 2000 )
		    send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
		else
		    ch->pcdata->minerals[MINERAL_PLATINUM] += 10;
            }
            else if ( ch->in_room->area->world == 1 )
            {
                send_to_char("You extracted mithril from the ore.\n\r", ch );
		if ( ch->pcdata->minerals[MINERAL_MITHRIL] >= 2000 )
		    send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
		else
		    ch->pcdata->minerals[MINERAL_MITHRIL] += 10;
            }
            else if ( ch->in_room->area->world == 2 )
            {
                send_to_char("You extracted obsidian from the ore.\n\r", ch );
		if ( ch->pcdata->minerals[MINERAL_OBSIDIAN] >= 2000 )
		    send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
		else
		    ch->pcdata->minerals[MINERAL_OBSIDIAN] += 10;
            }
        }
        else if ( ore_chance > 1 && ore_chance <= 3 )
        {
            send_to_char("You extracted a diamond from the ore.\n\r", ch );
            if ( ch->pcdata->minerals[MINERAL_DIAMOND] >= 2000 )
                send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch);
            else
                ch->pcdata->minerals[MINERAL_DIAMOND] += 10;
        }
        else if ( ore_chance > 3 && ore_chance <= 8 )
        {
            send_to_char("You extracted a ruby from the ore.\n\r", ch );
            if ( ch->pcdata->minerals[MINERAL_RUBY] >= 2000 )
                send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch);
            else
                ch->pcdata->minerals[MINERAL_RUBY] += 10;
        }
        else if ( ore_chance > 8 && ore_chance <= 20 )
        {
	    ore_chance_2 = number_range( 1, 5 );

	    if ( ore_chance_2 == 1 )
	    {
              	send_to_char("You extracted gold from the ore.\n\r", ch );
            	if ( ch->pcdata->minerals[MINERAL_GOLD] >= 2000 )
                    send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch);
            	else
                    ch->pcdata->minerals[MINERAL_GOLD] += 10;
	    }
	    else if ( ore_chance_2 == 2 )
	    {
               	send_to_char("You extracted silver from the ore.\n\r", ch );
            	if ( ch->pcdata->minerals[MINERAL_SILVER] >= 2000 )
                    send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch);
            	else
                    ch->pcdata->minerals[MINERAL_SILVER] += 10;
	    }
	    else if ( ore_chance_2 == 3 )
	    {
               	send_to_char("You extracted copper from the ore.\n\r", ch );
                if ( ch->pcdata->minerals[MINERAL_COPPER] >= 2000 )
                    send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch);
                else
                    ch->pcdata->minerals[MINERAL_COPPER] += 10;
	    }
	    else if ( ore_chance_2 == 4 )
	    {
               	send_to_char("You extracted iron from the ore.\n\r", ch );
                if ( ch->pcdata->minerals[MINERAL_IRON] >= 2000 )
                    send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch);
                else
                    ch->pcdata->minerals[MINERAL_IRON] += 10;
	    }
	    else
	    {
               	send_to_char("You extracted bronze from the ore.\n\r", ch );
                if ( ch->pcdata->minerals[MINERAL_BRONZE] >= 2000 )
                    send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch);
                else
                    ch->pcdata->minerals[MINERAL_BRONZE] += 10;
	    }
        }
        else if ( ore_chance > 20 && ore_chance <= 180 )
        {
            send_to_char("You extracted steel from the ore.\n\r", ch );
            if ( ch->pcdata->minerals[MINERAL_STEEL] >= 2000 )
                send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch);
            else
                ch->pcdata->minerals[MINERAL_STEEL] += 10;
        }
        else if ( ore_chance > 180 && ore_chance <= 192 )
        {
	    ore_chance_2 = number_range( 1, 5 );

	    if ( ore_chance_2 == 1 )
	    {
              	send_to_char("You extracted gold from the ore.\n\r", ch );
            	if ( ch->pcdata->minerals[MINERAL_GOLD] >= 2000 )
                    send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch);
            	else
                    ch->pcdata->minerals[MINERAL_GOLD] += 10;
	    }
	    else if ( ore_chance_2 == 2 )
	    {
               	send_to_char("You extracted silver from the ore.\n\r", ch );
            	if ( ch->pcdata->minerals[MINERAL_SILVER] >= 2000 )
                    send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch);
            	else
                    ch->pcdata->minerals[MINERAL_SILVER] += 10;
	    }
	    else if ( ore_chance_2 == 3 )
	    {
               	send_to_char("You extracted copper from the ore.\n\r", ch );
                if ( ch->pcdata->minerals[MINERAL_COPPER] >= 2000 )
                    send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch);
                else
                    ch->pcdata->minerals[MINERAL_COPPER] += 10;
	    }
	    else if ( ore_chance_2 == 4 )
	    {
               	send_to_char("You extracted iron from the ore.\n\r", ch );
                if ( ch->pcdata->minerals[MINERAL_IRON] >= 2000 )
                    send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch);
                else
                    ch->pcdata->minerals[MINERAL_IRON] += 10;
	    }
	    else
	    {
               	send_to_char("You extracted bronze from the ore.\n\r", ch );
                if ( ch->pcdata->minerals[MINERAL_BRONZE] >= 2000 )
                    send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch);
                else
                    ch->pcdata->minerals[MINERAL_BRONZE] += 10;
	    }
        }
        else if ( ore_chance > 192 && ore_chance <= 197 )
        {
            send_to_char("You extracted a sapphire from the ore.\n\r", ch );
            if ( ch->pcdata->minerals[MINERAL_SAPPHIRE] >= 2000 )
                send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch);
            else
                ch->pcdata->minerals[MINERAL_SAPPHIRE] += 10;
        }
        else if ( ore_chance > 197 && ore_chance <= 199 )
        {
            send_to_char("You extracted an emerald from the ore.\n\r", ch );
            if ( ch->pcdata->minerals[MINERAL_EMERALD] >= 2000 )
                send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch);
            else
                ch->pcdata->minerals[MINERAL_EMERALD] += 10;
        }
        else if ( ore_chance == 200 )
        {
	    if ( number_range(1, 5) == 1 )
	    {
		if ( number_range(1, 5) == 1 )
		{
               	    send_to_char("You extracted a titanium from the ore.\n\r", ch );
            	    if ( ch->pcdata->minerals[MINERAL_TITANIUM] >= 2000 )
                	send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch);
            	    else
                	ch->pcdata->minerals[MINERAL_TITANIUM] += 10;
		}
		else
		{
               	    send_to_char("You extracted a adamantite from the ore.\n\r", ch );
                    if ( ch->pcdata->minerals[MINERAL_ADAMANTITE] >= 2000 )
                        send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
                    else
                        ch->pcdata->minerals[MINERAL_ADAMANTITE] += 10;
		}
	    }
	    else
	    {
               	send_to_char("You extracted a alabaster from the ore.\n\r", ch );
                if ( ch->pcdata->minerals[MINERAL_ALABASTER] >= 2000 )
                    send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
                else
                    ch->pcdata->minerals[MINERAL_ALABASTER] += 10;
	    } 
        }	
	
    	if ( ore != NULL )
	{
    	    extract_obj( ore );
	    return;
	}
    }
    else if ( ore->pIndexData->vnum == OBJ_VNUM_ORE_MEDIUM && !IS_SET( ore->extra_flags, ITEM_NO_IDENTIFY ) )
    {
        check_improve(ch,gsn_metallurgy,TRUE,1);
        ore_chance = number_range( 1, 200 );
        if ( ore_chance == 1 )
        {
            if ( ch->in_room->area->world == 0 )
            {
                send_to_char("You extracted platinum from the ore.\n\r", ch );
		if ( ch->pcdata->minerals[MINERAL_PLATINUM] >= 2000 )
		    send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
		else
		    ch->pcdata->minerals[MINERAL_PLATINUM] += 4;
            }
            else if ( ch->in_room->area->world == 1 )
            {
                send_to_char("You extracted mithril from the ore.\n\r", ch );
		if ( ch->pcdata->minerals[MINERAL_MITHRIL] >= 2000 )
		    send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
		else
		    ch->pcdata->minerals[MINERAL_MITHRIL] += 4;
            }
            else if ( ch->in_room->area->world == 2 )
            {
                send_to_char("You extracted obsidian from the ore.\n\r", ch );
		if ( ch->pcdata->minerals[MINERAL_OBSIDIAN] >= 2000 )
		    send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
		else
		    ch->pcdata->minerals[MINERAL_OBSIDIAN] += 4;
            }
        }
        else if ( ore_chance > 1 && ore_chance <= 3 )
        {
            send_to_char("You extracted a diamond from the ore.\n\r", ch );
            if ( ch->pcdata->minerals[MINERAL_DIAMOND] >= 2000 )
                send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
            else
                ch->pcdata->minerals[MINERAL_DIAMOND] += 4;
        }
        else if ( ore_chance > 3 && ore_chance <= 8 )
        {
            send_to_char("You extracted a ruby from the ore.\n\r", ch );
            if ( ch->pcdata->minerals[MINERAL_RUBY] >= 2000 )
                send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
            else
                ch->pcdata->minerals[MINERAL_RUBY] += 4;
        }
        else if ( ore_chance > 8 && ore_chance <= 20 )
        {
	    ore_chance_2 = number_range( 1, 5 );

	    if ( ore_chance_2 == 1 )
	    {
              	send_to_char("You extracted gold from the ore.\n\r", ch );
            	if ( ch->pcdata->minerals[MINERAL_GOLD] >= 2000 )
                    send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
            	else
                    ch->pcdata->minerals[MINERAL_GOLD] += 4;
	    }
	    else if ( ore_chance_2 == 2 )
	    {
               	send_to_char("You extracted silver from the ore.\n\r", ch );
            	if ( ch->pcdata->minerals[MINERAL_SILVER] >= 2000 )
                    send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
            	else
                    ch->pcdata->minerals[MINERAL_SILVER] += 4;
	    }
	    else if ( ore_chance_2 == 3 )
	    {
               	send_to_char("You extracted copper from the ore.\n\r", ch );
                if ( ch->pcdata->minerals[MINERAL_COPPER] >= 2000 )
                    send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
                else
                    ch->pcdata->minerals[MINERAL_COPPER] += 4;
	    }
	    else if ( ore_chance_2 == 4 )
	    {
               	send_to_char("You extracted iron from the ore.\n\r", ch );
                if ( ch->pcdata->minerals[MINERAL_IRON] >= 2000 )
                    send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
                else
                    ch->pcdata->minerals[MINERAL_IRON] += 4;
	    }
	    else
	    {
               	send_to_char("You extracted bronze from the ore.\n\r", ch );
                if ( ch->pcdata->minerals[MINERAL_BRONZE] >= 2000 )
                    send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
                else
                    ch->pcdata->minerals[MINERAL_BRONZE] += 4;
	    }
        }
        else if ( ore_chance > 20 && ore_chance <= 180 )
        {
            send_to_char("You extracted steel from the ore.\n\r", ch );
            if ( ch->pcdata->minerals[MINERAL_STEEL] >= 2000 )
                send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
            else
                ch->pcdata->minerals[MINERAL_STEEL] += 4;
        }
        else if ( ore_chance > 180 && ore_chance <= 192 )
        {
	    ore_chance_2 = number_range( 1, 5 );

	    if ( ore_chance_2 == 1 )
	    {
              	send_to_char("You extracted gold from the ore.\n\r", ch );
            	if ( ch->pcdata->minerals[MINERAL_GOLD] >= 2000 )
                    send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
            	else
                    ch->pcdata->minerals[MINERAL_GOLD] += 4;
	    }
	    else if ( ore_chance_2 == 2 )
	    {
               	send_to_char("You extracted silver from the ore.\n\r", ch );
            	if ( ch->pcdata->minerals[MINERAL_SILVER] >= 2000 )
                    send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
            	else
                    ch->pcdata->minerals[MINERAL_SILVER] += 4;
	    }
	    else if ( ore_chance_2 == 3 )
	    {
               	send_to_char("You extracted copper from the ore.\n\r", ch );
                if ( ch->pcdata->minerals[MINERAL_COPPER] >= 2000 )
                    send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
                else
                    ch->pcdata->minerals[MINERAL_COPPER] += 4;
	    }
	    else if ( ore_chance_2 == 4 )
	    {
               	send_to_char("You extracted iron from the ore.\n\r", ch );
                if ( ch->pcdata->minerals[MINERAL_IRON] >= 2000 )
                    send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
                else
                    ch->pcdata->minerals[MINERAL_IRON] += 4;
	    }
	    else
	    {
               	send_to_char("You extracted bronze from the ore.\n\r", ch );
                if ( ch->pcdata->minerals[MINERAL_BRONZE] >= 2000 )
                    send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
                else
                    ch->pcdata->minerals[MINERAL_BRONZE] += 4;
	    }
        }
        else if ( ore_chance > 192 && ore_chance <= 197 )
        {
            send_to_char("You extracted a sapphire from the ore.\n\r", ch );
            if ( ch->pcdata->minerals[MINERAL_SAPPHIRE] >= 2000 )
                send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
            else
                ch->pcdata->minerals[MINERAL_SAPPHIRE] += 4;
        }
        else if ( ore_chance > 197 && ore_chance <= 199 )
        {
            send_to_char("You extracted an emerald from the ore.\n\r", ch );
            if ( ch->pcdata->minerals[MINERAL_EMERALD] >= 2000 )
                send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
            else
                ch->pcdata->minerals[MINERAL_EMERALD] += 4;
        }
        else if ( ore_chance == 200 )
        {
	    if ( number_range(1, 5) == 1 )
	    {
		if ( number_range(1, 5) == 1 )
		{
               	    send_to_char("You extracted a titanium from the ore.\n\r", ch );
            	    if ( ch->pcdata->minerals[MINERAL_TITANIUM] >= 2000 )
                	send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
            	    else
                	ch->pcdata->minerals[MINERAL_TITANIUM] += 4;
		}
		else
		{
               	    send_to_char("You extracted a adamantite from the ore.\n\r", ch );
                    if ( ch->pcdata->minerals[MINERAL_ADAMANTITE] >= 2000 )
                        send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
                    else
                        ch->pcdata->minerals[MINERAL_ADAMANTITE] += 4;
		}
	    }
	    else
	    {
               	send_to_char("You extracted a alabaster from the ore.\n\r", ch );
                if ( ch->pcdata->minerals[MINERAL_ALABASTER] >= 2000 )
                    send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
                else
                    ch->pcdata->minerals[MINERAL_ALABASTER] += 4;
	    } 
        }	
	
    	if ( ore != NULL )
	{
    	    extract_obj( ore );
	    return;
	}
    }
    else if ( ore->pIndexData->vnum == OBJ_VNUM_ORE_SMALL && !IS_SET( ore->extra_flags, ITEM_NO_IDENTIFY ) )
    {
        check_improve(ch,gsn_metallurgy,TRUE,1);
        ore_chance = number_range( 1, 200 );
        if ( ore_chance == 1 )
        {
            if ( ch->in_room->area->world == 0 )
            {
                send_to_char("You extracted platinum from the ore.\n\r", ch );
		if ( ch->pcdata->minerals[MINERAL_PLATINUM] >= 2000 )
		    send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
		else
		    ch->pcdata->minerals[MINERAL_PLATINUM] += 2;
            }
            else if ( ch->in_room->area->world == 1 )
            {
                send_to_char("You extracted mithril from the ore.\n\r", ch );
		if ( ch->pcdata->minerals[MINERAL_MITHRIL] >= 2000 )
		    send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
		else
		    ch->pcdata->minerals[MINERAL_MITHRIL] += 2;
            }
            else if ( ch->in_room->area->world == 2 )
            {
                send_to_char("You extracted obsidian from the ore.\n\r", ch );
		if ( ch->pcdata->minerals[MINERAL_OBSIDIAN] >= 2000 )
		    send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
		else
		    ch->pcdata->minerals[MINERAL_OBSIDIAN] += 2;
            }
        }
        else if ( ore_chance > 1 && ore_chance <= 3 )
        {
            send_to_char("You extracted a diamond from the ore.\n\r", ch );
            if ( ch->pcdata->minerals[MINERAL_DIAMOND] >= 2000 )
                send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
            else
                ch->pcdata->minerals[MINERAL_DIAMOND] += 2;
        }
        else if ( ore_chance > 3 && ore_chance <= 8 )
        {
            send_to_char("You extracted a ruby from the ore.\n\r", ch );
            if ( ch->pcdata->minerals[MINERAL_RUBY] >= 2000 )
                send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
            else
                ch->pcdata->minerals[MINERAL_RUBY] += 2;
        }
        else if ( ore_chance > 8 && ore_chance <= 20 )
        {
	    ore_chance_2 = number_range( 1, 5 );

	    if ( ore_chance_2 == 1 )
	    {
              	send_to_char("You extracted gold from the ore.\n\r", ch );
            	if ( ch->pcdata->minerals[MINERAL_GOLD] >= 2000 )
                    send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
            	else
                    ch->pcdata->minerals[MINERAL_GOLD] += 2;
	    }
	    else if ( ore_chance_2 == 2 )
	    {
               	send_to_char("You extracted silver from the ore.\n\r", ch );
            	if ( ch->pcdata->minerals[MINERAL_SILVER] >= 2000 )
                    send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
            	else
                    ch->pcdata->minerals[MINERAL_SILVER] += 2;
	    }
	    else if ( ore_chance_2 == 3 )
	    {
               	send_to_char("You extracted copper from the ore.\n\r", ch );
                if ( ch->pcdata->minerals[MINERAL_COPPER] >= 2000 )
                    send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
                else
                    ch->pcdata->minerals[MINERAL_COPPER] += 2;
	    }
	    else if ( ore_chance_2 == 4 )
	    {
               	send_to_char("You extracted iron from the ore.\n\r", ch );
                if ( ch->pcdata->minerals[MINERAL_IRON] >= 2000 )
                    send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
                else
                    ch->pcdata->minerals[MINERAL_IRON] += 2;
	    }
	    else
	    {
               	send_to_char("You extracted bronze from the ore.\n\r", ch );
                if ( ch->pcdata->minerals[MINERAL_BRONZE] >= 2000 )
                    send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
                else
                    ch->pcdata->minerals[MINERAL_BRONZE] += 2;
	    }
        }
        else if ( ore_chance > 20 && ore_chance <= 180 )
        {
            send_to_char("You extracted steel from the ore.\n\r", ch );
            if ( ch->pcdata->minerals[MINERAL_STEEL] >= 2000 )
                send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
            else
                ch->pcdata->minerals[MINERAL_STEEL] += 2;
        }
        else if ( ore_chance > 180 && ore_chance <= 192 )
        {
	    ore_chance_2 = number_range( 1, 5 );

	    if ( ore_chance_2 == 1 )
	    {
              	send_to_char("You extracted gold from the ore.\n\r", ch );
            	if ( ch->pcdata->minerals[MINERAL_GOLD] >= 2000 )
                    send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
            	else
                    ch->pcdata->minerals[MINERAL_GOLD] += 2;
	    }
	    else if ( ore_chance_2 == 2 )
	    {
               	send_to_char("You extracted silver from the ore.\n\r", ch );
            	if ( ch->pcdata->minerals[MINERAL_SILVER] >= 2000 )
                    send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
            	else
                    ch->pcdata->minerals[MINERAL_SILVER] += 2;
	    }
	    else if ( ore_chance_2 == 3 )
	    {
               	send_to_char("You extracted copper from the ore.\n\r", ch );
                if ( ch->pcdata->minerals[MINERAL_COPPER] >= 2000 )
                    send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
                else
                    ch->pcdata->minerals[MINERAL_COPPER] += 2;
	    }
	    else if ( ore_chance_2 == 4 )
	    {
               	send_to_char("You extracted iron from the ore.\n\r", ch );
                if ( ch->pcdata->minerals[MINERAL_IRON] >= 2000 )
                    send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
                else
                    ch->pcdata->minerals[MINERAL_IRON] += 2;
	    }
	    else
	    {
               	send_to_char("You extracted bronze from the ore.\n\r", ch );
                if ( ch->pcdata->minerals[MINERAL_BRONZE] >= 2000 )
                    send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
                else
                    ch->pcdata->minerals[MINERAL_BRONZE] += 2;
	    }
        }
        else if ( ore_chance > 192 && ore_chance <= 197 )
        {
            send_to_char("You extracted a sapphire from the ore.\n\r", ch );
            if ( ch->pcdata->minerals[MINERAL_SAPPHIRE] >= 2000 )
                send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
            else
                ch->pcdata->minerals[MINERAL_SAPPHIRE] += 2;
        }
        else if ( ore_chance > 197 && ore_chance <= 199 )
        {
            send_to_char("You extracted an emerald from the ore.\n\r", ch );
            if ( ch->pcdata->minerals[MINERAL_EMERALD] >= 2000 )
                send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
            else
                ch->pcdata->minerals[MINERAL_EMERALD] += 2;
        }
        else if ( ore_chance == 200 )
        {
	    if ( number_range(1, 5) == 1 )
	    {
		if ( number_range(1, 5) == 1 )
		{
               	    send_to_char("You extracted a titanium from the ore.\n\r", ch );
            	    if ( ch->pcdata->minerals[MINERAL_TITANIUM] >= 2000 )
                	send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
            	    else
                	ch->pcdata->minerals[MINERAL_TITANIUM] += 2;
		}
		else
		{
               	    send_to_char("You extracted a adamantite from the ore.\n\r", ch );
                    if ( ch->pcdata->minerals[MINERAL_ADAMANTITE] >= 2000 )
                        send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
                    else
                        ch->pcdata->minerals[MINERAL_ADAMANTITE] += 2;
		}
	    }
	    else
	    {
               	send_to_char("You extracted a alabaster from the ore.\n\r", ch );
                if ( ch->pcdata->minerals[MINERAL_ALABASTER] >= 2000 )
                    send_to_char( "You have no space for this in storage and the mineral soon becomes unstable and crumbles.\n\r", ch );
                else
                    ch->pcdata->minerals[MINERAL_ALABASTER] += 2;
	    } 
        }
	
    	if ( ore != NULL )
	{
    	    extract_obj( ore );
	    return;
	}
    }

    if ( ore->material == MAT_ROCK )
    {
    	send_to_char( "You find nothing in this ore sample.\n\r", ch );
    	check_improve(ch,gsn_metallurgy,FALSE,1);
    	extract_obj( ore );
	return;
    }
    
    return;
}

void do_fset( CHAR_DATA * ch, char *argument )
{
    char arg[MAX_STRING_LENGTH];
    char arg2[MAX_STRING_LENGTH];
    char buf[MAX_STRING_LENGTH];
    int mineral, amount;

    argument = one_argument( argument, arg );
    argument = one_argument( argument, arg2 );
    if ( get_skill( ch, gsn_mining ) <= 0 )
    {
	send_to_char( "You don't know how to mine.\n\r", ch );
	return;
    }

    if ( !IS_SET( ch->in_room->room_flags, ROOM_FORGE ) )
    {
	send_to_char( "You need to be in a forge to transfer minerals to the forge.\n\r", ch );
	return;
    }

    if ( ( mineral = get_mineral_type( arg ) ) == -1 )
    {
	send_to_char( "That is an invalid mineral.\n\r", ch );
	return;
    }

    if ( !is_number( arg2 ) )
    {
	send_to_char( "You must specify an amount.  Negative number to remove from forge, positive to add.\n\r", ch );
	send_to_char( "Syntax: fset <mineral type> <amount>   example: fset gold 10  (This will add 10 gold to forge)\n\r", ch );
	return;
    }
    
    amount = atoi( arg2 );
    /* remove minerals from forge */
    if ( amount < 0 && ch->pcdata->forge[mineral] < ( amount * -1 ) )
    {
	sprintf( buf, "There isn't that much %s in the forge.\n\r", arg );
	send_to_char( buf, ch );
	return;
    }
    else if ( amount < 0 )
    {
	ch->pcdata->forge[mineral] += amount;
	ch->pcdata->minerals[mineral] -= amount;
	send_to_char( "You remove minerals from the forge.\n\r", ch );
    }

    /* add minerals to forge */
    if ( amount > 0 && ch->pcdata->minerals[mineral] < amount )
    {
	sprintf( buf, "There isn't that much %s in your storage.\n\r", arg );
	send_to_char( buf, ch );
	return;
    }
    else if ( amount > 0 )
    {
	ch->pcdata->forge[mineral] += amount;
	ch->pcdata->minerals[mineral] -= amount;
	send_to_char( "You add minerals from the forge.\n\r", ch );
    }

    return;   
}

void list_minerals( CHAR_DATA *ch, char *argument )
{
    int i;
    char buf[MAX_STRING_LENGTH];

    if ( IS_NPC( ch ) )
	return;

    if ( get_skill( ch, gsn_mining ) <= 0 )
    {
	send_to_char( "You don't know how to mine.\n\r", ch );
	return;
    }
    
    send_to_char( "Minerals in Storage (listed by total weight stored):\n\r", ch );
    for ( i = 0 ; i < MAX_MINERAL ; i++ )
    {
	sprintf( buf, "%-20s: %d\n\r", mineral_type_name( i ), ch->pcdata->minerals[i] );
	send_to_char( buf, ch );
    }

    if ( IS_SET( ch->in_room->room_flags, ROOM_FORGE ) )
    {
    	send_to_char( "\n\rMinerals in the Forge (listed by total weight stored):\n\r", ch );
    	for ( i = 0 ; i < MAX_MINERAL ; i++ )
    	{
	    sprintf( buf, "%-20s: %d\n\r", mineral_type_name( i ), ch->pcdata->forge[i] );
	    send_to_char( buf, ch );
    	}
    }

    return;
}

void extract_mineral( CHAR_DATA * ch )
{
    int i;

    for ( i = 0; i < MAX_MINERAL; i++ )
	ch->pcdata->forge[i] = 0;

    return;
}

