act_comm.c:   if (!IS_SET(ch->tmpact,TMPACT_AWAY) && argument[0] == '\0')
act_comm.c:     REMOVE_BIT (ch->tmpact,TMPACT_AWAY);
act_comm.c:     ch->awaymessage[0] = '\0'; 
act_comm.c:     SET_BIT (ch->tmpact,TMPACT_AWAY);
act_comm.c:     strncpy(ch->awaymessage,argument,40);
act_comm.c:   if (ch->pcdata->confirm_delete)
act_comm.c:	    ch->pcdata->confirm_delete = FALSE;
act_comm.c:	    sprintf(imp_buf, "%s has just deleted\n\r",ch->name);
act_comm.c:    	    sprintf( strsave, "%s%s%s%s", PLAYER_DIR, initial(ch->name), "/",capitalize( ch->name ) ); 
act_comm.c:	    if ( ch->home != 0 )
act_comm.c:	        sprintf( buf, "rm -r %s%ld", SAVEHOMES_DIR, ch->home );
act_comm.c:	    if (ch->logon_data != NULL )
act_comm.c:     	    	strncpy( ch->logon_data->exit, "Delete", 30 );
act_comm.c:            d = ch->desc;
act_comm.c:    ch->pcdata->confirm_delete = TRUE;
act_comm.c:    if (!IS_SET(ch->comm,COMM_NOTHINK))
act_comm.c:    if (!IS_SET(ch->comm,COMM_NOHELP))
act_comm.c:    if (!IS_SET(ch->comm,COMM_NOAUCTION))
act_comm.c:      if (!IS_SET(ch->comm,COMM_NOPRAY))
act_comm.c:    if (!IS_SET(ch->comm,COMM_NOOOC))
act_comm.c:      if(!IS_SET(ch->comm,COMM_NOWIZ))
act_comm.c:      if (IS_SET(ch->comm,COMM_INFO))
act_comm.c:    if (!IS_SET(ch->comm,COMM_DEAF))
act_comm.c:    if (IS_SET(ch->comm,COMM_QUIET))
act_comm.c:    if (ch->lines != PAGELEN)
act_comm.c:	if (ch->lines)
act_comm.c:	    sprintf(buf,"You display %d lines of scroll.\n\r",ch->lines+2);
act_comm.c:    if (IS_SET(ch->comm,COMM_NOSHOUT))
act_comm.c:    if (IS_SET(ch->comm,COMM_NOTELL))
act_comm.c:    if (IS_SET(ch->comm,COMM_NOCHANNELS))
act_comm.c:    if (IS_SET(ch->comm,COMM_NOEMOTE))
act_comm.c:    if (IS_SET(ch->comm,COMM_NOSHOUT))
act_comm.c:   if (IS_SET(ch->comm,COMM_DEAF))
act_comm.c:     REMOVE_BIT(ch->comm,COMM_DEAF);
act_comm.c:     SET_BIT(ch->comm,COMM_DEAF);
act_comm.c:    if (IS_SET(ch->comm,COMM_QUIET))
act_comm.c:      REMOVE_BIT(ch->comm,COMM_QUIET);
act_comm.c:     SET_BIT(ch->comm,COMM_QUIET);
act_comm.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SILENCE ) )
act_comm.c:      if (IS_SET(ch->comm,COMM_NOAUCTION))
act_comm.c:	REMOVE_BIT(ch->comm,COMM_NOAUCTION);
act_comm.c:	SET_BIT(ch->comm,COMM_NOAUCTION);
act_comm.c:	if (IS_SET(ch->comm,COMM_QUIET))
act_comm.c:	if (IS_SET(ch->comm,COMM_NOCHANNELS))
act_comm.c:	REMOVE_BIT(ch->comm,COMM_NOAUCTION);
act_comm.c:	     victim->in_room->area->world == ch->in_room->area->world ) ) &&
act_comm.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SILENCE ) )
act_comm.c:      if (IS_SET(ch->comm,COMM_NOTHINK))
act_comm.c:        REMOVE_BIT(ch->comm,COMM_NOTHINK);
act_comm.c:        SET_BIT(ch->comm,COMM_NOTHINK);
act_comm.c:        if (IS_SET(ch->comm,COMM_QUIET))
act_comm.c:        if (IS_SET(ch->comm,COMM_NOCHANNELS))
act_comm.c:      REMOVE_BIT(ch->comm,COMM_NOTHINK);
act_comm.c:      if ( ch->level < 5 )
act_comm.c:	if (ch->gos_timer > 0 )
act_comm.c:	ch->gos_timer = 1;
act_comm.c:      if ( ch->in_room->area->world == 0 )
act_comm.c:      else if ( ch->in_room->area->world == 1 )
act_comm.c:      else if ( ch->in_room->area->world == 2 )
act_comm.c:	     victim->in_room->area->world == ch->in_room->area->world ) ) &&
act_comm.c:	    if ( ch->in_room->area->world == 0 )
act_comm.c:	    else if ( ch->in_room->area->world == 1 )
act_comm.c:	    else if ( ch->in_room->area->world == 2 )
act_comm.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SILENCE ) )
act_comm.c:      if (IS_SET(ch->comm,COMM_NOOOC))
act_comm.c:        REMOVE_BIT(ch->comm,COMM_NOOOC);
act_comm.c:        SET_BIT(ch->comm,COMM_NOOOC);
act_comm.c:        if (IS_SET(ch->comm,COMM_QUIET))
act_comm.c:        if (IS_SET(ch->comm,COMM_NOCHANNELS))
act_comm.c:        REMOVE_BIT(ch->comm,COMM_NOOOC);
act_comm.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SILENCE ) )
act_comm.c:      if (IS_SET(ch->comm,COMM_NOOOC))
act_comm.c:        REMOVE_BIT(ch->comm,COMM_NOOOC);
act_comm.c:        SET_BIT(ch->comm,COMM_NOOOC);
act_comm.c:        if (IS_SET(ch->comm,COMM_QUIET))
act_comm.c:        if (IS_SET(ch->comm,COMM_NOCHANNELS))
act_comm.c:        REMOVE_BIT(ch->comm,COMM_NOOOC);
act_comm.c:	     victim->in_room->area->world == ch->in_room->area->world ) ) &&
act_comm.c:      if (IS_SET(ch->comm,COMM_NOPRAY))
act_comm.c:        REMOVE_BIT(ch->comm,COMM_NOPRAY);
act_comm.c:        SET_BIT(ch->comm,COMM_NOPRAY);
act_comm.c:        if (IS_SET(ch->comm,COMM_NOCHANNELS))
act_comm.c:        REMOVE_BIT(ch->comm,COMM_NOPRAY);
act_comm.c:      if (IS_SET(ch->comm,COMM_NOWIZ))
act_comm.c:	REMOVE_BIT(ch->comm,COMM_NOWIZ);
act_comm.c:	SET_BIT(ch->comm,COMM_NOWIZ);
act_comm.c:    REMOVE_BIT(ch->comm,COMM_NOWIZ);
act_comm.c:    sprintf( buf, "`Y%s: %s",ch->name,  argument );
act_comm.c:      if (IS_SET(ch->comm,COMM_NOHELP))
act_comm.c:	REMOVE_BIT(ch->comm,COMM_NOHELP);
act_comm.c:	SET_BIT(ch->comm,COMM_NOHELP);
act_comm.c:    REMOVE_BIT(ch->comm,COMM_NOHELP);
act_comm.c:    if ( ( IS_IMMORTAL( ch ) && IS_SET( ch->plr, PLR_HOLYLIGHT) ) 
act_comm.c:      || is_name( victim->name, ch->mate )
act_comm.c:    if ( !IS_NPC( ch ) && ch->pcdata->condition[ COND_DRUNK ] > 10 )
act_comm.c:      if ( !strncmp( arg, "think", strlen(arg) )&& ch->level > 4 )
act_comm.c:      if ( arg[0]=='.' && ch->level > 4 )
act_comm.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SILENCE ) )
act_comm.c:    for ( victim=ch->in_room->people ; victim != NULL ;victim=victim->next_in_room)
act_comm.c:    trig = do_trigger( ch->in_room, ch, NULL, argument, TRIG_SAY, TRIG_TYPE_ROOM);
act_comm.c:    for ( obj = ch->in_room->contents; obj != NULL; obj = obj->next_content )
act_comm.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SILENCE ) )
act_comm.c:    if ( IS_SET(ch->comm, COMM_NOSHOUT) )
act_comm.c:    if ( IS_SET(ch->comm, COMM_DEAF))
act_comm.c:	     d->character->in_room->area->world == ch->in_room->area->world &&
act_comm.c:    if ( ch->pcdata->pcclan == NULL )
act_comm.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SILENCE ) )
act_comm.c:    if ( IS_SET(ch->comm, COMM_DEAF))
act_comm.c:	     d->character->pcdata->pcclan->clan == ch->pcdata->pcclan->clan &&
act_comm.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SILENCE ) )
act_comm.c:    if ( ch->pcdata != NULL && ( ch->pcdata->hand != NULL
act_comm.c:      || ch->pcdata->deck != NULL
act_comm.c:      || ch->pcdata->discarded != NULL
act_comm.c:      || ch->pcdata->played != NULL ) )
act_comm.c:    if ( IS_SET(ch->comm, COMM_QUIET) )
act_comm.c:    if ( strlen(ch->mate) == 0 )
act_comm.c:    if ( ( victim = get_char_world( ch, ch->mate ) ) == NULL
act_comm.c:    || ( IS_NPC(victim) && victim->in_room != ch->in_room ) )
act_comm.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SILENCE ) )
act_comm.c:    if ( ch->pcdata != NULL && ( ch->pcdata->hand != NULL
act_comm.c:      || ch->pcdata->deck != NULL
act_comm.c:      || ch->pcdata->discarded != NULL
act_comm.c:      || ch->pcdata->played != NULL ) )
act_comm.c:    if ( IS_SET(ch->comm, COMM_NOTELL) )
act_comm.c:    if ( IS_SET(ch->comm, COMM_QUIET) )
act_comm.c:    if ( !IS_IMMORTAL( ch ) && !IS_IMMORTAL( victim ) && victim->in_room->area->world != ch->in_room->area->world )
act_comm.c:    ch->reply		= victim;
act_comm.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SILENCE ) )
act_comm.c:    if ( ch->pcdata != NULL && ( ch->pcdata->hand != NULL
act_comm.c:      || ch->pcdata->deck != NULL
act_comm.c:      || ch->pcdata->discarded != NULL
act_comm.c:      || ch->pcdata->played != NULL ) )
act_comm.c:    if ( IS_SET(ch->comm, COMM_NOTELL) )
act_comm.c:    if ( ( victim = ch->reply ) == NULL )
act_comm.c:    if ( IS_SET(ch->comm, COMM_NO_REC_TELL) )
act_comm.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SILENCE ) )
act_comm.c:    if ( IS_SET(ch->comm, COMM_NOSHOUT) )
act_comm.c:	&&   d->character->in_room->area == ch->in_room->area 
act_comm.c:    if ( !IS_NPC(ch) && ( IS_SET(ch->comm, COMM_NOEMOTE) ) )
act_comm.c:  sprintf(log_buf,"%s has been Autorented.",ch->name);
act_comm.c:  if (ch->logon_data != NULL )
act_comm.c:	strncpy( ch->logon_data->exit, "Auto-Rent", 30 );
act_comm.c:  d = ch->desc;
act_comm.c:    if ( ch->level < 2 )
act_comm.c:    for ( s = ch->in_room->spro; s != NULL && str_cmp("rent",s->sp->trigger) ; s = s->next );
act_comm.c:     sprintf (buf,"%s has rented.",ch->name);
act_comm.c:     if (ch->logon_data != NULL )
act_comm.c:     	strncpy( ch->logon_data->exit, "Rent", 30 );
act_comm.c:     d = ch->desc;
act_comm.c:    if (!IS_IMMORTAL(ch) && !ch->home )
act_comm.c:    else if (ch->in_room->vnum != ch->home && !IS_IMMORTAL(ch) )
act_comm.c:    if ( ch->position == POS_FIGHTING )
act_comm.c:    if ( ch->position  < POS_STUNNED  )
act_comm.c:    sprintf( log_buf, "%s has quit.", ch->name );
act_comm.c:    if (ch->logon_data != NULL )
act_comm.c:	if ( ch->logon_data->exit[0] != '\0' )
act_comm.c:	    strncpy( ch->logon_data->exit, "Quit", 30 );
act_comm.c:    d = ch->desc;
act_comm.c:    if ( ch->level < 2 )
act_comm.c:    if ( IS_AFFECTED(ch, AFF_CONTROL_MIND) && ch->master != NULL )
act_comm.c:	act( "But you'd rather follow $N!", ch, NULL, ch->master, TO_CHAR );
act_comm.c:	if ( ch->master == NULL )
act_comm.c:	if ( ch->group )
act_comm.c:        REMOVE_BIT(ch->plr,PLR_NOFOLLOW);
act_comm.c:    if ( ch->master != NULL )
act_comm.c:    if ((pet = ch->pet) != NULL)
act_comm.c:    if ((mount = ch->mount) != NULL)
act_comm.c:    ch->pet = NULL;
act_comm.c:    ch->mount = NULL;
act_comm.c:    if ( ch->master != NULL )
act_comm.c:	sprintf( buf, "Add_follower: non-null master : %s", ch->name );
act_comm.c:    ch->master        = master;
act_comm.c:	ch->next_follower = NULL;
act_comm.c:	    trav_ch->next_follower;
act_comm.c:	    trav_ch=trav_ch->next_follower );
act_comm.c:	trav_ch->next_follower = ch;
act_comm.c:	ch->next_follower = NULL;
act_comm.c:    if( master->group && !ch->group )
act_comm.c:    	if ( ch->level - master->level < -10
act_comm.c:    	||   ch->level - master->level >  10 )
act_comm.c:	master->follower = ch->next_follower;
act_comm.c:	for(trav_ch=master->follower;trav_ch->next_follower != ch;
act_comm.c:	    trav_ch=trav_ch->next_follower);
act_comm.c:	trav_ch->next_follower = ch->next_follower;
act_comm.c:    if ( ch->master == NULL )
act_comm.c:	REMOVE_BIT( ch->affected_by, AFF_CONTROL_MIND );
act_comm.c:	REMOVE_BIT(ch->affected_by, AFF_MOUNTED);
act_comm.c:    if ( can_see( ch->master, ch ) && ch->in_room != NULL)
act_comm.c:	act( "$n stops following you.",     ch, NULL, ch->master, TO_VICT    );
act_comm.c:    	act( "You stop following $N.",      ch, NULL, ch->master, TO_CHAR    );
act_comm.c:    remove_follower( ch, ch->master );
act_comm.c:    ch->master = NULL;
act_comm.c:    if( ch->follower == NULL )
act_comm.c:    for(fch=ch->follower;fch;fch=fch->next_follower)
act_comm.c:    if ( ch->group )
act_comm.c:    ch->group = new_group;
act_comm.c:    ch->next_in_group = NULL;
act_comm.c:    SET_BIT(ch->group->flags, GROUP_IS_PUBLIC );
act_comm.c:	SET_BIT(ch->group->flags, GROUP_IS_SECRET );
act_comm.c:	REMOVE_BIT(ch->group->flags, GROUP_IS_PUBLIC);
act_comm.c:	SET_BIT(ch->group->flags, GROUP_IS_MOBILE );
act_comm.c:	REMOVE_BIT(ch->group->flags, GROUP_IS_PUBLIC);
act_comm.c:    if( !ch->group )
act_comm.c:    if( ch->group->leader == ch )
act_comm.c:    act( "$n has defected from $t.", ch, ch->group->name, NULL, TO_ROOM );
act_comm.c:    act( "You have defected from $t.", ch, ch->group->name, NULL, TO_CHAR );
act_comm.c:    if( ch->group == NULL )
act_comm.c:    if( ch != ch->group->leader )
act_comm.c:    ch->group->treasurer = victim;
act_comm.c:	ch, ch->group->name, victim, TO_NOTVICT );
act_comm.c:	ch, ch->group->name, victim, TO_CHAR );
act_comm.c:	ch, ch->group->name, victim, TO_VICT );
act_comm.c:    if( !ch->group )
act_comm.c:    if( ch != ch->group->leader )
act_comm.c:    act( "$t has been disbanded.", ch, ch->group->name, NULL, TO_CHAR );
act_comm.c:    for(gch=ch->next_in_group;gch;gch=gch->next_in_group)
act_comm.c:	act( "$t has been disbanded.", ch, ch->group->name, gch, TO_VICT );
act_comm.c:	gch->group = NULL;
act_comm.c:    if( group_list == ch->group )
act_comm.c:	for(trav=group_list;trav->next != ch->group;trav=trav->next);
act_comm.c:	trav->next = ch->group->next;
act_comm.c:    free_group_data(ch->group);
act_comm.c:    ch->group = NULL;
act_comm.c:	ch->next_in_group = NULL;
act_comm.c:	for( gch = leader->next_in_group ; gch->next_in_group ; gch = gch->next_in_group );
act_comm.c:	gch->next_in_group = ch;
act_comm.c:	ch->next_in_group = NULL;
act_comm.c:    ch->group = leader->group;
act_comm.c:    if ( ch == ch->group->leader )
act_comm.c:    if ( ch->group->treasurer == ch )
act_comm.c:        ch->group->treasurer = ch->group->leader;
act_comm.c:    for ( gch = ch->group->leader ; gch->next_in_group && gch->next_in_group != ch ; gch = gch->next_in_group );
act_comm.c:    if ( gch->next_in_group != NULL && gch->next_in_group->next_in_group )
act_comm.c:	gch->next_in_group = gch->next_in_group->next_in_group;
act_comm.c:	gch->next_in_group = NULL;
act_comm.c:    ch->group = NULL;
act_comm.c:	sprintf( buf, " Log: %s order %s sick %s\n", ch->name, arg, victim->name );
act_comm.c:	    for ( och = ch->in_room->people ; och != NULL ; och = och->next_in_room )	
act_comm.c:		strncpy(och->dislikes, victim->name,30);
act_comm.c:		strncpy(och->hunting, victim->name,30);
act_comm.c:		SET_BIT( och->act, ACT_HUNTER|ACT_UPDATE_ALWAYS );
act_comm.c:		REMOVE_BIT( och->act, ACT_SENTINEL );
act_comm.c:		och->spec_fun = spec_assassin;
act_comm.c:	    strncpy(och->dislikes, victim->name,30);
act_comm.c:	    strncpy(och->hunting, victim->name,30);
act_comm.c:	    SET_BIT( och->act, ACT_HUNTER|ACT_UPDATE_ALWAYS );
act_comm.c:	    REMOVE_BIT( och->act, ACT_SENTINEL );
act_comm.c:	    och->spec_fun = spec_assassin;
act_comm.c:    for ( och = ch->in_room->people; och != NULL; och = och_next )
act_comm.c:	och_next = och->next_in_room;
act_comm.c:	&&   och->master == ch 
act_comm.c:	if( ( group = ch->group ) == NULL )
act_comm.c:	leader = (ch->leader != NULL) ? ch->leader : ch;
act_comm.c:	for ( gch = char_list; gch != NULL; gch = gch->next )
act_comm.c:		    gch->level,
act_comm.c:		    ( IS_AFFECTED( gch, AFF_BERSERK ) ? gch->max_hit : gch->hit ), gch->max_hit,
act_comm.c:		    gch->move,  gch->max_move,
act_comm.c:		    gch->mana[ 0 ], gch->max_mana[ 0 ],
act_comm.c:		    gch->mana[ 1 ], gch->max_mana[ 1 ],
act_comm.c:		    gch->mana[ 2 ], gch->max_mana[ 2 ],
act_comm.c:		    gch->mana[ 3 ], gch->max_mana[ 3 ],
act_comm.c:		    gch->mana[ 4 ], gch->max_mana[ 4 ]);
act_comm.c:    if ( ch->master != NULL || ( ch->leader != NULL && ch->leader != ch ) )
act_comm.c:    if ( ( ch->level - victim->level < -10
act_comm.c:    ||   ch->level - victim->level >  10 )
act_comm.c:    if ( ch->master != NULL || ( ch->leader != NULL && ch->leader != ch ) )
act_comm.c:    for ( victim = ch->in_room->people; victim != NULL; victim = victim->next_in_room )
act_comm.c:    if ( ( ch->level - victim->level < -10
act_comm.c:    ||   ch->level - victim->level >  10 )
act_comm.c:        coin_type = race_table[ ch->race ][ ch->sex ].world;
act_comm.c:    if ( ch->gold[ coin_type ] < amount )
act_comm.c:    for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
act_comm.c:    ch->gold[ coin_type ] -= amount;
act_comm.c:    ch->gold[ coin_type ] += share + extra;
act_comm.c:    for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
act_comm.c:	    gch->gold[ coin_type ] += share;
act_comm.c:    if ( IS_SET( ch->comm, COMM_NOTELL ) || IS_SET( ch->in_room->room_flags, ROOM_SILENCE ) )
act_comm.c:    if ( ch->pcdata != NULL && ( ch->pcdata->hand != NULL
act_comm.c:      || ch->pcdata->deck != NULL
act_comm.c:      || ch->pcdata->discarded != NULL
act_comm.c:      || ch->pcdata->played != NULL ) )
act_comm.c:    for ( gch =char_list; gch != NULL; gch = gch->next)
act_comm.c:	if ( !is_same_group( gch, ch ) || IS_SET( gch->in_room->room_flags, ROOM_SILENCE )  )
act_comm.c:	sprintf( buf, "`G%s tells the group '%s'.`w\n\r", ch->name, argument );
act_comm.c:    if ( ach->group != NULL && bch->group != NULL )
act_comm.c:    	if ( ach->group->leader == bch->group->leader ) 
act_comm.c:  if (IS_SET(ch->comm,COMM_INFO))
act_comm.c:        REMOVE_BIT(ch->comm,COMM_INFO);
act_comm.c:        SET_BIT(ch->comm,COMM_INFO);
act_info.c:    for ( char_quests = ch->char_quests; char_quests != NULL; char_quests = char_quests->next )
act_info.c:    if ( IS_SET(ch->plr2, PLR_VNUMS_ON )       )
act_info.c:    if ( room_is_dark(ch->in_room, ch ) && IS_AFFECTED(ch, AFF_INFRARED ) )
act_info.c:    if ( !IS_NPC(ch) && IS_NPC(victim) && IS_SET(ch->plr2, PLR_VNUMS_ON)  )
act_info.c:    if ( !IS_NPC( victim ) && !IS_NPC( ch ) && IS_SET( victim->plr, PLR_PK ) && IS_SET( ch->plr, PLR_PK ) ) strcat( buf, "(PK) " );
act_info.c:    if ( !IS_NPC(victim) && !IS_SET(ch->comm, COMM_BRIEF) )
act_info.c:	else if ( ch->height * 11 / 12 > victim->height )
act_info.c:	else if ( ch->height < victim->height * 11 / 12 )
act_info.c:    &&   number_percent( ) < ch->pcdata->learned[gsn_peek] )
act_info.c:    for ( rch = list; rch != NULL; rch = rch->next_in_room )
act_info.c:	if (ch->inside_area != NULL )
act_info.c:	if ( !str_cmp(ch->inside_area->mob_name, rch->name) )
act_info.c:	else if ( room_is_dark( ch->in_room , ch)
act_info.c:	else if ( room_is_dark( ch->in_room, ch )
act_info.c:    ch->in_room->light_adjustment = get_light_adjustment( ch, ch->in_room );
act_info.c:    if ( ( ch->in_room->light_adjustment < 75 
act_info.c:    || IS_SET(ch->imm_flags, IMM_LIGHT) 
act_info.c:    || IS_SET(ch->res_flags, RES_LIGHT) )
act_info.c:    && ( IS_SET(ch->affected_by_2,AFF_LIGHT_SENSITIVE) ) )
act_info.c:    	REMOVE_BIT(ch->affected_by_2, AFF_LIGHT_SENSITIVE);
act_info.c:    else if ( ch->in_room->light_adjustment >= 75 )
act_info.c:            	SET_BIT(ch->affected_by_2, AFF_LIGHT_SENSITIVE);
act_info.c:    else if ( ch->in_room->light_adjustment > 50 && ch->in_room->light_adjustment < 75 )
act_info.c:    if (!IS_NPC(ch) && IS_SET(ch->plr,PLR_HOLYLIGHT))
act_info.c:    if ( IS_SET(ch->affected_by_2, AFF_LIGHT_SENSITIVE) )
act_info.c:	if ( is_name( top_ten_list[ 0 ][ 0 ].name, ch->name ) )
act_info.c:	if ( is_name( top_ten_list[ 0 ][ 1 ].name, ch->name ) )
act_info.c:	if ( is_name( top_ten_list[ 0 ][ 2 ].name, ch->name ) )
act_info.c:    if (IS_SET(ch->infoact,info_val[c1])) c2=1; else c2=0;
act_info.c:      case 0: REMOVE_BIT(ch->infoact,info_val[c1]);    break;
act_info.c:      case 1: SET_BIT(ch->infoact,info_val[c1]);       break;
act_info.c:      case 2: TOGGLE_BIT(ch->infoact,info_val[c1]);    break;
act_info.c:    if (IS_SET(ch->infoact,info_val[c1])) 
act_info.c:	if (ch->lines == 0)
act_info.c:		    ch->lines + 2);
act_info.c:        ch->lines = 0;
act_info.c:    ch->lines = lines - 2;
act_info.c:    sprintf(buf, " !-> %s\n\r",ch->desc->inlast[0]);
act_info.c:	sprintf(buf, "%2d-> %s\n\r",x, ch->desc->inlast[x]);
act_info.c:    if (IS_SET(ch->plr,PLR_AUTOASSIST))
act_info.c:    if (IS_SET(ch->plr,PLR_AUTODIRS))
act_info.c:    if (IS_SET(ch->plr,PLR_AUTOEXIT))
act_info.c:    if (IS_SET(ch->plr,PLR_AUTOMAP))
act_info.c:    if (IS_SET(ch->plr,PLR_AUTOGOLD))
act_info.c:    if (IS_SET(ch->plr,PLR_AUTOLOOT))
act_info.c:    if (IS_SET(ch->plr,PLR_AUTOSAC))
act_info.c:    if (IS_SET(ch->plr,PLR_AUTOSPLIT))
act_info.c:    if (IS_SET(ch->comm,COMM_INFO))
act_info.c:    if (IS_SET(ch->comm,COMM_COMBINE))
act_info.c:    if (!IS_SET(ch->plr,PLR_CANLOOT))
act_info.c:    if (IS_SET(ch->plr,PLR_NOSUMMON))
act_info.c:    if (IS_SET(ch->plr,PLR_NOFOLLOW))
act_info.c:    if ( IS_SET(ch->plr,PLR_AUTOPROMPT) )
act_info.c:    if ( IS_SET(ch->plr2,PLR_NOMISS) )
act_info.c:    if (IS_SET(ch->plr,PLR_AUTOASSIST))
act_info.c:      REMOVE_BIT(ch->plr,PLR_AUTOASSIST);
act_info.c:      SET_BIT(ch->plr,PLR_AUTOASSIST);
act_info.c:    if (IS_SET(ch->plr,PLR_AUTODIRS))
act_info.c:      REMOVE_BIT(ch->plr,PLR_AUTODIRS);
act_info.c:      SET_BIT(ch->plr,PLR_AUTODIRS);
act_info.c:    if (IS_SET(ch->plr,PLR_AUTOMAP))
act_info.c:      REMOVE_BIT(ch->plr,PLR_AUTOMAP);
act_info.c:      SET_BIT(ch->plr,PLR_AUTOMAP);
act_info.c:    if (IS_SET(ch->plr,PLR_AUTOEXIT))
act_info.c:      REMOVE_BIT(ch->plr,PLR_AUTOEXIT);
act_info.c:      SET_BIT(ch->plr,PLR_AUTOEXIT);
act_info.c:    if (IS_SET(ch->plr,PLR_ROOMSTATS))
act_info.c:      REMOVE_BIT(ch->plr,PLR_ROOMSTATS);
act_info.c:      SET_BIT(ch->plr,PLR_ROOMSTATS);
act_info.c:    if (IS_SET(ch->plr,PLR_SECTORSTATS))
act_info.c:      REMOVE_BIT(ch->plr,PLR_SECTORSTATS);
act_info.c:      SET_BIT(ch->plr,PLR_SECTORSTATS);
act_info.c:    if (IS_SET(ch->plr,PLR_AUTOGOLD))
act_info.c:      REMOVE_BIT(ch->plr,PLR_AUTOGOLD);
act_info.c:      SET_BIT(ch->plr,PLR_AUTOGOLD);
act_info.c:    if (IS_SET(ch->plr,PLR_AUTOLOOT))
act_info.c:      REMOVE_BIT(ch->plr,PLR_AUTOLOOT);
act_info.c:      SET_BIT(ch->plr,PLR_AUTOLOOT);
act_info.c:    if (IS_SET(ch->plr,PLR_AUTOSAC))
act_info.c:      REMOVE_BIT(ch->plr,PLR_AUTOSAC);
act_info.c:      SET_BIT(ch->plr,PLR_AUTOSAC);
act_info.c:    if (IS_SET(ch->plr,PLR_AUTOSPLIT))
act_info.c:      REMOVE_BIT(ch->plr,PLR_AUTOSPLIT);
act_info.c:      SET_BIT(ch->plr,PLR_AUTOSPLIT);
act_info.c:    if (IS_SET(ch->comm,COMM_BRIEF))
act_info.c:      REMOVE_BIT(ch->comm,COMM_BRIEF);
act_info.c:      SET_BIT(ch->comm,COMM_BRIEF);
act_info.c:    TOGGLE_BIT(ch->plr, PLR_ANSI);
act_info.c:    ch->color = !ch->color;
act_info.c:    if (!ch->color)
act_info.c:    if (IS_SET(ch->comm,COMM_COMPACT))
act_info.c:      REMOVE_BIT(ch->comm,COMM_COMPACT);
act_info.c:      SET_BIT(ch->comm,COMM_COMPACT);
act_info.c:            strncpy( ch->pcdata->prompt, "`yHp %c`y/`w%H `yMv %d`y/`w%V`y-> ", 160 );
act_info.c:           strncpy( ch->pcdata->prompt, "`gTank:`w %l  `rEnemy:`w %q%#`yHp %c`y/`w%H `yMv %d`y/`w%V`y-> ", 160 );
act_info.c:	    strncpy( ch->pcdata->prompt, "`GTank:`w %b  `rEnemy:`w %B%#`yHp %c`y/`w%H `yMv %d`y/`w%V`y-> ", 160 );
act_info.c:	   if (ch->pcdata->Oprompt[0] != '\0')
act_info.c:	   	strncpy( ch->pcdata->prompt, ch->pcdata->Oprompt, 160 );
act_info.c:	   	strncpy( ch->pcdata->prompt, "`gTank:`w %l  `rEnemy:`w %e%#[%W] <%i`y/`W%H `wHP %n`y/`W%M `wMP %w`y/`W%V `wMV `y>", 160 );
act_info.c:	   ch->pcdata->prompt[0] = '\0';
act_info.c:	   if (ch->pcdata->Oprompt[0] != '\0')
act_info.c:	   	strncpy( ch->pcdata->prompt, ch->pcdata->Oprompt, 160 );
act_info.c:	   strncpy( ch->pcdata->prompt, argument, 160 );
act_info.c:	   strncpy( ch->pcdata->Oprompt, argument, 160 );
act_info.c:    if (IS_SET(ch->comm,COMM_COMBINE))
act_info.c:      REMOVE_BIT(ch->comm,COMM_COMBINE);
act_info.c:      SET_BIT(ch->comm,COMM_COMBINE);
act_info.c:    if (IS_SET(ch->plr,PLR_CANLOOT))
act_info.c:      REMOVE_BIT(ch->plr,PLR_CANLOOT);
act_info.c:      SET_BIT(ch->plr,PLR_CANLOOT);
act_info.c:    if (IS_SET(ch->plr2,PLR_NOMISS))
act_info.c:      REMOVE_BIT(ch->plr2,PLR_NOMISS);
act_info.c:      SET_BIT(ch->plr2,PLR_NOMISS);
act_info.c:    if (IS_SET(ch->plr,PLR_NOFOLLOW))
act_info.c:      REMOVE_BIT(ch->plr,PLR_NOFOLLOW);
act_info.c:      SET_BIT(ch->plr,PLR_NOFOLLOW);
act_info.c:      if (IS_SET(ch->imm_flags,IMM_SUMMON))
act_info.c:	REMOVE_BIT(ch->imm_flags,IMM_SUMMON);
act_info.c:	SET_BIT(ch->imm_flags,IMM_SUMMON);
act_info.c:      if (IS_SET(ch->plr,PLR_NOSUMMON))
act_info.c:        REMOVE_BIT(ch->plr,PLR_NOSUMMON);
act_info.c:        SET_BIT(ch->plr,PLR_NOSUMMON);
act_info.c:    if ( ch->desc == NULL )
act_info.c:    if ( ch->position < POS_SLEEPING )
act_info.c:    if ( ch->position == POS_SLEEPING )
act_info.c:    &&   !IS_SET(ch->plr, PLR_HOLYLIGHT)
act_info.c:    &&   room_is_dark( ch->in_room, ch ) )
act_info.c:	if ( IS_SET(ch->in_room->room_flags, ROOM_DARK ) )
act_info.c:	if ( !IS_SET(ch->affected_by, AFF_DARK_VISION ) )
act_info.c:		show_char_to_char( ch->in_room->people,   ch );
act_info.c:        if ( !IS_NPC(ch) && IS_SET(ch->plr, PLR_ROOMSTATS) )
act_info.c:        if ( !IS_NPC(ch) && IS_SET(ch->plr, PLR_SECTORSTATS) )
act_info.c:	if ( ch->in_room->sector_type == SECT_CITY
act_info.c: 	|| ch->in_room->sector_type == SECT_NONE )
act_info.c:	    if ( ch->in_room->area->world  == 0 )
act_info.c:	    else if (  ch->in_room->area->world == 1 )
act_info.c:	    else if (  ch->in_room->area->world == 2 )
act_info.c:	    else if ( ch->in_room->area->world == 3 )
act_info.c:	else if ( ch->in_room->sector_type == SECT_FIELD )
act_info.c:	else if ( ch->in_room->sector_type == SECT_HILLS )
act_info.c:	else if ( ch->in_room->sector_type == SECT_AIR )
act_info.c:	else if ( ch->in_room->sector_type == SECT_LAVA )
act_info.c:	else if ( ch->in_room->sector_type == SECT_SWAMP )
act_info.c:	else if ( ch->in_room->sector_type == SECT_SNOW )
act_info.c:	else if ( ch->in_room->sector_type == SECT_DIRT )
act_info.c:	else if ( ch->in_room->sector_type == SECT_SAND )
act_info.c:	else if ( ch->in_room->sector_type == SECT_GRASS )
act_info.c:	else if ( ch->in_room->sector_type == SECT_ICE )
act_info.c:	else if ( ch->in_room->sector_type == SECT_DESERT )
act_info.c:	else if ( ch->in_room->sector_type == SECT_MOUNTAIN )
act_info.c:	else if ( ch->in_room->sector_type == SECT_FOREST )
act_info.c:	else if ( ch->in_room->sector_type == SECT_UNDERWATER )
act_info.c:	else if ( ch->in_room->sector_type == SECT_OCEAN_BOTTOM )
act_info.c:	else if ( ch->in_room->sector_type == SECT_UNDERGROUND )
act_info.c:	else if ( ch->in_room->sector_type == SECT_WATER_SWIM )
act_info.c:	else if ( ch->in_room->sector_type == SECT_WATER_NOSWIM )
act_info.c:	else if ( ch->in_room->sector_type == SECT_STREAM )
act_info.c:	send_to_char( ch->in_room->name, ch );
act_info.c:	|| ( !IS_NPC(ch) && !IS_SET(ch->comm, COMM_BRIEF) ) )
act_info.c:	if ( ch->in_room->sector_type == SECT_CITY
act_info.c: 	|| ch->in_room->sector_type == SECT_NONE )
act_info.c:	    if (  ch->in_room->area->world == 0 )
act_info.c:	    else if (  ch->in_room->area->world == 1 )
act_info.c:	    else if (  ch->in_room->area->world == 2 )
act_info.c:	    else if (  ch->in_room->area->world == 3 )
act_info.c:	else if ( ch->in_room->sector_type == SECT_FIELD )
act_info.c:	else if ( ch->in_room->sector_type == SECT_HILLS )
act_info.c:	else if ( ch->in_room->sector_type == SECT_AIR )
act_info.c:	else if ( ch->in_room->sector_type == SECT_LAVA )
act_info.c:	else if ( ch->in_room->sector_type == SECT_SWAMP )
act_info.c:	else if ( ch->in_room->sector_type == SECT_SNOW )
act_info.c:	else if ( ch->in_room->sector_type == SECT_ICE )
act_info.c:	else if ( ch->in_room->sector_type == SECT_DIRT )
act_info.c:	else if ( ch->in_room->sector_type == SECT_SAND )
act_info.c:	else if ( ch->in_room->sector_type == SECT_GRASS )
act_info.c:	else if ( ch->in_room->sector_type == SECT_DOCK )
act_info.c:	else if ( ch->in_room->sector_type == SECT_DESERT )
act_info.c:	else if ( ch->in_room->sector_type == SECT_MOUNTAIN )
act_info.c:	else if ( ch->in_room->sector_type == SECT_FOREST )
act_info.c:	else if ( ch->in_room->sector_type == SECT_UNDERWATER )
act_info.c:	else if ( ch->in_room->sector_type == SECT_OCEAN_BOTTOM )
act_info.c:	else if ( ch->in_room->sector_type == SECT_UNDERGROUND )
act_info.c:	else if ( ch->in_room->sector_type == SECT_WATER_SWIM )
act_info.c:	else if ( ch->in_room->sector_type == SECT_WATER_NOSWIM )
act_info.c:	else if ( ch->in_room->sector_type == SECT_STREAM )
act_info.c:	    send_to_char( ch->in_room->description, ch );
act_info.c:        for ( s = ch->in_room->spro;s != NULL;s = s->next )
act_info.c:        if ( ch->inside_area == NULL ) /* oops! Summon, Or just starting the game.. This may be NULL But we need to set */
act_info.c:	       if ( ch->in_room->area == pRoom->area ) /* If so, we must have the right moveable area */
act_info.c:		ch->inside_area = inside_area_alloc();
act_info.c:		strncpy( ch->inside_area->mob_name, victim->name, 30 );
act_info.c:		strncpy( ch->inside_area->short_descr, victim->short_descr, 80 );
act_info.c: 		ch->inside_area->start_room = victim->moveable->area_start_room; 
act_info.c:      if ( ch->inside_area != NULL ) /* Moveable has no start room or is nolonger in the game */
act_info.c:      if ( ( location = find_location(ch, ch->inside_area->mob_name) )  != NULL )
act_info.c:	original = ch->in_room;
act_info.c:         	send_to_char( ch->in_room->name, ch); 
act_info.c:         	send_to_char( ch->in_room->description, ch); 
act_info.c:		show_char_to_char( ch->in_room->people,   ch );
act_info.c:        	if ( !IS_NPC(ch) && IS_SET(ch->plr, PLR_AUTOEXIT) )
act_info.c:	if (ch->in_room->contents)
act_info.c:	show_list_to_char( ch->in_room->contents, ch, FALSE, FALSE );
act_info.c:	if (ch->in_room->people)
act_info.c:	    show_char_to_char( ch->in_room->people,   ch );
act_info.c:        if ( !IS_NPC(ch) && IS_SET(ch->plr, PLR_AUTOEXIT) )
act_info.c:        if ( !IS_NPC(ch) && IS_SET(ch->plr, PLR_AUTODIRS) )
act_info.c:        if ( !IS_NPC(ch) && IS_SET(ch->plr, PLR_AUTOMAP) )
act_info.c:	for( obj = ch->in_room->contents ; obj != NULL; obj = obj->next_content )
act_info.c:		chance = get_skill( ch, gsn_awareness ) + (IS_SET(ch->affected_by_2, AFF_SENSES ) ? ch->level : 0 );
act_info.c:    trig = do_trigger( ch->in_room, ch, NULL, NULL, TRIG_LOOK, TRIG_TYPE_ROOM);
act_info.c:    for ( obj = ch->carrying; obj != NULL; obj = obj_next )
act_info.c:    for ( obj = ch->in_room->contents; obj != NULL; obj = obj_next )
act_info.c:    pdesc = get_extra_descr( arg1, ch->in_room->extra_descr );
act_info.c:    if ( ( pexit = ch->in_room->exit[door] ) == NULL ) 
act_info.c:	if ( pexit->u1.to_room != NULL && can_see_room( ch, pexit->u1.to_room ) && ( IS_SET( ch->plr, PLR_HOLYLIGHT ) || !room_is_dark( pexit->u1.to_room, ch ) ) )
act_info.c:	if ( ( pexit = ch->in_room->exit[door] ) != NULL
act_info.c:	      IS_SET(ch->plr, PLR_HOLYLIGHT) ) )
act_info.c:		if ( IS_IMMORTAL( ch ) && IS_SET(ch->plr,PLR_HOLYLIGHT) )
act_info.c:			&& !IS_SET(ch->plr,PLR_HOLYLIGHT)
act_info.c:			&& !IS_SET(ch->affected_by, AFF_DARK_VISION) )
act_info.c:			 (IS_SET(pexit->exit_info, EX_HIDDEN) && ( ( IS_IMMORTAL(ch) && IS_SET(ch->plr,PLR_HOLYLIGHT) ) || IS_SET( pexit->exit_info, EX_CLOSED ) ) ) ? 
act_info.c:			 (IS_SET(pexit->exit_info, EX_BASHPROOF) && IS_SET(ch->plr, PLR_HOLYLIGHT )) ? 
act_info.c:			 (IS_SET(pexit->exit_info, EX_PASSPROOF) && IS_SET(ch->plr, PLR_HOLYLIGHT )) ? 
act_info.c:			 (IS_SET(pexit->exit_info, EX_WALL) && IS_SET(ch->plr, PLR_HOLYLIGHT )) ? 
act_info.c:			 (IS_SET(pexit->exit_info, EX_ILLUSION) && IS_SET(ch->plr, PLR_HOLYLIGHT )) ? 
act_info.c:   	sprintf(buf,"You have:\n\r%ld Nenkemen crowns.\n\r%ld Maegmenel duckets\n\r%ld Lithdor wheels\n\r%ld greckles.\n\r",ch->gold[0],ch->gold[1],ch->gold[2],ch->gold[3]);
act_info.c:    sprintf(buf,"You have:\n\r%ld Nenkemen crowns.\n\r%ld Maegmenel duckets\n\r%ld Lithdor wheels\n\r%ld greckles.\n\r",ch->gold[0],ch->gold[1],ch->gold[2],ch->gold[3]);
act_info.c:    room = ch->in_room;
act_info.c:    to_room = ch->in_room;
act_info.c:	if ( ( pexit = ch->in_room->exit[door] ) != NULL
act_info.c:	      IS_SET(ch->plr, PLR_HOLYLIGHT) ) )
act_info.c:    if ( ch->position == POS_FIGHTING)
act_info.c:    for ( vch = ch->in_room->people ; vch != NULL ; vch = vch->next_in_room )
act_info.c:	    sprintf( buf, "%s `wis right here.\n\r", ( IS_NPC(vch) ? vch->short_descr : vch->name ) );
act_info.c:    room = ch->in_room;
act_info.c:	for ( num = 0 ; num < ( race_table[ ch->race ][ ch->sex ].scan_dist < 10 ? race_table[ ch->race ][ ch->sex ].scan_dist : 10 ) ; num++ )
act_info.c:	        for( vch = pexit->u1.to_room->people ; vch != NULL ; vch = vch->next_in_room )
act_info.c:		        sprintf( buf, "You see %s `wis %s %s of you.\n\r", ( IS_NPC(vch) ? vch->short_descr : vch->name ) , scan_msg[ num ], dir_name[ door ] );
act_info.c:		        sprintf( buf, "%s `wis %s %s.\n\r", ( IS_NPC(vch) ? vch->short_descr : vch->name ) , scan_msg[ num ], dir_name[ door ] );
act_info.c:temp=ch->max_hit;
act_info.c:for ( quests = ch->char_quests; quests != NULL; quests = quests->next )
act_info.c:   instead of for example ch->hit 
act_info.c:    int world=ch->in_room->area->world;
act_info.c:    if ( ch->in_room->area->time_zone + time_info[ world ].hour > time_table[ world ].hours_day )
act_info.c:    time = get_hour( ch->in_room->area );
act_info.c:	season_name[ ch->in_room->area->weather->season ],
act_info.c:	SET_BIT(ch->plr, PLR_WEATHER_OFF);
act_info.c:	REMOVE_BIT(ch->plr, PLR_WEATHER_OFF);
act_info.c:	sky_look[ ch->in_room->area->weather->sky ],
act_info.c:	ch->in_room->area->weather->change <= 0
act_info.c:    	if ( IS_SET(ch->in_room->room_flags_2, ROOM_STARTING ) )
act_info.c:    sprintf(buf,"No help for: %s (%s)",argall, ch->name);
act_info.c:        if ( wch->level < iLevelLower
act_info.c:        ||   wch->level > iLevelUpper
act_info.c:        || ( fWorldRestrict && ch->in_room->area->world != wch->in_room->area->world )
act_info.c:        || ( fRaceRestrict && !rgfRace[wch->race] ) )
act_info.c:        if (ch->color)
act_info.c:            switch (wch->level / 10)
act_info.c:            sprintf( buf, "%s[ %s ] %s%s`w%s%s%s\n\r", ( ( ch->color ) ? colorbuf : "" ), 
act_info.c:		wch->pcdata->imm_title, 
act_info.c:		wch->name, 
act_info.c:		wch->pcdata->title, 
act_info.c:		( IS_SET( wch->plr, PLR_WIZINVIS ) ? " (INVIS)" : "" ),
act_info.c:		( IS_SET( wch->tmpact, TMPACT_AWAY ) ? " (AWAY)" : "" ) );
act_info.c:		( ( ch->color ) ? colorbuf : "" ),
act_info.c: 		wch->level, 
act_info.c:		race_table[ wch->race ][ wch->sex ].who_name, 
act_info.c:		wch->name, wch->pcdata->title, 
act_info.c:		( IS_SET( wch->tmpact, TMPACT_AWAY ) ? " (AWAY)" : "" ) );
act_info.c:    if ( ch->color )
act_info.c:    sprintf( buf2, "%s\n\rPlayers found: %d\n\r",((ch->color) ?  colorbuf : ""), nMatch );
act_info.c:    show_list_to_char( ch->carrying, ch, TRUE, TRUE );
act_info.c:		else if ( paf->bit_type == BIT_IMM && !IS_SET( ch->imm_flags, paf->bitvector ) )
act_info.c:		else if ( paf->bit_type == BIT_RES && !IS_SET( ch->res_flags, paf->bitvector ) )
act_info.c:		else if ( paf->bit_type == BIT_VULN && !IS_SET( ch->vuln_flags, paf->bitvector ) )
act_info.c:	for (obj2 = ch->carrying; obj2 != NULL; obj2 = obj2->next_content)
act_info.c:	    &&   victim->in_room->area == ch->in_room->area
act_info.c:	    &&   victim->in_room->area == ch->in_room->area
act_info.c:    diff = level - ch->level;
act_info.c:    strncpy( ch->pcdata->title, buf, 80 );
act_info.c:	if ( !str_cmp( finger->name, ch->name ) && !IS_IMMORTAL( ch ) )
act_info.c:            string_append( ch, &ch->description );
act_info.c:            string_append( ch, &ch->description );
act_info.c:        sprintf( buf, "%s %d/%d ",element_type_name( i ), ch->mana[ i ], ch->max_mana[ i ] );
act_info.c:	ch->hit,  ch->max_hit,
act_info.c:	ch->move, ch->max_move,
act_info.c:	ch->hit,  ch->max_hit, 
act_info.c:	ch->move, ch->max_move,
act_info.c:	    if (mob->in_room->area->world == ch->in_room->area->world )
act_info.c:	    if (mob->in_room->area == ch->in_room->area )
act_info.c:	    if (IS_NPC(mob) && IS_SET(mob->act, ACT_GAIN ) && (!fWorld || mob->in_room->area == ch->in_room->area))
act_info.c:	wimpy = ch->max_hit / 5;
act_info.c:    if ( wimpy > ch->max_hit/2 )
act_info.c:    ch->wimpy	= wimpy;
act_info.c:    if ( str_cmp( arg1, ch->pcdata->pwd ))
act_info.c:    strncpy( ch->pcdata->pwd, pwdnew, 30 );
act_info.c:    if ( ch->affected != NULL )
act_info.c:	for ( paf = ch->affected; paf != NULL; paf = paf->next )
act_info.c:		if (ch->level >= 30)
act_info.c:	    if ( ch->level >= 30 )
act_info.c:	for ( paf = ch->in_room->affected_by ; paf != NULL ; paf = paf->next )
act_info.c:    value = exp_table[ch->level +1].exp_at_level - ch->exp;
act_info.c:	    for( gch = group->leader ; gch ; gch = gch->next_in_group )
act_info.c:		sprintf( buf,"      %20s -- %5d -- %s\n\r", gch->name, gch->level, 
act_info.c:		race_list[gch->race].name );
act_info.c:	    if ( !str_cmp( finger->name, ch->name ) )
act_info.c:	    if ( !str_cmp( finger->name, ch->name ) )
act_info.c:		ch->desc->connected = CON_EDITING;
act_info.c:    if ( ch->desc == NULL )
act_info.c:    comm = ( IS_SET(ch->comm, COMM_COMBINE ) ? TRUE : FALSE );
act_info.c:    SET_BIT(ch->comm, COMM_COMBINE );
act_info.c:	    if ( IS_NPC(ch) || IS_SET(ch->comm, COMM_COMBINE) )
act_info.c:	if ( IS_NPC(ch) || IS_SET(ch->comm, COMM_COMBINE) )
act_info.c:	if ( IS_NPC(ch) || IS_SET(ch->comm, COMM_COMBINE) )
act_info.c:    if ( !comm ) REMOVE_BIT(ch->comm, COMM_COMBINE );
act_info.c:    if ( ch->pcdata->pcclan == NULL )
act_info.c:    if ( ch->pcdata->pcclan->clanrank == 1 )
act_info.c:	strcpy (rank, ch->pcdata->pcclan->clan->rank1);
act_info.c:    if ( ch->pcdata->pcclan->clanrank == 2 )
act_info.c:        strcpy (rank, ch->pcdata->pcclan->clan->rank2);
act_info.c:    if ( ch->pcdata->pcclan->clanrank == 3 )
act_info.c:        strcpy (rank, ch->pcdata->pcclan->clan->rank3);
act_info.c:    if ( ch->pcdata->pcclan->clanrank == 4 )
act_info.c:        strcpy (rank, ch->pcdata->pcclan->clan->rank4);
act_info.c:    if ( ch->pcdata->pcclan->clanrank == 5 )
act_info.c:        strcpy (rank, ch->pcdata->pcclan->clan->rank5);
act_info.c:    if ( ch->pcdata->pcclan->clanrank == 6 )
act_info.c:        strcpy (rank, ch->pcdata->pcclan->clan->rank6);
act_info.c:    if ( ch->pcdata->pcclan->clanrank == 7 )
act_info.c:        strcpy (rank, ch->pcdata->pcclan->clan->rank7);
act_info.c:    if ( ch->pcdata->pcclan->clanrank == 8 )
act_info.c:        strcpy (rank, ch->pcdata->pcclan->clan->rank8);
act_info.c:    if ( ch->pcdata->pcclan->clanrank == 9 )
act_info.c:        strcpy (rank, ch->pcdata->pcclan->clan->rank9);
act_info.c:    if ( ch->pcdata->pcclan->clanrank == 10 )
act_info.c:        strcpy (rank, ch->pcdata->pcclan->clan->rank10);
act_move.c:        for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
act_move.c:	    if ( ch->home == ch->in_room->vnum )
act_move.c: if (IS_SET(doorflags,EX_WALL) && !IS_IMMORTAL(ch) && !IS_SET( ch->plr2, PLR_SPECIAL_PASS ) )
act_move.c: if ((!IS_SET(doorflags,EX_CLOSED) && IS_SET(doorflags, EX_ILLUSION  )) && !IS_SET(ch->plr, PLR_HOLYLIGHT ) )
act_move.c:       chance = get_skill( ch, gsn_awareness ) + (IS_SET(ch->affected_by_2, AFF_SENSES ) ? ch->level : 0 );
act_move.c:    if ( ( obj = get_obj_list( ch, arg, ch->in_room->contents ) ) != NULL )
act_move.c:    else if ( ( obj = get_obj_list( ch, arg, ch->carrying ) ) != NULL )
act_move.c:	if ( ( pexit = ch->in_room->exit[ door ] ) != NULL
act_move.c:    in_room = ch->in_room;
act_move.c:    for ( pick = ch->carrying; pick != NULL && !IS_SET( pick->extra_flags, ITEM_PICK ) ; pick = pick->next_content );
act_move.c:    if ( ( ch->in_room->sector_type != SECT_UNDERGROUND 
act_move.c:	&& ch->in_room->sector_type != SECT_MOUNTAIN )
act_move.c:	|| IS_SET( ch->in_room->area->area_flags, AREA_PKSAFE ) )
act_move.c:    if ( ( pexit = ch->in_room->exit[door] ) != NULL )
act_move.c:    if ( ch->move < move )
act_move.c:    	    do_generate_rooms( ch, ch->in_room, TRUE, door );
act_move.c:				    if ( ch->in_room->area->world == 0 )
act_move.c:				    else if ( ch->in_room->area->world == 1 )
act_move.c:				    else if ( ch->in_room->area->world == 2 )
act_move.c:				    if ( ch->in_room->area->world == 0 )
act_move.c:				    else if ( ch->in_room->area->world == 1 )
act_move.c:				    else if ( ch->in_room->area->world == 2 )
act_move.c:			if ( ch->level >= 43 && number_range( 1, 10 ) == 10 )
act_move.c:			if ( ch->level >= 38 && number_range( 1, 8 ) == 8 )
act_move.c:			if ( ch->level >= 34 && number_range( 1, 6 ) == 6 )
act_move.c:			if ( ch->level >= 29 && number_range( 1, 4 ) == 4 )
act_move.c:			if ( ch->level >= 1 && number_range( 1, 2 ) == 2 )
act_move.c:			if ( ch->level >= 43 && number_range( 1, 10 ) == 10 )
act_move.c:			if ( ch->level >= 38 && number_range( 1, 8 ) == 8 )
act_move.c:			if ( ch->level >= 34 && number_range( 1, 6 ) == 6 )
act_move.c:			if ( ch->level >= 29 && number_range( 1, 4 ) == 4 )
act_move.c:			if ( ch->level >= 1 && number_range( 1, 2 ) == 2 )
act_move.c:    ch->move = UMAX( 0, ch->move - move );
act_move.c:	for ( shovel =  ch->carrying; shovel != NULL && shovel->pIndexData->vnum != OBJ_VNUM_SHOVEL ; shovel = shovel->next_content );
act_move.c:	for ( obj = ch->in_room->contents ; obj != NULL ; obj = obj->next_content )
act_move.c:        if ( ch->in_room->sector_type == SECT_CITY 
act_move.c:		|| ch->in_room->sector_type == SECT_NONE 
act_move.c:	    	|| ch->in_room->sector_type == SECT_UNDERWATER
act_move.c:	    	|| ch->in_room->sector_type == SECT_WATER_SWIM
act_move.c:	    	|| ch->in_room->sector_type == SECT_WATER_NOSWIM
act_move.c:	    	|| ch->in_room->sector_type == SECT_AIR
act_move.c:	    	|| ch->in_room->sector_type == SECT_LAVA)
act_move.c:	for ( shovel =  ch->carrying; shovel != NULL && shovel->pIndexData->vnum != OBJ_VNUM_SHOVEL ; shovel = shovel->next_content );
act_move.c:	if ( ( obj = get_obj_list( ch, arg, ch->in_room->contents ) ) != NULL )
act_move.c:    int bonus = ( IS_SET( ch->affected_by_2, AFF_SENSES ) ? ch->level : 0);
act_move.c:	if ( ( pexit = ch->in_room->exit[ door ] ) != NULL
act_move.c:	for ( obj = ch->in_room->contents ; obj != NULL ; obj = obj->next_content )
act_move.c:    else if ( ( obj = get_obj_list( ch, arg, ch->in_room->contents ) ) != NULL 
act_move.c:          || ( obj = get_obj_list( ch, arg, ch->carrying ) ) != NULL )
act_move.c:	if ( ( pexit = ch->in_room->exit[ door ] ) != NULL
act_move.c:    if ( ch->pcdata != NULL )
act_move.c:	    minerals += ch->pcdata->forge[i];
act_move.c:    if ( ch->pcdata != NULL && ( ch->pcdata->hand != NULL
act_move.c:      || ch->pcdata->deck != NULL 
act_move.c:      || ch->pcdata->played != NULL
act_move.c:      || ch->pcdata->discarded != NULL ) )
act_move.c:    if ( ch->mount != NULL && IS_SET( ch->mount->affected_by , AFF_MOUNTED ) 
act_move.c:	&& ch->mount->position < POS_STANDING )
act_move.c:	if ( IS_SET( ch->plr2, PLR_SPECIAL_PASS ) )
act_move.c:	    ch->mount->position = POS_STANDING;
act_move.c:    in_room = ch->in_room;
act_move.c:    &&   !IS_SET( ch->plr2, PLR_SPECIAL_PASS )
act_move.c:    &&   !IS_SET(ch->plr, PLR_WIZPASS ) )
act_move.c:	 if ( IS_NPC(ch) && IS_SET(ch->act2, ACT2_WALKTO) )
act_move.c:    &&   !IS_SET( ch->plr2, PLR_SPECIAL_PASS )
act_move.c:    &&   !IS_SET(ch->plr, PLR_WIZPASS ) )
act_move.c:    &&   !IS_SET( ch->plr2, PLR_SPECIAL_PASS )
act_move.c:    &&   ch->master != NULL
act_move.c:    &&   in_room == ch->master->in_room )
act_move.c:    &&   !IS_SET( ch->plr2, PLR_SPECIAL_PASS )  &&
act_move.c:       (IS_OPTIVISION(ch) || !IS_SET(ch->plr,PLR_WIZINVIS)))
act_move.c:      && !IS_SET( ch->guilds, to_room->guilds )
act_move.c:	   if ( ch->in_room != in_room )
act_move.c:	      extract_obj(ch->pcdata->corpse);
act_move.c:	      ch->pcdata->corpse = NULL;
act_move.c:		&& !IS_SET(ch->imm_flags, IMM_FIRE) && !IS_NPC(ch))
act_move.c:		if ( IS_SET(ch->res_flags, RES_FIRE) )
act_move.c:		     ch->hit = UMAX(1,ch->hit - number_range(25,75) );
act_move.c:		    ch->hit = UMAX(1,ch->hit - number_range(50,100) );
act_move.c:        do_generate_rooms( ch, ch->in_room, FALSE, 0 );
act_move.c:	  &&   !IS_SET( ch->plr2, PLR_SPECIAL_PASS )
act_move.c:		for ( obj = ch->carrying ; obj != NULL ; obj = obj->next_content )
act_move.c:	    if (!IS_NPC(ch) || ch->pIndexData->moveable == NULL ) 
act_move.c:	&& IS_SET(ch->affected_by_2, AFF_FALLING)
act_move.c:		ch->hit = UMAX(1,ch->hit - number_range(5,39) );
act_move.c:		REMOVE_BIT(ch->affected_by_2, AFF_FALLING);
act_move.c:	    if ( IS_NPC(ch) && !IS_SET( ch->affected_by, AFF_BREATHE_UNDERWATER ) )
act_move.c:	      &&   !IS_SET( ch->plr2, PLR_SPECIAL_PASS )
act_move.c:                && ( ch->mount != NULL 
act_move.c:                   && !IS_SET( ch->mount->affected_by , AFF_BREATHE_UNDERWATER ) ))
act_move.c:		if ( IS_SET( ch->mount->affected_by, AFF_MOUNTED) )
act_move.c:        &&   !IS_SET( ch->plr2, PLR_SPECIAL_PASS )
act_move.c:                && ( ch->mount == NULL 
act_move.c:                   || IS_SET( ch->mount->affected_by , AFF_MOUNTED )
act_move.c:                   || !IS_AFFECTED( ch->mount , AFF_FLYING|AFF_LEVITATING ) ) )
act_move.c:	    if (IS_IMMORTAL(ch) || race_table[ch->race][ch->sex].world == 0 )
act_move.c:	    for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
act_move.c: 	&& !IS_SET( ch->act, ACT_MOUNT ) && !IS_SET( ch->affected_by, AFF_CONTROL_MIND ) 
act_move.c:	&& !IS_SET(ch->act2, ACT2_WALKTO) && !IS_SET( ch->act, ACT_PET )
act_move.c:	&& !IS_SET(ch->act2, ACT2_GUIDE))
act_move.c:	  &&   !IS_SET( ch->plr2, PLR_SPECIAL_PASS )
act_move.c:	  && (ch->mount == NULL || !IS_SET( ch->mount->affected_by, AFF_MOUNTED ) ) )
act_move.c:	  &&   !IS_SET( ch->plr2, PLR_SPECIAL_PASS )
act_move.c:	  && (ch->mount != NULL && ch->mount->position >= POS_STANDING && ch->mount->in_room == ch->in_room ) )
act_move.c:        if ( ch->mount != NULL 
act_move.c:                   && IS_SET( ch->mount->affected_by , AFF_MOUNTED ) )
act_move.c:       	    if ( ch->mount->move < move*3/2 )
act_move.c:	    ch->mount->move -= move*3/2;
act_move.c:	if ( IS_NPC(ch) && ch->moveable != NULL )
act_move.c:	if ( ch->move < move )
act_move.c:	ch->move -= move;
act_move.c:        if (IS_SET(ch->plr, PLR_FLEE ) )
act_move.c:        else if ( ch->mount != NULL && IS_SET( ch->mount->affected_by , AFF_MOUNTED ) )
act_move.c:            sprintf(buf,"You ride %s, mounted on %s.",dir_name[door],ch->mount->short_descr);
act_move.c:    	else if (IS_SET( ch->plr, PLR_RUNNING ) )
act_move.c:	else if ( ch->in_room->sector_type == SECT_UNDERWATER )
act_move.c:	else if ( ch->in_room->sector_type == SECT_OCEAN_BOTTOM )
act_move.c:	else if ( ch->in_room->sector_type == SECT_WATER_SWIM )
act_move.c:	else if ( !found_boat && ch->in_room->sector_type == SECT_WATER_NOSWIM )
act_move.c:        else if (IS_SET(ch->plr, PLR_FLEE ) )
act_move.c:    fch_next = fch->next_in_room;
act_move.c:    if (ch == fch || ch->mount == fch )
act_move.c:    if ( ch->mount != NULL && !IS_SET( ch->mount->affected_by, AFF_MOUNTED ) )
act_move.c:    else if (IS_SET( ch->plr, PLR_FLEE ) )
act_move.c:    else if ( ch->mount != NULL && IS_SET( ch->mount->affected_by , AFF_MOUNTED )
act_move.c:	 && (can_see(fch,ch) || can_see(fch, ch->mount) ) )
act_move.c:	sprintf(buf,"%s rides %s, mounted on %s.",PERS(ch, fch),dir_name[door],ch->mount->short_descr);
act_move.c:    	    if ( !IS_NPC(fch) && IS_SET(fch->plr, PLR_HOLYLIGHT) )
act_move.c:    else if (IS_SET( ch->act2, ACT2_MOVEABLE_AREA ) && ch->moveable->move_msg[0] != '\0' )
act_move.c:	sprintf(buf,"%s `w%s %s.",ch->short_descr,ch->moveable->move_msg,dir_name[door]);
act_move.c:    else if ( ch->in_room->sector_type == SECT_UNDERWATER )
act_move.c:    else if ( ch->in_room->sector_type == SECT_OCEAN_BOTTOM )
act_move.c:    else if ( ch->in_room->sector_type == SECT_WATER_SWIM )
act_move.c:    else if ( !found_boat && ch->in_room->sector_type == SECT_WATER_NOSWIM )
act_move.c:    else if (IS_SET( ch->plr, PLR_RUNNING ) )
act_move.c:    else if (IS_SET( ch->act2, ACT2_SHIP ) )
act_move.c:    else if (IS_NPC(ch) && ch->movement_msg[0] != '\0'  )
act_move.c:	sprintf(buf, "%s `w%s %s.", ch->short_descr,ch->movement_msg, dir_name[door]);
act_move.c:    trig = do_trigger( ch->in_room, ch, NULL, NULL, TRIG_LEAVES, TRIG_TYPE_ROOM);
act_move.c:    if ( IS_SET(ch->affected_by, AFF_HIDE ) )
act_move.c:	REMOVE_BIT( ch->affected_by, AFF_HIDE );
act_move.c:	fch_next = fch->next_in_room;
act_move.c:    	if (ch == fch || ch->mount == fch )
act_move.c:    	if ( ch->mount != NULL && !IS_SET( ch->mount->affected_by, AFF_MOUNTED ) )
act_move.c:    	    if ( !IS_NPC(fch) && IS_SET(fch->plr, PLR_HOLYLIGHT) )
act_move.c:    	else if (IS_SET( ch->plr, PLR_FLEE ) )
act_move.c:    	else if ( ch->mount != NULL && (can_see(fch,ch) || can_see(fch, ch->mount) ) )
act_move.c:		sprintf(buf,"%s `whas arrived riding %s, mounted on %s`w.",PERS(ch, fch),dir_name[door],ch->mount->short_descr);
act_move.c:    	else if (IS_SET( ch->act2, ACT2_MOVEABLE_AREA ) && ch->moveable->move_msg[0] != '\0' )
act_move.c:            	sprintf(buf,"%s `w%s in from %s.",ch->short_descr,ch->moveable->move_msg,dir_name_2[rev_dir[door]]);
act_move.c:    	else if ( ch->in_room->sector_type == SECT_UNDERWATER )
act_move.c:	else if ( ch->in_room->sector_type == SECT_OCEAN_BOTTOM )
act_move.c:    	else if ( ch->in_room->sector_type == SECT_WATER_SWIM )
act_move.c:    	else if (IS_SET( ch->plr, PLR_RUNNING ) )
act_move.c:    	else if (IS_SET( ch->act2, ACT2_SHIP ) )
act_move.c:    	else if (IS_NPC(ch) && ch->movement_msg[0] != '\0' ) 
act_move.c:		sprintf(buf, "%s `w%s in from %s.",ch->short_descr, ch->movement_msg, dir_name_2[rev_dir[door]]);
act_move.c:trig = do_trigger( ch->in_room, ch, NULL, NULL, TRIG_ENTER, TRIG_TYPE_ROOM);
act_move.c:    if ( ch->mount != NULL && IS_SET( ch->mount->affected_by , AFF_MOUNTED ) )
act_move.c:	if ( ch->mount->in_room != in_room )
act_move.c:	    sprintf( buf, "do_move: Mounted rider (%s) not in room (%ld) with mount (%ld)\n\r",ch->name,in_room->vnum,ch->mount->in_room->vnum);
act_move.c:	    REMOVE_BIT( ch->mount->affected_by, AFF_MOUNTED);
act_move.c:            char_from_room( ch->mount );
act_move.c:            char_to_room( ch->mount, to_room );
act_move.c:	fch_next = fch->next_in_room;
act_move.c:	if ( fch->master == ch && IS_AFFECTED(fch,AFF_CONTROL_MIND) && !IS_SET(fch->act,ACT_MOUNT)
act_move.c:	&&   fch->position < POS_STANDING)
act_move.c:	if ( fch->master == ch && fch->position == POS_STANDING )
act_move.c:			&& ( ch->mount == NULL || !IS_SET(ch->mount->affected_by,AFF_FLYING|AFF_LEVITATING) ) )
act_move.c:			&& !IS_SET(ch->affected_by, AFF_FLYING)
act_move.c:			if ( !IS_SET(ch->affected_by, AFF_LEVITATE) )
act_move.c:			    SET_BIT(ch->affected_by_2, AFF_FALLING);
act_move.c:        af.duration  = 4 + ( ch->level * URANGE( 1, get_skill( ch, gsn_hold_breath ), 100 ) / 200 );
act_move.c:        af.level     = ch->level;
act_move.c:    if( ch->mount != NULL && IS_SET( ch->mount->affected_by , AFF_MOUNTED ) )
act_move.c:   if ( ch->mount != victim )
act_move.c:	    if ( ch->mount->master == ch )
act_move.c:    if( ch->mount == NULL || !IS_SET( ch->mount->affected_by , AFF_MOUNTED ) )
act_move.c:	victim = ch->mount;
act_move.c:	    if ( ( pexit = ch->in_room->exit[door] ) != NULL
act_move.c:    if ( ( pexit = ch->in_room->exit[door] ) == NULL 
act_move.c:	ROOM_INDEX_DATA *in_room=ch->in_room;
act_move.c:	pexit = ch->in_room->exit[door];
act_move.c:	if ( is_locked_door( ch->in_room, door ) )
act_move.c:	for ( rch = ch->in_room->people ; rch != NULL ; rch = rch->next_in_room )
act_move.c:	for ( rch = ch->in_room->people ; rch != NULL ; rch=rch->next_in_room )
act_move.c:		&& ( rch->mount == NULL || !IS_SET(rch->mount->affected_by,AFF_FLYING|AFF_LEVITATING) ) )
act_move.c:	for ( rch = ch->in_room->people ; rch != NULL ; rch=rch->next_in_room )
act_move.c:		&& !IS_SET(rch->affected_by, AFF_FLYING)
act_move.c:		if ( !IS_SET(rch->affected_by, AFF_LEVITATE) )
act_move.c:		    SET_BIT(rch->affected_by_2, AFF_FALLING);
act_move.c:	&&   pexit_rev->u1.to_room == ch->in_room )
act_move.c:	    for ( rch = to_room->people; rch != NULL; rch = rch->next_in_room )
act_move.c:	pexit	= ch->in_room->exit[door];
act_move.c:	&&   pexit_rev->u1.to_room == ch->in_room )
act_move.c:	    for ( rch = to_room->people; rch != NULL; rch = rch->next_in_room )
act_move.c:    autoexit = ( IS_SET( ch->plr, PLR_AUTOEXIT ) ? TRUE : FALSE );
act_move.c:    automap = ( IS_SET( ch->plr, PLR_AUTOMAP ) ? TRUE : FALSE );
act_move.c:    brief = ( IS_SET( ch->comm, COMM_BRIEF ) ? TRUE : FALSE );
act_move.c:    d_hide = ( IS_SET( ch->affected_by , AFF_DETECT_HIDDEN ) ? TRUE : FALSE );
act_move.c:    SET_BIT( ch->comm, COMM_BRIEF );
act_move.c:    SET_BIT( ch->plr, PLR_RUNNING );
act_move.c:    REMOVE_BIT( ch->affected_by, AFF_DETECT_HIDDEN );
act_move.c:    REMOVE_BIT( ch->affected_by, AFF_SNEAK );
act_move.c:    REMOVE_BIT( ch->affected_by_2, AFF_FADE );
act_move.c:    REMOVE_BIT( ch->affected_by, AFF_HIDE );
act_move.c:    REMOVE_BIT( ch->plr, PLR_AUTOEXIT );
act_move.c:    REMOVE_BIT( ch->plr, PLR_AUTOMAP );
act_move.c:    sprintf(arg,"%s sprints off heading %s.\n\r",(IS_NPC(ch)?ch->short_descr:ch->name),dir_name[direction] );
act_move.c:    for ( rooms = 0 ; rooms < get_curr_stat( ch, STAT_CON ) && ch->in_room != in_room ; rooms++ )
act_move.c:	in_room = ch->in_room;
act_move.c:	        if ( !brief ) REMOVE_BIT( ch->comm, COMM_BRIEF );
act_move.c:	        if ( d_hide ) SET_BIT( ch->affected_by, AFF_DETECT_HIDDEN );
act_move.c:	        if ( autoexit ) SET_BIT( ch->plr, PLR_AUTOEXIT );
act_move.c:	        if ( automap ) SET_BIT( ch->plr, PLR_AUTOMAP );
act_move.c:    	        REMOVE_BIT( ch->plr, PLR_RUNNING );
act_move.c:	    ch->hit = UMAX( -1, ch->hit - dice(rooms + 1 ,2) );
act_move.c:	    if ( !brief ) REMOVE_BIT( ch->comm, COMM_BRIEF );
act_move.c:	    if ( d_hide ) SET_BIT( ch->affected_by, AFF_DETECT_HIDDEN );
act_move.c:	    if ( autoexit ) SET_BIT( ch->plr, PLR_AUTOEXIT );
act_move.c:    	    REMOVE_BIT( ch->plr, PLR_RUNNING );
act_move.c:	  &&   !IS_SET(ch->plr, PLR_WIZPASS )  ) 
act_move.c:	    if ( number_percent() < rooms * race_table[ ch->race ][ ch->sex ].size * (is_locked_door( ch->in_room, direction )?1:3) && !IS_SET(pexit->exit_info, EX_BASHPROOF ) )
act_move.c:	        ch->hit = UMAX( -1, ch->hit - dice(rooms + 1,2) / 2 );
act_move.c:		if ( pexit->u1.to_room->exit[rev_dir[direction]]->u1.to_room == ch->in_room )
act_move.c:	        ch->hit = UMAX( -1, ch->hit - dice(rooms + 1,2) );
act_move.c:	        ch->hit = UMAX( -1, ch->hit - dice(rooms + 1,2) );
act_move.c:		ch->hit = UMAX( 1, ch->hit );
act_move.c:	    if ( !brief ) REMOVE_BIT( ch->comm, COMM_BRIEF );
act_move.c:	    if ( d_hide ) SET_BIT( ch->affected_by, AFF_DETECT_HIDDEN );
act_move.c:	    if ( autoexit ) SET_BIT( ch->plr, PLR_AUTOEXIT );
act_move.c:	    if ( automap ) SET_BIT( ch->plr, PLR_AUTOMAP );
act_move.c:    	    REMOVE_BIT( ch->plr, PLR_RUNNING );
act_move.c:	if ( ch->in_room->exit[ direction ]->u1.to_room == ch->in_room )
act_move.c:	    if ( !brief ) REMOVE_BIT( ch->comm, COMM_BRIEF );
act_move.c:	    if ( d_hide ) SET_BIT( ch->affected_by, AFF_DETECT_HIDDEN );
act_move.c:	    if ( autoexit ) SET_BIT( ch->plr, PLR_AUTOEXIT );
act_move.c:	    if ( automap ) SET_BIT( ch->plr, PLR_AUTOMAP );
act_move.c:    	    REMOVE_BIT( ch->plr, PLR_RUNNING );
act_move.c:	ch->move = UMAX( 0, ch->move - 10 );
act_move.c:    if ( !brief ) REMOVE_BIT( ch->comm, COMM_BRIEF );
act_move.c:    if ( d_hide ) SET_BIT( ch->affected_by, AFF_DETECT_HIDDEN );
act_move.c:    if ( autoexit ) SET_BIT( ch->plr, PLR_AUTOEXIT );
act_move.c:    if ( automap ) SET_BIT( ch->plr, PLR_AUTOMAP );
act_move.c:    REMOVE_BIT( ch->plr, PLR_RUNNING );
act_move.c:	    for ( key = ch->carrying ; key != NULL && key->pIndexData->vnum != lock_list->vnum ; key = key->next_content );
act_move.c:	pexit	= ch->in_room->exit[door];
act_move.c:	    for ( key = ch->carrying ; key != NULL && key->pIndexData->vnum != lock_list->vnum ; key = key->next_content );
act_move.c:	    if ( is_door( pexit_rev ) && pexit_rev->u1.to_room == ch->in_room )
act_move.c:	    for ( key = ch->carrying ; key != NULL && key->pIndexData->vnum != lock_list->vnum ; key = key->next_content );
act_move.c:	pexit	= ch->in_room->exit[door];
act_move.c:	if ( !is_locked_door( ch->in_room, door ) )
act_move.c:	    for ( key = ch->carrying ; key != NULL && key->pIndexData->vnum != lock_list->vnum ; key = key->next_content );
act_move.c:	    if ( is_door( pexit_rev ) && pexit_rev->u1.to_room == ch->in_room )
act_move.c:    for ( gch = ch->in_room->people; gch; gch = gch->next_in_room )
act_move.c:	if ( IS_NPC(gch) && IS_AWAKE(gch) && ch->level + 5 < gch->level )
act_move.c:	pexit = ch->in_room->exit[door];
act_move.c:	if ( !is_locked_door( ch->in_room, door ) )
act_move.c:	    if ( is_door( pexit_rev ) && pexit_rev->u1.to_room == ch->in_room )
act_move.c:    switch ( ch->position )
act_move.c:    	if (IS_SET(ch->dream_flags, DREAM_IS_NIGHTMARE ) )
act_move.c:    switch ( ch->position )
act_move.c:    switch (ch->position)
act_move.c:    for ( rch = ch->in_room->people ; rch != NULL ; rch = rch->next_in_room )
act_move.c:	if ( rch->fighting != NULL )
act_move.c:    switch ( ch->position )
act_move.c:    if (IS_SET(ch->dream_flags, DREAM_IS_NIGHTMARE ) )
act_move.c:    	ch->dream_flags = 0;
act_move.c:    	ch->dream_count = 0;
act_move.c:    ch->dream_flags = 0;
act_move.c:    ch->dream_count = 0;
act_move.c:   brightness = get_light_adjustment( ch, ch->in_room ) ;
act_move.c:	af.level     = ch->level; 
act_move.c:	af.duration  = ch->level;
act_move.c:   brightness = get_light_adjustment( ch, ch->in_room ) ;
act_move.c:	REMOVE_BIT(ch->affected_by_2, AFF_FADE);
act_move.c:	REMOVE_BIT(ch->affected_by, AFF_HIDE);
act_move.c:	SET_BIT(ch->affected_by, AFF_HIDE);
act_move.c:   brightness = get_light_adjustment( ch, ch->in_room ) ;
act_move.c:	REMOVE_BIT(ch->affected_by, AFF_HIDE);
act_move.c:	REMOVE_BIT(ch->affected_by_2, AFF_FADE);
act_move.c:	SET_BIT(ch->affected_by_2, AFF_FADE);
act_move.c:    REMOVE_BIT   ( ch->affected_by, AFF_HIDE		);
act_move.c:    REMOVE_BIT   ( ch->affected_by_2, AFF_FADE		);
act_move.c:    REMOVE_BIT   ( ch->affected_by, AFF_SHADOWFORM	);
act_move.c:    REMOVE_BIT   ( ch->affected_by, AFF_SNEAK		);
act_move.c:    if ( ch->pcdata != NULL )
act_move.c:    ch->affected_by=ch->affected_by|ch->pcdata->perm_aff;
act_move.c:    ch->affected_by_2=ch->affected_by_2|ch->pcdata->perm_aff_2;
act_move.c:    if (IS_NPC(ch) && !IS_SET(ch->act2, ACT2_GUIDE) && !IS_SET(ch->act,ACT_PET) && !IS_SET(ch->act,ACT_MOUNT))
act_move.c:    if ( ch->level >= 10 && !IS_IMMORTAL(ch) && !IS_NPC( ch ) ) 
act_move.c:    if ( !IS_NPC( ch ) && ch->pcdata->pcclan == NULL )
act_move.c:        if ( ( location = get_room_index( race_table[ ch->race ][ ch->sex ].begin ) ) == NULL )
act_move.c:    	location = get_room_index( ch->pcdata->pcclan->clan->recall_room );
act_move.c:	    if ( ( location = get_room_index( race_table[ ch->race ][ ch->sex ].begin ) ) == NULL )
act_move.c:	if ( ( location = get_room_index( race_table[ ch->race ][ ch->sex ].begin ) ) == NULL )
act_move.c:    if ( ch->in_room == location || location == NULL )
act_move.c:    if ( ch->in_room == NULL )
act_move.c:    if ( IS_SET(ch->in_room->room_flags, ROOM_NO_RECALL)
act_move.c:    if ( ( victim = ch->fighting ) != NULL )
act_move.c:	 skill = 40 + ch->level;
act_move.c:	lose = (ch->desc != NULL) ? 25 : 50;
act_move.c:    ch->move /= 2;
act_move.c:    if ( ch->inside_area != NULL )
act_move.c:	free_inside_area_data(ch->inside_area);
act_move.c:    ch->inside_area = NULL;	
act_move.c:    if (ch->mount != NULL )
act_move.c:        if ( IS_SET(ch->mount->affected_by,AFF_MOUNTED) )
act_move.c:            char_from_room( ch->mount );
act_move.c:            char_to_room( ch->mount, location );
act_move.c:	    do_recall( ch->mount, "" );
act_move.c:    if (ch->pet != NULL)
act_move.c:	do_recall(ch->pet,"");
act_move.c:    else if ( !IS_NPC( ch ) && ch->pet == NULL && ch->level < 10 ) 
act_move.c:            char_to_room( mob, ch->in_room );
act_move.c:            ch->pet = mob;
act_move.c:    for ( mob = ch->in_room->people; mob; mob = mob->next_in_room )
act_move.c:	sprintf( buf, "You have %d practices.\n\r", ch->practice );
act_move.c:	if ( ch->perm_stat[STAT_STR] < get_max_train(ch,STAT_STR)) 
act_move.c:	    sprintf( buf1, " str( %d )", train_cost_table[ ch->perm_stat[ STAT_STR ] + 1 ][ STAT_STR ] );
act_move.c:	if ( ch->perm_stat[STAT_INT] < get_max_train(ch,STAT_INT))  
act_move.c:	    sprintf( buf1, " int( %d )", train_cost_table[ ch->perm_stat[ STAT_INT ] + 1 ][ STAT_INT ] );
act_move.c:	if ( ch->perm_stat[STAT_WIS] < get_max_train(ch,STAT_WIS)) 
act_move.c:	    sprintf( buf1, " wis( %d )", train_cost_table[ ch->perm_stat[ STAT_WIS ] + 1 ][ STAT_WIS ] );
act_move.c:	if ( ch->perm_stat[STAT_DEX] < get_max_train(ch,STAT_DEX))  
act_move.c:	    sprintf( buf1, " dex( %d )", train_cost_table[ ch->perm_stat[ STAT_DEX ] + 1 ][ STAT_DEX ] );
act_move.c:	if ( ch->perm_stat[STAT_CON] < get_max_train(ch,STAT_CON))  
act_move.c:	    sprintf( buf1, " con( %d )", train_cost_table[ ch->perm_stat[ STAT_CON ] + 1 ][ STAT_CON ] );
act_move.c:	if ( ch->perm_stat[STAT_CHR] < get_max_train(ch,STAT_CHR))  
act_move.c:	    sprintf( buf1, " chr( %d )", train_cost_table[ ch->perm_stat[ STAT_CHR ] + 1 ][ STAT_CHR ] );
act_move.c:	cost = train_cost_table[ ch->perm_stat[ stat ] + 1 ][ stat ];
act_move.c:    	if ( cost > ch->practice )
act_move.c:	ch->practice -= cost;
act_move.c:        ch->pcdata->perm_hit += 10;
act_move.c:        ch->max_hit += 10;
act_move.c:        ch->hit +=10;
act_move.c:        if (cost > ch->practice )
act_move.c:	ch->practice -= cost;
act_move.c:        ch->pcdata->perm_mana[ type ] += 30;
act_move.c:        ch->max_mana[ type ] += 30;
act_move.c:        ch->mana[ type ] += 30;
act_move.c:    if ( ch->perm_stat[stat]  >= get_max_train(ch,stat) )
act_move.c:    if ( cost > ch->practice  )
act_move.c:    ch->practice		-= cost;
act_move.c:    ch->perm_stat[stat]		+= 1;
act_move.c:    if ( !IS_IMMORTAL( ch ) && ( IS_SET(ch->in_room->room_flags, ROOM_NO_RECALL)
act_move.c:    if ( ch->pcdata == NULL || ch->home < 1 || ( home = get_room_index(ch->home) ) == NULL ) 
act_move.c:    if ( ch->in_room == home )
act_move.c:	if ( ch->in_room->area->world != home->area->world )
act_move.c:	if ( ch->pcdata->home_timer < 5 )
act_move.c:	 ch->move /= 2;
act_move.c:    ch->pcdata->home_timer = 0;
act_move.c:    if (strlen(ch->pcdata->bamfout) != 0)
act_move.c:        cact (ch->pcdata->bamfout,ch,NULL,ch,TO_ROOM,"`b");
act_move.c:    if ( ch->inside_area != NULL )
act_move.c:	free_inside_area_data(ch->inside_area);
act_move.c:	ch->inside_area = NULL;	
act_move.c:    char_to_room(ch,get_room_index(ch->home));
act_move.c:  if ((obj = get_obj_list (ch, arg, ch->in_room->contents)) == NULL)
act_move.c:	trig = do_trigger( ch->in_room, ch, NULL, NULL, TRIG_LEAVES, TRIG_TYPE_ROOM);
act_move.c:	in_room = ch->in_room;
act_move.c:	    fch_next = fch->next_in_room;
act_move.c:	    if ( fch->master == ch && IS_AFFECTED(fch,AFF_CONTROL_MIND) && !IS_SET(fch->act,ACT_MOUNT)
act_move.c:	    &&   fch->position < POS_STANDING)
act_move.c:  	    if ( fch->master == ch && fch->position == POS_STANDING )
act_move.c:	    if ( IS_NPC(ch) && !IS_SET( ch->affected_by, AFF_BREATHE_UNDERWATER ) )
act_move.c:	      &&   !IS_SET( ch->plr2, PLR_SPECIAL_PASS )
act_move.c:                && ( ch->mount != NULL 
act_move.c:                   && !IS_SET( ch->mount->affected_by , AFF_BREATHE_UNDERWATER ) ))
act_move.c:		if ( IS_SET( ch->mount->affected_by, AFF_MOUNTED) )
act_move.c:			&& ( ch->mount == NULL || !IS_SET(ch->mount->affected_by,AFF_FLYING|AFF_LEVITATING) ) )
act_move.c:			&& !IS_SET(ch->affected_by, AFF_FLYING)
act_move.c:			if ( !IS_SET(ch->affected_by, AFF_LEVITATE) )
act_move.c:			    SET_BIT(ch->affected_by_2, AFF_FALLING);
act_move.c:	if ( ch->inside_area == NULL )
act_move.c:	ch->inside_area = inside_area_alloc();
act_move.c:	strncpy( ch->inside_area->mob_name, victim->name, 30 );
act_move.c:	strncpy( ch->inside_area->short_descr, victim->short_descr, 80 );
act_move.c: 	ch->inside_area->start_room = victim->moveable->area_start_room; 
act_move.c:  for ( s = ch->in_room->spro;s != NULL; s = s->next ) /* possible moveable area */
act_move.c:    if ( ch->inside_area == NULL ) /* oops! Summon, Or just starting the game.. This may be NULL But we need to set */
act_move.c:	       if ( ch->in_room->area == pRoom->area ) /* If so, we must have the right moveable area */
act_move.c:		ch->inside_area = inside_area_alloc();
act_move.c:		strncpy( ch->inside_area->mob_name, victim->name, 30 );
act_move.c:		strncpy( ch->inside_area->short_descr, victim->short_descr, 80 );
act_move.c: 		ch->inside_area->start_room = victim->moveable->area_start_room; 
act_move.c:    if ( ( location = find_location(ch, ch->inside_area->mob_name ) ) == NULL )
act_move.c:	act ("$n leaves $T",ch,NULL,ch->inside_area->short_descr,TO_ROOM);	
act_move.c:	sprintf(buf,"You climb down from %s\n\r",ch->inside_area->short_descr);
act_move.c:        act ("$n leaves $T",ch,NULL,ch->inside_area->short_descr,TO_ROOM);	
act_move.c:	free_inside_area_data(ch->inside_area); /* Wont need till they board again */
act_move.c:	ch->inside_area = NULL;
act_move.c:  if (ch->inside_area != NULL )
act_move.c:     sprintf(buf,"You can't leave %s from here",ch->inside_area->short_descr);
act_move.c:    track->track_penalty = track_penalty[ ch->in_room->sector_type ];
act_move.c:    track->time = track_time[ ch->in_room->sector_type ] * ( ch->size + 1 );
act_move.c:    if ( ( ch->mount != NULL && ch->in_room == ch->mount->in_room && IS_AFFECTED( ch->mount, AFF_MOUNTED ) && !IS_AFFECTED( ch->mount, AFF_FLYING|AFF_LEVITATING ) )
act_move.c:	  || ( ch->mount != NULL && ch->mount->in_room == ch->in_room && IS_AFFECTED( ch->mount, AFF_MOUNTED ) && IS_AFFECTED( ch->mount, AFF_FLYING|AFF_LEVITATING ) ) )
act_move.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_INDOORS ) )
act_move.c:    ROOM_INDEX_DATA * room = ch->in_room;
act_move.c:    skill += ( IS_SET( ch->affected_by_2, AFF_SENSES ) ? ch->level : 0 );
act_move.c:    WAIT_STATE( ch, ( 3 - ( ch->level / 15 ) ) * PULSE_PER_SECOND );
act_move.c:	    for ( vch = char_list ; vch != NULL && vch != tracks->ch ; vch = vch->next );
act_move.c:	      || ( !is_name( arg, vch->name ) && fPass )
act_move.c:	      || ( is_name( arg, vch->name ) && !fPass ) )
act_move.c:    ROOM_INDEX_DATA * room = ch->in_room;
act_move.c:    if ( ch->desc == NULL || ch->desc->inbuf[0] != '\0' )
act_move.c:	ch->hunting[0] = '\0';
act_move.c:	ch->hunting[0] = '\0';
act_move.c:    skill += ( IS_SET( ch->affected_by_2, AFF_SENSES ) ? ch->level : 0 );
act_move.c:	if ( ch->hunting[0] == '\0' )
act_move.c:	    strncpy( arg, ch->hunting,30 );
act_move.c:	strncpy(ch->hunting, arg,30);
act_move.c:	ch->hunting[0] = '\0';
act_move.c:	    for ( vch = char_list ; vch != NULL && vch != tracks->ch ; vch = vch->next );
act_move.c:	      || ( !is_name( arg, vch->name ) && fPass )
act_move.c:	      || ( is_name( arg, vch->name ) && !fPass ) )
act_move.c:        ch->hunting[0] =  '\0';
act_move.c:        ch->hunting[0] = '\0';
act_move.c:    if ( room == ch->in_room )
act_move.c:        ch->hunting[0] = '\0';
act_move.c:    if ( ch->inside_area == NULL ) /* oops! Summon, Or just starting the game.. This may be NULL But we need to set */
act_move.c:	       if ( ch->in_room->area == pRoom->area ) /* If so, we must have the right moveable area */
act_move.c:		ch->inside_area = inside_area_alloc();
act_move.c:		strncpy( ch->inside_area->mob_name, victim->name, 30 );
act_move.c:		strncpy( ch->inside_area->short_descr, victim->short_descr, 80 );
act_move.c: 		ch->inside_area->start_room = victim->moveable->area_start_room; 
act_move.c:	if (ch->inside_area == NULL ) /* This should never happen */
act_move.c:	if ( is_name( ch->inside_area->mob_name, victim->name ) )
act_move.c:    sprintf(buf, "%s steers %s %s",IS_NPC(ch) ? ch->short_descr : ch->name, victim->short_descr, dir_name[door]);
act_move.c:    in_room = ch->in_room;
act_move.c:    for ( rch = ch->in_room->people ; rch != NULL ; rch = rch->next_in_room )
act_move.c:	rch->in_room = victim->in_room;
act_move.c:	rch->in_room = in_room;
act_move.c:   if ( to_obj->in_room->area->visible > ch->level )
act_move.c:      && !IS_SET(ch->in_room->room_flags_2, ROOM_STARTING ) )
act_move.c:   if ( to_mob->in_room->area->visible > ch->level )
act_move.c:   if ( to_room->area->visible > ch->level )
act_obj.c:    if ( ch->pcdata == NULL || ch->home < 1 || ( home = get_room_index(ch->home) ) == NULL )
act_obj.c:    size_diff = ch->size - obj->wear_data->size;
act_obj.c:    if ( ch->race == 6 )
act_obj.c:    size_diff = ch->size - obj->wear_data->size;
act_obj.c:    if ( ch->race == 6 )
act_obj.c:    size_diff = ch->size - obj->wear_data->size;
act_obj.c:    if ( ch->race == 6 )
act_obj.c:    size_diff = ch->size - obj->wear_data->size;
act_obj.c:    if ( ch->race == 6 )
act_obj.c:        total += exchange_rate[ num ] [ coin_type ] *  ch->gold[ num ] / 100;
act_obj.c:	cost = UMIN( ch->gold[ num % MAX_WORLD ] , ( 100 * total % exchange_rate[ num % MAX_WORLD ] [ coin_type ] ? 100 * total / exchange_rate[ num % MAX_WORLD ] [ coin_type ] + 1 : 100 * total / exchange_rate[ num % MAX_WORLD ] [ coin_type ] ) );  
act_obj.c:	ch->gold[ num % MAX_WORLD ] -= cost;
act_obj.c:	cost = UMIN( ch->gold[ num % MAX_WORLD ] , ( 100 * total % exchange_rate[ num % MAX_WORLD ] [ coin_type ] ? 100 * total / exchange_rate[ num % MAX_WORLD ] [ coin_type ] + 1 : 100 * total / exchange_rate[ num % MAX_WORLD ] [ coin_type ] ) );  
act_obj.c:	ch->gold[ num % MAX_WORLD ] -= cost;
act_obj.c:    for ( wch = char_list; wch != NULL ; wch = wch->next )
act_obj.c:        if ( !str_cmp( wch->name, obj->owner ) )
act_obj.c:    if ( !str_cmp( ch->name, owner->name ) )
act_obj.c:	    ch->pcdata->minerals[MINERAL_STEEL] = URANGE( 0, ch->pcdata->minerals[MINERAL_STEEL] + obj->wear_data->weight, 1000 );
act_obj.c:	    ch->pcdata->minerals[MINERAL_GOLD] = URANGE( 0, ch->pcdata->minerals[MINERAL_GOLD] + obj->wear_data->weight, 1000 );
act_obj.c:	    ch->pcdata->minerals[MINERAL_SILVER] = URANGE( 0, ch->pcdata->minerals[MINERAL_SILVER] + obj->wear_data->weight, 1000 );
act_obj.c:	    ch->pcdata->minerals[MINERAL_RUBY] = URANGE( 0, ch->pcdata->minerals[MINERAL_RUBY] + obj->wear_data->weight, 1000 );
act_obj.c:	    ch->pcdata->minerals[MINERAL_SAPPHIRE] = URANGE( 0, ch->pcdata->minerals[MINERAL_SAPPHIRE] + obj->wear_data->weight, 1000 );
act_obj.c:	    ch->pcdata->minerals[MINERAL_IRON] = URANGE( 0, ch->pcdata->minerals[MINERAL_IRON] + obj->wear_data->weight, 1000 );
act_obj.c:	    ch->pcdata->minerals[MINERAL_BRONZE] = URANGE( 0, ch->pcdata->minerals[MINERAL_BRONZE] + obj->wear_data->weight, 1000 );
act_obj.c:	    ch->pcdata->minerals[MINERAL_COPPER] = URANGE( 0, ch->pcdata->minerals[MINERAL_COPPER] + obj->wear_data->weight, 1000 );
act_obj.c:	    ch->pcdata->minerals[MINERAL_EMERALD] = URANGE( 0, ch->pcdata->minerals[MINERAL_EMERALD] + obj->wear_data->weight, 1000 );
act_obj.c:	    ch->pcdata->minerals[MINERAL_PLATINUM] = URANGE( 0, ch->pcdata->minerals[MINERAL_PLATINUM] + obj->wear_data->weight, 1000 );
act_obj.c:	    ch->pcdata->minerals[MINERAL_MITHRIL] = URANGE( 0, ch->pcdata->minerals[MINERAL_MITHRIL] + obj->wear_data->weight, 1000 );
act_obj.c:	    ch->pcdata->minerals[MINERAL_DIAMOND] = URANGE( 0, ch->pcdata->minerals[MINERAL_DIAMOND] + obj->wear_data->weight, 1000 );
act_obj.c:	    ch->pcdata->minerals[MINERAL_OBSIDIAN] = URANGE( 0, ch->pcdata->minerals[MINERAL_OBSIDIAN] + obj->wear_data->weight, 1000 );
act_obj.c:	    ch->pcdata->minerals[MINERAL_ALABASTER] = URANGE( 0, ch->pcdata->minerals[MINERAL_ALABASTER] + obj->wear_data->weight, 1000 );
act_obj.c:	    ch->pcdata->minerals[MINERAL_TITANIUM] = URANGE( 0, ch->pcdata->minerals[MINERAL_TITANIUM] + obj->wear_data->weight, 1000 );
act_obj.c:	    ch->pcdata->minerals[MINERAL_ADAMANTITE] = URANGE( 0, ch->pcdata->minerals[MINERAL_ADAMANTITE] + obj->wear_data->weight, 1000 );
act_obj.c:    if ( ch->carry_number >= can_carry_n( ch ) )
act_obj.c:    if ( ch->carry_weight + get_obj_weight( obj ) > can_carry_w( ch ) )
act_obj.c:	ch->gold[ coin_type ] += value;
act_obj.c:        if (IS_SET(ch->plr,PLR_AUTOSPLIT))
act_obj.c:    	  for (gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
act_obj.c:	trig = do_trigger( ch->in_room, ch, obj, NULL, TRIG_GETS, TRIG_TYPE_ROOM);
act_obj.c:	    strncpy(obj->owner, ch->name,30 );
act_obj.c:    for ( component = ch->carrying; component != NULL && component->pIndexData->vnum != 18050 ; component = component->next_content );
act_obj.c:	spell->level = URANGE( 1, ch->level + number_range( -5, 5 ), 60 );
act_obj.c:	    exp = ( ch->level * number_range( 5000, 25000 ) ) / 2;
act_obj.c:    	    exp = ch->level * number_range(5000, 25000);
act_obj.c:	    ch->mana[ ELEMENT_WATER ] = UMIN( ch->max_mana[ ELEMENT_WATER ] , ch->mana[ ELEMENT_WATER ] + mana );
act_obj.c:	    ch->mana[ ELEMENT_FIRE ] = UMIN( ch->max_mana[ ELEMENT_FIRE ] , ch->mana[ ELEMENT_FIRE ] + mana );
act_obj.c:	    ch->mana[ ELEMENT_EARTH ] = UMIN( ch->max_mana[ ELEMENT_EARTH ] , ch->mana[ ELEMENT_EARTH ] + mana );
act_obj.c:	    ch->mana[ ELEMENT_WIND ] = UMIN( ch->max_mana[ ELEMENT_WIND ] , ch->mana[ ELEMENT_WIND ] + mana );
act_obj.c:	    ch->mana[ ELEMENT_SPIRIT ] = UMIN( ch->max_mana[ ELEMENT_SPIRIT ] , ch->mana[ ELEMENT_SPIRIT ] + mana );
act_obj.c:	    ch->move = UMIN( ch->max_move, ch->move + mana );
act_obj.c:	    ch->hit = UMIN( ch->max_hit, ch->hit + mana );
act_obj.c:	    ch->mana[ ELEMENT_SPIRIT ] = UMIN( ch->max_mana[ ELEMENT_SPIRIT ] , ch->mana[ ELEMENT_SPIRIT ] + mana );
act_obj.c:	    ch->mana[ ELEMENT_WATER ] = UMIN( ch->max_mana[ ELEMENT_WATER ] , ch->mana[ ELEMENT_WATER ] + mana );
act_obj.c:	    ch->mana[ ELEMENT_EARTH ] = UMIN( ch->max_mana[ ELEMENT_EARTH ] , ch->mana[ ELEMENT_EARTH ] + mana );
act_obj.c:	    ch->mana[ ELEMENT_WIND ] = UMIN( ch->max_mana[ ELEMENT_WIND ] , ch->mana[ ELEMENT_WIND ] + mana );
act_obj.c:	    ch->mana[ ELEMENT_FIRE ] = UMIN( ch->max_mana[ ELEMENT_FIRE ] , ch->mana[ ELEMENT_FIRE ] + mana );
act_obj.c:	    ch->move = UMIN( ch->max_move, ch->move + mana );
act_obj.c:	    ch->hit = UMIN( ch->max_hit, ch->hit + mana );
act_obj.c:	    ch->mana[ ELEMENT_WATER ] = ch->max_mana[ ELEMENT_WATER ];
act_obj.c:	    ch->mana[ ELEMENT_FIRE ] = ch->max_mana[ ELEMENT_FIRE ];
act_obj.c:	    ch->mana[ ELEMENT_WIND ] = ch->max_mana[ ELEMENT_WIND ];
act_obj.c:	    ch->mana[ ELEMENT_EARTH ] = ch->max_mana[ ELEMENT_EARTH ];
act_obj.c:	    ch->mana[ ELEMENT_SPIRIT ] = ch->max_mana[ ELEMENT_SPIRIT ];
act_obj.c:	    ch->move = ch->max_move;
act_obj.c:	    ch->hit = ch->max_hit;
act_obj.c:    coin_type = ch->in_room->area->world;
act_obj.c:    level = vch->level;
act_obj.c:    if ( get_money_total( ch, ch->in_room->area->world ) < cost )
act_obj.c:    for ( i = 0 ; i < ( 80 - strlen( vch->name ) ) / 2 + 1 ; i++ ) strcat( buf, " " );
act_obj.c:    strcat( buf, capitalize( vch->name ) );
act_obj.c:    obj_to_room( obj, ch->in_room );
act_obj.c:    get_char_money( ch, cost, ch->in_room->area->world );
act_obj.c:    for ( af = vch->affected ; af != NULL ; af = af_next )
act_obj.c:    send_to_area( ch->in_room->area, "You hear a soft trumpet solo, signalling the end of a funeral.\n\r" );
act_obj.c:	if ( ch->sex != SEX_FEMALE )
act_obj.c:	if ( ch->mate[0] == '\0' )
act_obj.c:	for ( vch = ch->in_room->people ; vch != NULL ; vch = vch->next_in_room ) 
act_obj.c:		&&  ( vch->mate[0] == '\0' )
act_obj.c:		&& vch->sex == SEX_FEMALE )
act_obj.c:	if ( ch->sex != SEX_MALE )
act_obj.c:	if ( ch->mate[0] == '\0' )
act_obj.c:	for ( vch = ch->in_room->people ; vch != NULL ; vch = vch->next_in_room ) 
act_obj.c:		&&  ( vch->mate[0] == '\0' )
act_obj.c:		&& vch->sex == SEX_MALE )
act_obj.c:    for ( obj = ch->carrying; obj != NULL && ( obj->light_data == NULL || !IS_SET( obj->light_data->flags, LIGHT_BURNING ) || !IS_SET( obj->light_data->flags, LIGHT_LIT|LIGHT_MAGIC_LIT ) ) ; obj = obj->next_content ); 
act_obj.c:        for ( obj = ch->in_room->contents; obj != NULL && ( obj->light_data == NULL || !IS_SET( obj->light_data->flags, LIGHT_BURNING ) || !IS_SET( obj->light_data->flags, LIGHT_LIT|LIGHT_MAGIC_LIT ) ) ; obj = obj->next_content ); 
act_obj.c:    for ( smithy = ch->in_room->people; smithy != NULL ; smithy = smithy->next_in_room )
act_obj.c:    if ( get_skill( ch, gsn_repair ) < 1 || ( skill = get_skill( ch, gsn_repair ) * ch->level / 100 ) + ( obj->condition ) < number_percent() )
act_obj.c:    if ( ch->pcdata != NULL && ch->pcdata->debt != NULL )
act_obj.c:    if ( ch->level < 5 || ch->pcdata == NULL )
act_obj.c:	ch->gold[ type ] += value;
act_obj.c:    if ( value > ch->level * ch->level * 20 )
act_obj.c:	sprintf( buf, "Sorry you cannot borrow more then %d.\n\r", ch->level * ch->level * 20 );
act_obj.c:    ch->pcdata->debt = debt_data_alloc();
act_obj.c:    ch->pcdata->debt->type = type;
act_obj.c:    ch->pcdata->debt->vnum = ch->in_room->vnum;
act_obj.c:    ch->pcdata->debt->amount = value * 2;
act_obj.c:    ch->gold[ type ] += value;
act_obj.c:    ch->pcdata->debt->due = ch->played + 18000 * 3 + current_time - ch->logon;
act_obj.c:    ch->pcdata->debt->timer = 0;
act_obj.c:	ch->pcdata->debt->amount,
act_obj.c:	coin_name[ ch->pcdata->debt->type ] );
act_obj.c:    if ( ch->pcdata == NULL || ch->pcdata->debt == NULL )
act_obj.c:    if ( ch->in_room->vnum != ch->pcdata->debt->vnum 
act_obj.c:      && get_room_index( ch->pcdata->debt->vnum ) != NULL )
act_obj.c:	value = ch->pcdata->debt->amount;
act_obj.c:    if ( value > ch->pcdata->debt->amount )
act_obj.c:	value = ch->pcdata->debt->amount;
act_obj.c:    if ( value > ch->gold[ ch->pcdata->debt->type ] )
act_obj.c:	sprintf( buf, "You do not have %ld %s.\n\r", value, coin_name[ ch->pcdata->debt->type ]  );
act_obj.c:    ch->gold[ ch->pcdata->debt->type ] -= value;
act_obj.c:    ch->pcdata->debt->amount -= value;
act_obj.c:    if ( ch->pcdata->debt->amount <= 0 )
act_obj.c:	free_debt_data( ch->pcdata->debt);
act_obj.c:	ch->pcdata->debt = NULL;
act_obj.c:	coin_name[ ch->pcdata->debt->type ],
act_obj.c:	ch->pcdata->debt->amount,
act_obj.c:	coin_name[ ch->pcdata->debt->type ]);
act_obj.c:    for ( tame_food = ch->carrying; tame_food; tame_food = tame_food->next_content )
act_obj.c:	    || ( ch->level + amount / 10 ) < victim->level
act_obj.c:	|| ( ch->level + amount / 10 ) < victim->level
act_obj.c:	|| saves_spell( ch->level , victim ) 
act_obj.c:    af.duration  = number_fuzzy( ch->level / 4 + amount / 3 );
act_obj.c:    	ch->mount = victim;
act_obj.c:	    obj_to_room( obj, ch->in_room );
act_obj.c:	    obj = get_obj_list( ch, arg1, ch->in_room->contents );
act_obj.c:	    for ( obj = ch->in_room->contents; obj != NULL; obj = obj_next )
act_obj.c:	for ( obj = ch->carrying; obj != NULL; obj = obj_next )
act_obj.c:    for ( obj = ch->in_room->contents ; obj != NULL ; obj = obj->next_content ) value++;
act_obj.c:	    coin_type = race_table[ ch->race ][ ch->sex ].world; 
act_obj.c:	if ( ch->gold[ coin_type ]< amount )
act_obj.c:	ch->gold[ coin_type ] -= amount;
act_obj.c:	for ( obj = ch->in_room->contents; obj != NULL; obj = obj_next )
act_obj.c:	obj_to_room( create_money( amount, coin_type ), ch->in_room );
act_obj.c:	obj_to_room( obj, ch->in_room );
act_obj.c:	trig = do_trigger( ch->in_room, ch, obj, NULL, TRIG_DROP, TRIG_TYPE_ROOM);
act_obj.c:	for ( obj = ch->carrying; obj != NULL; obj = obj_next )
act_obj.c:		obj_to_room( obj, ch->in_room );
act_obj.c:		trig = do_trigger( ch->in_room, ch, obj, NULL, TRIG_DROP, TRIG_TYPE_ROOM);
act_obj.c:	    coin_type = race_table[ ch->race ][ ch->sex ].world; 
act_obj.c:	if ( ch->gold[ coin_type ] < amount )
act_obj.c:	ch->gold[ coin_type ]     -= amount;
act_obj.c:    	trig = do_trigger( ch->in_room, ch, NULL, NULL, TRIG_GIVE, TRIG_TYPE_ROOM);
act_obj.c:    trig = do_trigger( ch->in_room, ch, obj, NULL, TRIG_GIVE, TRIG_TYPE_ROOM);
act_obj.c:    if ( obj->owner[0] == '\0' || is_name( ch->name, obj->owner ) )
act_obj.c:    for ( fountain = ch->in_room->contents; fountain != NULL;
act_obj.c:	for ( obj = ch->in_room->contents; obj; obj = obj->next_content )
act_obj.c:    if ( !IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK] > 10 )
act_obj.c:	if ( !IS_NPC(ch) && ch->pcdata->condition[COND_THIRST] >= race_table[ ch->race ][ ch->sex ].max_condition[COND_THIRST] )
act_obj.c:	    amount = race_table[ ch->race ][ ch->sex ].max_condition[COND_THIRST] - ch->pcdata->condition[COND_THIRST];
act_obj.c:	if ( !IS_NPC(ch) && ch->pcdata->condition[COND_DRUNK]  == race_table[ ch->race ][ ch->sex ].max_condition[COND_DRUNK] )
act_obj.c:	if ( !IS_NPC(ch) && ch->pcdata->condition[COND_FULL] >= race_table[ ch->race ][ ch->sex ].max_condition[COND_FULL] )
act_obj.c:	    condition = ch->pcdata->condition[COND_FULL];
act_obj.c:	    amount = UMIN( obj->edible_data->amount, race_table[ ch->race ][ ch->sex ].max_condition[COND_FULL] - condition );
act_obj.c:	    if ( condition == 0 && ch->pcdata->condition[COND_FULL] > 0 )
act_obj.c:	    else if ( ch->pcdata->condition[COND_FULL] == race_table[ ch->race ][ ch->sex ].max_condition[COND_FULL] )
act_obj.c:    if ( obj->wear_data->size < ch->size && !IS_IMMORTAL(ch) )
act_obj.c:    if ( obj->wear_data->size > ch->size && !IS_IMMORTAL(ch) ) 
act_obj.c:    if ( ( IS_SET( obj->extra_flags, ITEM_BARDING ) && !IS_SET( ch->act, ACT_MOUNT ) )
act_obj.c:      || ( !IS_SET( obj->extra_flags, ITEM_BARDING ) && IS_SET( ch->act, ACT_MOUNT ) ) )
act_obj.c:	if ( IS_SET( ch->guilds, TATH ) || IS_SET( ch->guilds, MAR_TUUR )
act_obj.c:	|| IS_SET( ch->guilds, CLANNGUARD ) )
act_obj.c:	if ( IS_SET( ch->guilds, TATH ) || IS_SET( ch->guilds, MAR_TUUR )
act_obj.c:	|| IS_SET( ch->guilds, CLANNGUARD ) || IS_SET( ch->guilds, MAJHERE ) )
act_obj.c:	if ( !IS_SET( obj->extra_flags, ITEM_BUCKLER ) && ( IS_SET( ch->guilds, TATH ) || IS_SET( ch->guilds, MAR_TUUR )
act_obj.c:	|| IS_SET( ch->guilds, CLANNGUARD ) ) )
act_obj.c:	else if ( IS_SET( ch->guilds, MAJHERE ) )
act_obj.c:	if ( ch->hands_free == 0 && !IS_SET( obj->extra_flags, ITEM_BUCKLER ) )
act_obj.c:	        ch->hands_free++;
act_obj.c:	if ( ( IS_SET( ch->guilds, CLANNGUARD ) || IS_SET( ch->guilds, MAR_TUUR )
act_obj.c:	|| IS_SET( ch->guilds, TATH ) ) || ( IS_SET( ch->guilds, MAJHERE ) 
act_obj.c:	    if ( ch->hands_free < 2 )
act_obj.c:	    if ( ch->hands_free == 0 )
act_obj.c:	    else if ( ch->hands_free == 1 )
act_obj.c:	        if ( ch->hands_free == 0 )
act_obj.c:	   	        if ( ch->hands_free == 0 )
act_obj.c:	     	            if ( ch->hands_free == 0 )
act_obj.c:	   	        if ( ch->hands_free == 0 )
act_obj.c:	if ( ch->hands_free == 0 && !IS_SET( obj->extra_flags, ITEM_BUCKLER ) )
act_obj.c:	        ch->hands_free++;
act_obj.c:	for ( obj = ch->carrying; obj != NULL; obj = obj_next )
act_obj.c:    if ( arg[0] == '\0' || !str_cmp( arg, ch->name ) )
act_obj.c:	for ( obj = ch->in_room->contents ; obj != NULL ; obj = obj_next )
act_obj.c:	for ( obj = ch->in_room->contents ; obj != NULL ; obj = obj_next )
act_obj.c:    for ( obj = ch->in_room->contents ; obj != NULL && !is_name( arg, obj->name ) ; obj = obj->next_content );
act_obj.c:    coin_type = race_table[ ch->race ][ ch->sex ].world;
act_obj.c:    ch->gold[ coin_type ] += gold;
act_obj.c:    if (IS_SET(ch->plr,PLR_AUTOSPLIT) )
act_obj.c:	for (gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
act_obj.c:	else for ( vch = ch->in_room->people; vch; vch = vch_next )
act_obj.c:	    vch_next	= vch->next_in_room;
act_obj.c:    if ( arg[0] == '\0' && ch->fighting == NULL )
act_obj.c:	if ( ch->fighting != NULL )
act_obj.c:	    victim = ch->fighting;
act_obj.c:    if ( ch->level + 5 < victim->level
act_obj.c:	   sprintf( buf, "%s is a lousy thief!", ch->name );
act_obj.c:		    ch->name,(ch->sex == SEX_FEMALE) ? "her" : "his");
act_obj.c:	    sprintf( buf,"%s tried to rob me!",ch->name );
act_obj.c:	    sprintf(buf,"Keep your hands out of there, %s!",ch->name);
act_obj.c:		if ( !IS_SET(ch->plr, PLR_THIEF) )
act_obj.c:		    SET_BIT(ch->plr, PLR_THIEF);
act_obj.c:	ch->gold[ coin_type ]     += amount;
act_obj.c:    if ( ch->carry_number >= can_carry_n( ch ) )
act_obj.c:    if ( ch->carry_weight + get_obj_weight( obj ) > can_carry_w( ch ) )
act_obj.c:    for ( keeper = ch->in_room->people; keeper; keeper = keeper->next_in_room )
act_obj.c:    if ( !IS_NPC(ch) && IS_SET(ch->plr, PLR_THIEF) )
act_obj.c:	sprintf( buf, "%s the THIEF is over here!\n\r", ch->name );
act_obj.c:    if ( race_table[ ch->race ][ ch->sex ].world != race_table[ keeper->race ][ keeper->sex ].world )
act_obj.c:    if ( cost > get_money_total( ch, ch->in_room->area->world ) )
act_obj.c:    get_char_money( ch, cost, ch->in_room->area->world );
act_obj.c:    	if ( cost > get_money_total( ch, ch->in_room->area->world ) )
act_obj.c:    	get_char_money( ch, cost, ch->in_room->area->world );
act_obj.c:    if ( cost > get_money_total( ch, ch->in_room->area->world ) )
act_obj.c:    	get_char_money( ch, cost, ch->in_room->area->world );
act_obj.c:    	get_char_money( ch, cost, ch->in_room->area->world );
act_obj.c:	        ch->reply = keeper;
act_obj.c:		ch->reply = keeper;
act_obj.c:		&&  keeper->pIndexData->pShop->owner == ch->name )
act_obj.c:	         ch->reply = keeper;
act_obj.c:  	     if ( ch->carry_number + number > can_carry_n( ch ) )
act_obj.c:	     if ( ch->carry_weight + get_obj_weight( obj ) * number > can_carry_w( ch ) && (ch->home && get_room_index(ch->home) == NULL ) )
act_obj.c:	     if ( ch->carry_weight + get_obj_weight( obj ) > can_carry_w( ch ) && (ch->home && get_room_index(ch->home) != NULL ) )
act_obj.c:	         obj_to_room(obj, get_room_index(ch->home) );
act_obj.c:	         strncpy(obj->owner , ch->name,30 );
act_obj.c:	     if ( ch->carry_weight + get_obj_weight( obj ) > can_carry_w( ch ) && (ch->home && get_room_index(ch->home) != NULL ) )
act_obj.c:	         obj_to_room(obj, get_room_index(ch->home) );
act_obj.c:	         strncpy(obj->owner , ch->name,30 );
act_obj.c:    if ( IS_SET(ch->in_room->room_flags, ROOM_PET_SHOP)
act_obj.c:      ||  IS_SET(ch->in_room->room_flags, ROOM_MOUNT_SHOP) )
act_obj.c:	pRoomIndexNext = get_room_index( ch->in_room->vnum + 1 );
act_obj.c:	    bug( "Do_buy: bad pet shop at vnum %d.", ch->in_room->vnum );
act_obj.c:	in_room     = ch->in_room;
act_obj.c:	ch->in_room = pRoomIndexNext;
act_obj.c:	    for ( pet = ch->in_room->people; pet && anum != value ; pet = pet->next_in_room )
act_obj.c:	ch->in_room = in_room;
act_obj.c:	if ( ch->pet != NULL && IS_SET(ch->in_room->room_flags,ROOM_PET_SHOP) && !fGuard )
act_obj.c:	if ( ch->mount != NULL && IS_SET(ch->in_room->room_flags,ROOM_MOUNT_SHOP))
act_obj.c: 	if ( IS_SET( ch->in_room->room_flags,ROOM_PET_SHOP) )
act_obj.c:	coin_type = ch->in_room->area->world;
act_obj.c:	if ( fGuard && ch->home < 2 )
act_obj.c:	if ( ch->level < pet->level && !fGuard )
act_obj.c:	    pet->description, ch->name );
act_obj.c:	    pRoom = get_room_index( ch->home );
act_obj.c:		char_to_room( pet, ch->in_room );
act_obj.c:        if ( IS_SET(ch->in_room->room_flags,ROOM_PET_SHOP) )
act_obj.c: 	    SET_BIT(ch->plr, PLR_BOUGHT_PET);
act_obj.c:        if ( IS_SET(ch->in_room->room_flags,ROOM_MOUNT_SHOP) )
act_obj.c:	char_to_room( pet, ch->in_room );
act_obj.c:	if ( IS_SET(ch->in_room->room_flags,ROOM_PET_SHOP) )
act_obj.c: 	    ch->pet = pet;
act_obj.c:	    ch->mount = pet;
act_obj.c:	if ( ch->race != keeper->race )
act_obj.c:	    if ( race_table[ ch->race ][ ch->sex ].world != race_table[ keeper->race ][ keeper->sex ].world )
act_obj.c:	    ch->reply = keeper;
act_obj.c:	    ch->reply = keeper;
act_obj.c:	for (obj=ch->carrying;  obj != NULL; obj = obj_next )
act_obj.c:	if ( ( obj = get_obj_carry( ch, arg ) ) == NULL && ( obj = get_obj_list( ch, arg, ch->in_room->contents ) ) == NULL )
act_obj.c:    for (objcarried=ch->carrying; objcarried!=NULL;objcarried=nextobj)
act_obj.c:	for ( objcarried = ch->in_room->contents ; objcarried != NULL; objcarried = nextobj )
act_obj.c:	for ( obj = ch->carrying; obj != NULL; obj = obj_next )
act_obj.c:	ch->in_room->light_adjustment = get_light_adjustment ( ch, ch->in_room );
act_obj.c:    for ( fuel = ch->carrying; fuel != NULL;
act_obj.c:    if ( IS_SET(ch->in_room->room_flags, ROOM_PET_SHOP) 
act_obj.c:      || IS_SET(ch->in_room->room_flags, ROOM_MOUNT_SHOP) )
act_obj.c:	pRoomIndexNext = get_room_index( ch->in_room->vnum + 1 );
act_obj.c:	    bug( "Do_list: bad pet shop at vnum %d.", ch->in_room->vnum );
act_obj.c:		    sprintf(buf,"Pets for sale:  (values in %s)\n\r", coin_names[ ch->in_room->area->world ]);
act_obj.c:		    sprintf(buf,"Mounts for sale:  (values in %s)\n\r", coin_names[ ch->in_room->area->world ]);
act_obj.c:	for ( obj = ch->carrying ; obj != NULL ; obj = obj_next )
act_obj.c:	ch->reply = keeper;
act_obj.c:		ch->reply = keeper;
act_obj.c:    &&  keeper->pIndexData->pShop->owner == ch->name )
act_obj.c:	ch->reply = keeper;
act_obj.c:    if ( ch->race != keeper->race )
act_obj.c:    	if ( race_table[ ch->race ][ ch->sex ].world != race_table[ keeper->race ][ keeper->sex ].world )
act_obj.c:        ch->reply = keeper;
act_obj.c:    ch->reply = keeper;
act_obj.c:    for ( herb = ch->carrying; herb != NULL && herb->pIndexData->vnum != OBJ_VNUM_MEDICAL_HERB ; herb = herb->next_content );   
act_obj.c:    victim->hit += ( dice(ch->level, 2 ) * 2 / 7 ) + ( get_skill( ch, gsn_first_aid ) * 2 / 10);
act_obj.c:	if ( d->character->in_room->area == ch->in_room->area )
act_obj.c:pArea = ch->in_room->area;
act_obj.c:	sprintf(buf,"%s: Congradulations!  Best wishes and all my love!\n\r",ch->name);
act_obj.c:obj = get_obj_list( ch, arg, ch->in_room->contents );
act_obj.c:sprintf(buf3,"%s%-12s-%s\n\r",ed->description,ch->name,argument);
act_special.c:   if( ch->in_room->area->world != race_table[ ch->race ][ ch->sex ].world )
act_special.c:   if (ch->bank == 1) 
act_special.c:        { sprintf (buf,"Our records show you have %ld coins in our vault\n\r.",ch->bank);
act_special.c:   if( ch->in_room->area->world != race_table[ ch->race ][ ch->sex ].world )
act_special.c:       coin_type = race_table[ ch->race ][ ch->sex ].world;
act_special.c:   if (coins > ch->gold[ coin_type ]) 
act_special.c:         ch->gold[ coin_type ] -= coins;
act_special.c:         ch->bank += bank_exchange_rate[ coin_type ][ race_table[ ch->race ][ ch->sex ].world ] * coins / 100;
act_special.c:         sprintf (buf,"%s deposited %d coins of type %d.",ch->name,coins,coin_type);
act_special.c:      coin_type = race_table[ ch->race ][ ch->sex ].world; 
act_special.c:   if (coins > ch->gold[ coin_type ]) {send_to_char ("You can't exchange more then you have!\n\r",ch); return;}; 
act_special.c:         ch->gold[ coin_type ] -= coins;
act_special.c:         ch->gold[ ch->in_room->area->world ] += bank_exchange_rate[ coin_type ] [ ch->in_room->area->world ] * coins / 100;
act_special.c:	 sprintf( buf,"You exchanges your %d %s for %d %s", coins, coin_names[ coin_type ], bank_exchange_rate[ coin_type ] [ ch->in_room->area->world ] * coins / 100, coin_names[ ch->in_room->area->world ]);
act_special.c:   if( ch->in_room->area->world != race_table[ ch->race ][ ch->sex ].world )
act_special.c:  coin_type = race_table[ ch->race ][ ch->sex ].world; 
act_special.c:  if (coins > ch->bank)
act_special.c:  ch->gold[ coin_type ] += coins;
act_special.c:  ch->bank -= coins;
act_special.c:   if( ch->in_room->area->world != race_table[ ch->race ][ ch->sex ].world )
act_special.c:  if (ch->bank < coins)
act_special.c:  ch->bank -= coins;
act_special.c:  victim->bank += bank_exchange_rate[ race_table[ ch->race ][ ch->sex ].world ] [ race_table[ victim->race ][ victim->sex ].world ] * coins / 100; 
act_special.c:  sprintf(buf,"\a[%d] coins have been transferred form the account of [%s] to the\n\raccount of [%s]",coins,ch->name,victim->name);
act_special.c:  type = race_table[ ch->race ][ ch->sex ].world;
act_special.c:                 ch->practice += 5;
act_special.c:                 ch->gold[ type ]+=10000;
act_wiz.c:    ch->room_template = atoi( argument );
act_wiz.c:    event_reset(flag, ch->in_room->area);
act_wiz.c:	if ( ch->pcdata->learned[ gsn_weapon_power[i][0] ] != 0 )
act_wiz.c:    ch->pcdata->learned[ gsn_weapon_power[ type ][ 0 ] ] = 40;
act_wiz.c:	    pArea = ch->in_room->area;
act_wiz.c:	    pArea = ch->in_room->area;
act_wiz.c:	    pArea = ch->in_room->area;
act_wiz.c:	    pArea = ch->in_room->area;
act_wiz.c:	    pArea = ch->in_room->area;
act_wiz.c:	    pArea = ch->in_room->area;
act_wiz.c:    sprintf( buf, "%s has married you to %s.\n\r", ch->name, ch1->name );
act_wiz.c:    sprintf( buf, "%s has married you to %s.\n\r", ch->name, ch2->name );
act_wiz.c:    sprintf( buf, "%s has married %s to %s.\n\r", ch->name, ch1->name, ch2->name );
act_wiz.c:    if ( value == 0 ) value = ch->level;  
act_wiz.c:    ch->pcdata->condition[COND_THIRST] = 48;
act_wiz.c:    ch->pcdata->condition[COND_FULL] = 48;
act_wiz.c:    ch->pcdata->condition[COND_DRUNK] = 0;
act_wiz.c:    ch->level		= value;
act_wiz.c:    ch->hit		= ch->level * 10 + ch->level *10 ;   
act_wiz.c:    ch->max_hit		= ch->hit;
act_wiz.c:    ch->pcdata->perm_hit = ch->max_hit;
act_wiz.c:    ch->move		= ch->level *15 + 10;
act_wiz.c:    ch->max_move	= ch->level *15 + 10;
act_wiz.c:    ch->pcdata->perm_move = ch->max_move;
act_wiz.c:    ch->exp = exp_table[ ch->level ].exp_at_level;
act_wiz.c:    ch->pkills = 0;
act_wiz.c:    ch->died = 0;
act_wiz.c:    ch->kills = 0;
act_wiz.c:	ch->perm_stat[i] = race_table[ch->race][ch->sex].stats[i];
act_wiz.c:	ch->mod_stat[i]=0;
act_wiz.c:    for (x = 0; x < ch->level; x++)
act_wiz.c:	if ( ch->perm_stat[i] < 25 )
act_wiz.c:	ch->perm_stat[i] += 1;
act_wiz.c:    ch->affected_by = race_table[ch->race][ch->sex].aff;
act_wiz.c:    ch->affected_by_2 = race_table[ch->race][ch->sex].aff2;
act_wiz.c:    ch->pcdata->perm_aff = race_table[ch->race][ch->sex].aff;
act_wiz.c:    ch->pcdata->perm_aff_2 = race_table[ch->race][ch->sex].aff2;
act_wiz.c:    ch->imm_flags	= race_table[ch->race][ch->sex].imm;
act_wiz.c:    ch->res_flags	= race_table[ch->race][ch->sex].res;
act_wiz.c:    ch->vuln_flags	= race_table[ch->race][ch->sex].vuln;
act_wiz.c:    ch->form	= race_table[ch->race][ch->sex].form;
act_wiz.c:    ch->size = race_table[ch->race][ch->sex].size;
act_wiz.c:    ch->height = get_height_size( ch->size );
act_wiz.c:    ch->weight = get_weight_size( ch->size );
act_wiz.c:    strncpy( ch->pcdata->prompt, "`yHp %c`y/`w%H `yMv %d`y/`w%V`y-> ", 160 );
act_wiz.c:	ch->pcdata->learned[sn] = 0;
act_wiz.c:	if ( ch->level >= LEVEL_IMMORTAL )
act_wiz.c:	    ch->pcdata->learned[ sn ] = 100;
act_wiz.c:	    if ( race_table[ ch->race ][ ch->sex ].skill_level[ sn ] < ch->level
act_wiz.c:	      && race_table[ ch->race ][ ch->sex ].rating[ sn ] > 0 )
act_wiz.c:	    ch->pcdata->learned[ sn ] = URANGE( 0, ( ( ch->level - race_table[ ch->race ][ ch->sex ].skill_level[ sn ] + 1 ) * 35 ) / race_table[ ch->race ][ ch->sex ].rating[ sn ], 100 );
act_wiz.c:	    ch->pcdata->learned[ sn ] = 0;
act_wiz.c:        ch->max_mana[i] = race_table[ ch->race ][ ch->sex ].mana_die[ i ] * race_table[ ch->race ][ ch->sex ].mana_dice[ i ] + race_table[ ch->race ][ ch->sex ].mana_bonus[ i ];
act_wiz.c:	if ( ch->level > 1 )
act_wiz.c:	    ch->max_mana[i] *= 7*ch->level;
act_wiz.c:	    ch->max_mana[i] *= 10*ch->level;
act_wiz.c:        ch->mana[i]	= ch->max_mana[ i ];
act_wiz.c:	ch->pcdata->perm_mana[i] = ch->max_mana[i];
act_wiz.c:	if ( !str_cmp( list->host, ch->desc->host ) )
act_wiz.c:    strncpy( list->host, ch->desc->host, 15 );
act_wiz.c:	sprintf( buf, "You inherited %d %s from your parents to help you in your adventures.\n\r", 5000, coin_names[ race_table[ ch->race ][ ch->sex ].world ] );
act_wiz.c:	ch->gold[ race_table[ ch->race ][ ch->sex ].world ] += 5000;
act_wiz.c:	    strcpy( name, ch->name );
act_wiz.c:	value = ( ch->sex == SEX_FEMALE ? 18101 : ( number_range( 0, 1 ) ? 18096 : 18097 ) );
act_wiz.c:	    strcpy( name, ch->name );
act_wiz.c:	    if ( ch->sex == SEX_FEMALE )
act_wiz.c:	    if ( race_table[ ch->race ][ ch->sex ].skill_level[ sn ] < 49
act_wiz.c:	      && race_table[ ch->race ][ ch->sex ].rating[ sn ] > 0
act_wiz.c:	      && ch->pcdata->learned[ sn ] < 25 )
act_wiz.c:	   if ( race_table[ ch->race ][ ch->sex ].skill_level[ sn ] < 49 
act_wiz.c:	     && race_table[ ch->race ][ ch->sex ].rating[ sn ] > 0
act_wiz.c:	     && ch->pcdata->learned[ sn ] < 25 )
act_wiz.c:	ch->pcdata->learned[ sn ] = number_range( 25, race_table[ ch->race ][ ch->sex ].adept[ sn ] );
act_wiz.c:	    char_to_room( mob, ch->in_room );
act_wiz.c:	    ch->mount = mob;
act_wiz.c:	    ch->pcdata->learned[ gsn_riding ] = 85;
act_wiz.c:	    strcpy( name, ch->name );
act_wiz.c:	    ch->max_hit += i;
act_wiz.c:	    ch->hit = ch->max_hit;
act_wiz.c:	    ch->pcdata->perm_hit = ch->max_hit;
act_wiz.c:	    ch->max_mana[ type ] += i;
act_wiz.c:	    ch->mana[ type ] = ch->max_mana[ type ];
act_wiz.c:	    ch->pcdata->perm_mana[ type ] = ch->max_mana[ type ];
act_wiz.c:	    ch->max_move += 3 * i;
act_wiz.c:	    ch->move = ch->max_move;
act_wiz.c:	    ch->pcdata->perm_move = ch->max_move;
act_wiz.c:	    ch->practice += number_range( 4, 8 );
act_wiz.c:	    if ( ch->perm_stat[ i ] < race_table[ ch->race ][ ch->sex ].max_stats[ i ] )
act_wiz.c:	while ( ch->perm_stat[ i = number_range( 0, MAX_STATS - 1 ) ] >= race_table[ ch->race ][ ch->sex ].max_stats[ i ] );
act_wiz.c:	ch->perm_stat[ i ] = UMIN( ch->perm_stat[ i ] + number_range( 1, 2 ), race_table[ ch->race ][ ch->sex ].max_stats[ i ] );
act_wiz.c:    if (ch->outfit_timer > 0 )
act_wiz.c:    ch->outfit_timer = 2;
act_wiz.c:    if (ch->level > 5 || IS_NPC(ch))
act_wiz.c:      && !obj_vnum_in_room( ch->in_room, OBJ_VNUM_BEGIN_LIGHT ) )
act_wiz.c:      && !has_obj_vnum( ch, race_table[ch->race][ch->sex].weapon )
act_wiz.c:      && !obj_vnum_in_room( ch->in_room, race_table[ch->race][ch->sex].weapon ) )
act_wiz.c:        obj = create_object( get_obj_index(race_table[ch->race][ch->sex].weapon));
act_wiz.c:      && !obj_vnum_in_room( ch->in_room, OBJ_VNUM_BEGIN_LIGHTER ) )
act_wiz.c:    ch->hands_free = 0;
act_wiz.c:    strncpy ( clan->rank9, "Arch-Bishop", 30);
act_wiz.c:	if ( IS_SET( clan->clan_info, CLAN_UNLISTED ) && !IS_IMMORTAL( ch ) && ch->pcdata->pcclan->clan != clan )
act_wiz.c:    if (ch->pcdata->pcclan != NULL)
act_wiz.c:        clan = ch->pcdata->pcclan->clan;
act_wiz.c:	if ( ch->pcdata->pcclan == NULL )
act_wiz.c:	if ( !strstr(ch->name, ch->pcdata->pcclan->clan->leader->name))
act_wiz.c:	if ( ch->in_room != victim->in_room )
act_wiz.c:	clan = ch->pcdata->pcclan->clan;
act_wiz.c:	    sprintf(buf,"Your poofin is %s\n\r",ch->pcdata->bamfin);
act_wiz.c:	if ( strstr(argument,ch->name) == NULL)
act_wiz.c:	strncpy( ch->pcdata->bamfin, argument, 160 );
act_wiz.c:        sprintf(buf,"Your poofin is now %s\n\r",ch->pcdata->bamfin);
act_wiz.c:            sprintf(buf,"Your poofout is %s\n\r",ch->pcdata->bamfout);
act_wiz.c:        if ( strstr(argument,ch->name) == NULL)
act_wiz.c:        strncpy( ch->pcdata->bamfout, argument, 160 );
act_wiz.c:        sprintf(buf,"Your poofout is now %s\n\r",ch->pcdata->bamfout);
act_wiz.c:    for ( af = ch->affected ; af != NULL ; af = af_next )
act_wiz.c: 	coin_type = race_table[ ch->race ][ ch->sex ].world; 
act_wiz.c:      if ( !ch->pcdata )
act_wiz.c:         if ( ch->pcdata->pcclan == NULL )
act_wiz.c:	   clan = ch->pcdata->pcclan->clan;
act_wiz.c:   if ( ch->pcdata->pcclan != NULL )
act_wiz.c:	if ( (  to_room = get_room_index( ch->pcdata->pcclan->clan->donate_room ) ) == NULL )
act_wiz.c:	  if ( ( to_room = get_room_index( race_table[ ch->race ][ ch->sex ].donate ) ) == NULL )
act_wiz.c:   if ( ( to_room = get_room_index( race_table[ ch->race ][ ch->sex ].donate ) ) == NULL )
act_wiz.c:   for ( obj2 = ch->in_room->contents ; obj2 != NULL ; obj2 = obj2->next_content ) count++;
act_wiz.c:	  && d->character->in_room->area->world == ch->in_room->area->world )
act_wiz.c:	  && d->character->in_room->area == ch->in_room->area )
act_wiz.c:	&&   d->character->in_room == ch->in_room )
act_wiz.c:    if (victim->level >= ch->level && !IS_OPTIVISION(ch))
act_wiz.c:    if ( obj->wear_data != NULL && location == ch->in_room )
act_wiz.c:	location = ch->in_room;
act_wiz.c:    original = ch->in_room;
act_wiz.c:    for ( wch = char_list; wch != NULL; wch = wch->next )
act_wiz.c:    if ( ch->fighting != NULL )
act_wiz.c:    if ( ch->inside_area != NULL ) /* don't carry the moveable area data */
act_wiz.c:	free_inside_area_data(ch->inside_area);
act_wiz.c:	ch->inside_area = NULL;
act_wiz.c:    for (rch = ch->in_room->people; rch != NULL; rch = rch->next_in_room)
act_wiz.c:	    if (ch->pcdata != NULL && ch->pcdata->bamfout[0] != '\0')
act_wiz.c:		act("$t",ch,ch->pcdata->bamfout,rch,TO_VICT);
act_wiz.c:    for (rch = ch->in_room->people; rch != NULL; rch = rch->next_in_room)
act_wiz.c:            if (ch->pcdata != NULL && ch->pcdata->bamfin[0] != '\0' )
act_wiz.c:                act("$t",ch,ch->pcdata->bamfin,rch,TO_VICT);
act_wiz.c:    if ( ch->mount != NULL && IS_SET(ch->mount->affected_by,AFF_MOUNTED) )
act_wiz.c:        char_from_room( ch->mount );
act_wiz.c:        char_to_room( ch->mount, location );
act_wiz.c:    location = ( arg[0] == '\0' ) ? ch->in_room : find_location( ch, arg );
act_wiz.c:    if ( ch->in_room != location && room_is_private( location ) && 
act_wiz.c:    for ( rch = location->people; rch; rch = rch->next_in_room )
act_wiz.c:	    one_argument( rch->name, buf );
act_wiz.c:    pArea = ch->in_room->area;
act_wiz.c:	if ( pArea->world != ch->in_room->area->world ) 
act_wiz.c:	fArean = ch->in_room->area->areanum;
act_wiz.c:    AREA_DATA * pArea = ch->in_room->area;
act_wiz.c:	fArean = ch->in_room->area->areanum;
act_wiz.c:    for ( vch = char_list; vch != NULL; vch = vch->next)
act_wiz.c:		if (vch->logon_data != NULL)
act_wiz.c:		    strncpy( vch->logon_data->exit, "Reboot", 30 );
act_wiz.c:    if (!IS_SET(ch->plr,PLR_WIZINVIS))
act_wiz.c:    	sprintf( buf, "Shutdown by %s.", ch->name );
act_wiz.c:    for ( vch = char_list; vch != NULL; vch = vch->next)
act_wiz.c:	if (vch->logon_data != NULL)
act_wiz.c:	    strncpy( vch->logon_data->exit, "Shutdown", 30 );
act_wiz.c:    for ( snoop_list = ch->desc->snoop_by; snoop_list != NULL; snoop_list = snoop_list->next )
act_wiz.c:	    while( d->snoop_by != NULL && d->snoop_by->desc == ch->desc )
act_wiz.c:		while( snoop_list_next != NULL && snoop_list_next->desc == ch->desc )
act_wiz.c:        sprintf(buf, "%s cancells snoop ",ch->name);
act_wiz.c:    if ( ch->desc != NULL && check_snoop_by( ch, victim ) )
act_wiz.c:    if ( victim->desc->snoop_by != NULL && victim->desc->snoop_by->desc == ch->desc )
act_wiz.c:	sprintf( buf, "%s stops snooping %s", ch->name, victim->name );
act_wiz.c:	if ( snoop_list_next != NULL && snoop_list_next->desc == ch->desc )
act_wiz.c:	    sprintf( buf, "%s stops snooping %s", ch->name, victim->name );
act_wiz.c:    snoop_list->desc = ch->desc;
act_wiz.c:    sprintf(buf, "%s snoops %s",ch->name,victim->name);
act_wiz.c:    if ( ch->desc == NULL )
act_wiz.c:    if ( ch->desc->original != NULL )
act_wiz.c:    ch->desc->character = victim;
act_wiz.c:    ch->desc->original  = ch;
act_wiz.c:    victim->desc        = ch->desc;
act_wiz.c:    ch->desc            = NULL;
act_wiz.c:    victim->comm = ch->comm;
act_wiz.c:    victim->lines = ch->lines;
act_wiz.c:    if ( ch->desc == NULL )
act_wiz.c:    if ( ch->desc->original == NULL )
act_wiz.c:    ch->desc->character       = ch->desc->original;
act_wiz.c:    ch->desc->original        = NULL;
act_wiz.c:    ch->desc->character->desc = ch->desc; 
act_wiz.c:    ch->desc                  = NULL;
act_wiz.c:	    obj_to_room(clone,ch->in_room);
act_wiz.c:	char_to_room(clone,ch->in_room);
act_wiz.c:    char_to_room( victim, ch->in_room );
act_wiz.c:    level = ch->level;
act_wiz.c:	strncpy(obj->owner ,ch->name,30);
act_wiz.c:	obj_to_room( obj, ch->in_room );
act_wiz.c:    pArea = ch->in_room->area;
act_wiz.c:	for ( victim = ch->in_room->people; victim != NULL; victim = vnext )
act_wiz.c:	for ( obj = ch->in_room->contents; obj != NULL; obj = obj_next )
act_wiz.c:	  sprintf(buf,"%s tried to purge you!\n\r",ch->name);
act_wiz.c:	    victim->max_mana[ i ] = race_table[ ch->race ][ ch->sex ].mana_die[ i ] * race_table[ ch->race ][ ch->sex ].mana_dice[ i ] + race_table[ ch->race ][ ch->sex ].mana_bonus[ i ];
act_wiz.c:        for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
act_wiz.c:	    for ( af = vch->affected; af != NULL; af = af_next )
act_wiz.c:            vch->affected_by = vch->pcdata->perm_aff; 
act_wiz.c:            vch->affected_by_2 = vch->pcdata->perm_aff_2; 
act_wiz.c:            vch->hit 	= vch->max_hit;
act_wiz.c:                vch->mana[i]	= vch->max_mana[i];
act_wiz.c:            vch->move	= vch->max_move;
act_wiz.c:	sprintf(imp_buf, "%s restored all active players\n\r",ch->name);
act_wiz.c:	REMOVE_BIT(ch->comm, COMM_NO_REC_TELL);
act_wiz.c:	SET_BIT(ch->comm, COMM_NO_REC_TELL);
act_wiz.c:    for ( rch = ch->in_room->people; rch != NULL; rch = rch->next_in_room )
act_wiz.c:	if ( rch->fighting != NULL )
act_wiz.c:	if ( rch->dislikes[0] != '\0' )
act_wiz.c:	rch->dislikes[0] = '\0';
act_wiz.c:	if (IS_NPC(rch) && IS_SET(rch->act,ACT_AGGRESSIVE))
act_wiz.c:	    REMOVE_BIT(rch->act,ACT_AGGRESSIVE);
act_wiz.c:	if (!IS_SET(ch->cmd_groups, CMD_GROUP_ADMIN ) )
act_wiz.c:	if (!IS_SET(ch->cmd_groups, CMD_GROUP_ADMIN ) )
act_wiz.c:	if (!IS_SET(ch->cmd_groups, CMD_GROUP_ADMIN ) )
act_wiz.c:	    vch_next = vch->next;
act_wiz.c:		&& vch->prompt_num < 1 )
act_wiz.c:            vch_next = vch->next;
act_wiz.c:		&& vch->prompt_num < 1 )
act_wiz.c:            vch_next = vch->next;
act_wiz.c:		&& vch->prompt_num < 1 )
act_wiz.c:      if ( IS_SET(ch->plr, PLR_WIZINVIS) )
act_wiz.c:	  REMOVE_BIT(ch->plr, PLR_WIZINVIS);
act_wiz.c:	  ch->invis_level = 0;
act_wiz.c:	  ++ch->in_room->area->nplayer;
act_wiz.c:	      if (ch->logon_data != NULL)
act_wiz.c:		ch->logon_data->level = ch->level;
act_wiz.c:	  if ( !IS_SET( ch->plr, PLR_WIZINVIS ) )
act_wiz.c:	      --ch->in_room->area->nplayer;
act_wiz.c:	  SET_BIT(ch->plr, PLR_WIZINVIS);
act_wiz.c:	  ch->invis_level = ch->level;
act_wiz.c:	      if (ch->logon_data != NULL)
act_wiz.c:		ch->logon_data->level = ch->invis_level;
act_wiz.c:		    ch->reply = NULL;
act_wiz.c:		    if ( !IS_SET( ch->plr, PLR_WIZINVIS ) )
act_wiz.c:			--ch->in_room->area->nplayer;
act_wiz.c:		    SET_BIT(ch->plr, PLR_WIZINVIS);
act_wiz.c:		    ch->invis_level = level;
act_wiz.c:			if (ch->logon_data != NULL)
act_wiz.c:			    ch->logon_data->level = ch->invis_level;
act_wiz.c:		    ch->reply = NULL;
act_wiz.c:		    if ( !IS_SET( ch->plr, PLR_WIZINVIS ) )
act_wiz.c:			--ch->in_room->area->nplayer;
act_wiz.c:		    SET_BIT(ch->plr, PLR_WIZINVIS);
act_wiz.c:		    ch->invis_level = level;
act_wiz.c:		    ch->reply = NULL;
act_wiz.c:		    if ( !IS_SET( ch->plr, PLR_WIZINVIS ) )
act_wiz.c:			--ch->in_room->area->nplayer;
act_wiz.c:		    SET_BIT(ch->plr, PLR_WIZINVIS);
act_wiz.c:		    ch->invis_level = level;
act_wiz.c:    if ( !str_cmp( ch->name, capitalize( opti_wiz_list[ i ] ) ) )
act_wiz.c:    if ( IS_SET(ch->plr, PLR_WIZPASS) )
act_wiz.c:	REMOVE_BIT(ch->plr, PLR_WIZPASS);
act_wiz.c:	SET_BIT(ch->plr, PLR_WIZPASS);
act_wiz.c:    if ( IS_SET( ch->plr, PLR_HOLYLIGHT ) && IS_IMMORTAL( ch ) && !IS_OPTIVISION( ch ) )
act_wiz.c:    if ( IS_SET(ch->plr, PLR_HOLYLIGHT) )
act_wiz.c:	REMOVE_BIT(ch->plr, PLR_HOLYLIGHT);
act_wiz.c:	SET_BIT(ch->plr, PLR_HOLYLIGHT);
act_wiz.c:    AREA_DATA * pArea = ch->in_room->area;
act_wiz.c:    house_key->wear_data->size = ch->size;
act_wiz.c:    sprintf(buf,"%s's Apartment", ch->name );
act_wiz.c:	, ch->name 
act_wiz.c:    ch->home = vnum;    
act_wiz.c:    get_char_money( ch, COST_HOUSE, ch->in_room->area->world );
act_wiz.c:    int coin_type = ch->in_room->area->world;
act_wiz.c:    if ( ch->home != 0 )
act_wiz.c:	if ( ( pexit = ch->in_room->exit[ door ] ) != NULL
act_wiz.c:	  && pexit->u1.to_room->area == ch->in_room->area )
act_wiz.c:	    if ( ( pexit = ch->in_room->exit[ door ] ) != NULL
act_wiz.c:	      && pexit->u1.to_room->area != ch->in_room->area )
act_wiz.c:	if ( !make_first_floor( ch->in_room , floor_dir )
act_wiz.c:	  || ( pexit = ch->in_room->exit[ rev_dir[ floor_dir ] ] ) == NULL
act_wiz.c:	  && pexit->u1.to_room != ch->in_room )
act_wiz.c:    pArea = ch->in_room->area;
act_wiz.c:    if (ch->in_room->exit[direction] != NULL)
act_wiz.c:    ch->in_room->exit[direction] = pexit_here;
act_wiz.c:    pexit_there->u1.vnum = ch->in_room->vnum;
act_wiz.c:    pexit_there->u1.to_room = ch->in_room;
act_wiz.c:    ch->in_room->exit[ direction ] = pexit_here;
act_wiz.c:  victim->home = ch->in_room->vnum;
act_wiz.c:    strncpy( name, vch->name, 30 );
act_wiz.c:     virtual(ch, ch->in_room->area );
act_wiz.c:    pArea = ch->in_room->area; /* Current area of charactor */
act_wiz.c:	if (ch->prefix[0] == '\0')
act_wiz.c:	ch->prefix[0] = '\0';
act_wiz.c:    if ( ch->prefix[0] != '\0' )
act_wiz.c:    strncpy( ch->prefix, argument, 30 );
comm.c:	sprintf( log_buf, "Closing link to %s.", ch->name );
comm.c:	   if (ch->logon_data != NULL) /* for those that type the wrong passwd */
comm.c:	   if (!str_cmp(ch->logon_data->exit,"Menu-Quit") )
comm.c:	   	strncpy( ch->logon_data->exit, "Menu-Quit", 30 );
comm.c:	   	strncpy( ch->logon_data->exit, "Lost-link", 30 );
comm.c:	    ch->desc = NULL;
comm.c:	    ch->edit_flags = 0;
comm.c:	    ch->edit_buffer[0] = '\0';
comm.c:	    if (!check_reconnect( dclose, ch->name, FALSE ) )
comm.c:    if (ch->max_hit > 0)
comm.c:        percent = ch->hit * 100 / ch->max_hit;
comm.c:    if (ch->max_hit > 0)
comm.c:        percent = ch->hit * 100 / ch->max_hit;
comm.c:	    if (IS_SET(ch->plr, PLR_ANSI) )
comm.c:	    if (!IS_SET(ch->comm, COMM_COMPACT) && ch->prompt_num == 0 )
comm.c:	    if (ch->pcdata->prompt[0] != '\0' && ch->prompt_num==0 )
comm.c:	        promptlen=strlen(ch->pcdata->prompt);
comm.c:                promptlen=strlen(ch->pcdata->prompt);
comm.c:/* OLC */   	switch (ch->desc->connected)
comm.c:			    if ( ch->edit_buffer )
comm.c:				sprintf( buf, "REdit->%s",ch->edit_buffer );
comm.c:			    if ( ch->edit_buffer )
comm.c:				sprintf( buf, "OEdit->%s",ch->edit_buffer );
comm.c:			    if ( ch->edit_buffer )
comm.c:				sprintf( buf, "MEdit->%s",ch->edit_buffer );
comm.c:			    if ( ch->edit_buffer )
comm.c:				sprintf( buf, "GEdit->%s",ch->edit_buffer );
comm.c:                if (ch->pcdata->prompt[c1]!='%' )
comm.c:                buf[c2++]=ch->pcdata->prompt[c1];
comm.c:              	switch (ch->pcdata->prompt[c1])
comm.c:                           sprintf(buf2,"%ld",ch->in_room->vnum);
comm.c:                           sprintf(buf2,"%d",ch->in_room->area->areanum);
comm.c:		    case 'r':if (IS_IMMORTAL(ch)) strcat(buf,ch->in_room->name); break;
comm.c:		    case 'A':if (IS_IMMORTAL(ch)) strcat(buf,ch->in_room->area->filename); break;
comm.c:		    case 'h':sprintf(buf2,"%d",ch->hit); strcat(buf,buf2); break;
comm.c:                    case 'H':sprintf(buf2,"%d",ch->max_hit); strcat(buf,buf2); break;
comm.c:                    case 'f':sprintf(buf2,"%d",ch->mana[0]); strcat(buf,buf2); break;
comm.c:                    case 'F':sprintf(buf2,"%d",ch->max_mana[0]); strcat(buf,buf2); break;
comm.c:                    case 'i':sprintf(buf2,"%d",ch->mana[1]); strcat(buf,buf2); break;
comm.c:                    case 'I':sprintf(buf2,"%d",ch->max_mana[1]); strcat(buf,buf2); break;
comm.c:                    case 'e':sprintf(buf2,"%d",ch->mana[2]); strcat(buf,buf2); break;
comm.c:                    case 'E':sprintf(buf2,"%d",ch->max_mana[2]); strcat(buf,buf2); break;
comm.c:                    case 'w':sprintf(buf2,"%d",ch->mana[3]); strcat(buf,buf2); break;
comm.c:                    case 'W':sprintf(buf2,"%d",ch->max_mana[3]); strcat(buf,buf2); break;
comm.c:                    case 's':sprintf(buf2,"%d",ch->mana[4]); strcat(buf,buf2); break;
comm.c:                    case 'S':sprintf(buf2,"%d",ch->max_mana[4]); strcat(buf,buf2); break;
comm.c:                    case 'v':sprintf(buf2,"%d",ch->move); strcat(buf,buf2); break;
comm.c:                    case 'V':sprintf(buf2,"%d",ch->max_move); strcat(buf,buf2); break;
comm.c:               	    case 'c':	sprintf(buf2, "%s", figurestate( ( IS_AFFECTED( ch, AFF_BERSERK ) ? ch->max_hit : ch->hit ), ch->max_hit));
comm.c:				case 'd':	sprintf(buf2, "%s", figurestate(ch->move, ch->max_move));
comm.c:				case 'l':  	if ((tank=ch->fighting) != NULL) 
comm.c:				case 'b':	if ((tank=ch->fighting) != NULL)
comm.c:				case 'B':	if ((victim=ch->fighting) != NULL)
comm.c:				case 'q':	if ((victim=ch->fighting) != NULL) 
comm.c:			        case 'L':       if (IS_SET(ch->tmpact,TMPACT_AWAY))
comm.c:						if (IS_SET(ch->plr,PLR_THIEF))
comm.c:						if (IS_SET(ch->plr2,PLR_PLAYER_HELPER))
comm.c:					        if (IS_IMMORTAL(ch)&&IS_SET(ch->plr,PLR_WIZINVIS)) 
comm.c:						    if (ch->invis_level >= 61) 
comm.c:						 	sprintf(buf2, " `BWizi:%d`w",ch->invis_level);
comm.c:                case '%':c2=strlen(buf); buf[c2++]=ch->pcdata->prompt[c1]; buf[c2]=0; break;
comm.c:                case 'g':sprintf(buf2,"%ld,%ld,%ld,%ld",ch->gold[0],ch->gold[1],ch->gold[2],ch->gold[3]); strcat(buf,buf2); break;
comm.c:		case 'x':sprintf(buf2,"%ld",ch->exp); strcat(buf,buf2); break;	
comm.c:		case 'X':if (ch->level<LEVEL_HERO) 
comm.c:			   sprintf(buf2,"%ld",exp_table[ch->level +1].exp_at_level - ch->exp);
comm.c:	        sprintf(buf2,"%s", ch->prefix);
comm.c:	if ( ch->prompt_num > 0 )
comm.c:	    sprintf(buf, "%s", ch->pcdata->prompt_str);
comm.c:	if (IS_SET(ch->comm,COMM_TELNET_GA))
comm.c:	if ( IS_SET(ch->plr, PLR_DENY) )
comm.c:	/* if ( str_cmp( crypt( argument, ch->pcdata->pwd ), ch->pcdata->pwd ))  */
comm.c:	if ( ch->version < 11 )
comm.c:	    strncpy( ch->pcdata->pwd, argument, 30 );
comm.c:	if ( str_cmp( argument, ch->pcdata->pwd )) 
comm.c:	if ( ch->pcdata->pwd[0] == 0)
comm.c:	if ( check_playing( d, ch->name ) )
comm.c:	if ( check_reconnect( d, ch->name, TRUE ) )
comm.c:	sprintf( log_buf, "%s@@%s has connected.", ch->name, d->host);
comm.c:	    strncpy( logon_data->name, ch->name, 30 );
comm.c:	    logon_data->level = IS_IMMORTAL(ch) ? 60 : ch->level;
comm.c:	    ch->logon_data = logon_data;
comm.c:	    if (IS_SET(ch->plr,PLR_WIZINVIS) )
comm.c:	    ch->logon_data->level = ch->invis_level ;
comm.c:	    strncpy( ch->logon_data->exit, "Login", 30 );
comm.c:        ch->desc->inlast[x]     = &str_empty[0];
comm.c:	ch->prompt_num = 1;
comm.c:	if ( ch->level == 0 ) /* if new char skip the menu */
comm.c:	if ( IS_SET( ch->plr, PLR_DIRECT ) )
comm.c:	    ch->prompt_num = 0;
comm.c:	strncpy( ch->pcdata->prompt_str, "Electric Dreams-> ", 160 );
comm.c:	strncpy( ch->pcdata->prompt_str, "Electric Dreams-> ", 160 );
comm.c:	 	ch->prompt_num = 0;
comm.c:			strncpy( ch->pcdata->prompt_str, "\n\rHit RTN for Menu-> ", 160 );
comm.c:			strncpy( ch->pcdata->prompt_str, "\n\rHit RTN for Menu-> ", 160 );
comm.c:			if ( ch->level == 0 || ch->in_room == NULL )
comm.c:			strncpy( ch->pcdata->prompt_str, "\n\rHit RTN for Menu-> ", 160 );
comm.c:	    		if (is_note_to(ch,pnote) && str_cmp(ch->name,pnote->sender)
comm.c:			strncpy( ch->pcdata->prompt_str, "\n\rHit RTN for Menu-> ", 160 );
comm.c:			strncpy( ch->pcdata->prompt_str, "\n\rHit RTN for Menu-> ", 160 );
comm.c:			strncpy( ch->pcdata->prompt_str, "\n\rHit RTN for Menu-> ", 160 );
comm.c:		        if (ch->logon_data != NULL )
comm.c:			    strncpy( ch->logon_data->exit, "Menu-Quit", 30 );
comm.c:		if (str_cmp(ch->name,d_old->character->name))
comm.c:	    if (check_reconnect(d,ch->name,TRUE))
comm.c:	    if (!check_reconnect( d, ch->name, FALSE ) )
comm.c:		ch->name, echo_off_str );
comm.c:	strncpy( ch->pcdata->pwd, pwdnew, 30 );
comm.c:	/*if ( str_cmp( crypt( argument, ch->pcdata->pwd ), ch->pcdata->pwd ) ) */
comm.c:	if ( str_cmp( argument, ch->pcdata->pwd ))
comm.c:	case 'm': case 'M': ch->sex = SEX_MALE;    
comm.c:			    ch->pcdata->true_sex = SEX_MALE;
comm.c:	case 'f': case 'F': ch->sex = SEX_FEMALE; 
comm.c:			    ch->pcdata->true_sex = SEX_FEMALE;
comm.c:	    	    if (!race_table[race][ch->sex].pc_race)
comm.c:	    	    sprintf(buf,"  %2d :  %-15s :  %s\n\r",race+1,race_table[race][ch->sex].name,world_name[ race_table[race][ch->sex].world ]);
comm.c:		ch->race = 18; /* Starting race */
comm.c:	    	    ch->perm_stat[i] = race_table[race][ch->sex].stats[i];
comm.c:	    	    ch->mod_stat[i]=0;
comm.c:		ch->pcdata->perm_aff 	= race_table[ race ][ ch->sex ].aff;
comm.c:		ch->pcdata->perm_aff_2 	= race_table[ race ][ ch->sex ].aff2;
comm.c:		ch->affected_by 	= ch->affected_by|ch->pcdata->perm_aff;
comm.c:		ch->affected_by_2 	= ch->affected_by_2|ch->pcdata->perm_aff_2;
comm.c:		ch->imm_flags		= ch->imm_flags|race_table[race][ch->sex].imm;
comm.c:		ch->res_flags		= ch->res_flags|race_table[race][ch->sex].res;
comm.c:		ch->vuln_flags		= ch->vuln_flags|race_table[race][ch->sex].vuln;
comm.c:		ch->form		= race_table[race][ch->sex].form;
comm.c:		ch->size 		= race_table[race][ch->sex].size;
comm.c:		ch->height 		= get_height_size( ch->size );
comm.c:		ch->weight 		= get_weight_size( ch->size );
comm.c:		ch->hands_free		= 2;
comm.c:		sprintf( log_buf, "%s@@%s new player.", ch->name, d->host );
comm.c:		    strncpy( logon_data->name, ch->name, 30 );
comm.c:		    logon_data->level 	= IS_IMMORTAL(ch) ? 60 : ch->level;
comm.c:		    ch->logon_data 		= logon_data;
comm.c:		    strncpy( ch->logon_data->exit, "New-Char", 30 );
comm.c:	if (race < 0 || race >= top_race || !race_table[race][ch->sex].pc_race)
comm.c:	    if (!race_table[race][ch->sex].pc_race)
comm.c:	    sprintf(buf,"  %2d :  %-15s :  %s\n\r",race+1,race_table[race][ch->sex].name,world_name[ race_table[race][ch->sex].world ]);
comm.c:	ch->race = race;
comm.c: 	    ch->perm_stat[i] = race_table[race][ch->sex].stats[i];
comm.c: 	    ch->mod_stat[i]=0;
comm.c: 	ch->affected_by = race_table[race][ch->sex].aff;
comm.c: 	ch->pcdata->perm_aff = race_table[race][ch->sex].aff;
comm.c: 	ch->imm_flags   = race_table[race][ch->sex].imm;
comm.c: 	ch->res_flags   = race_table[race][ch->sex].res;
comm.c:        ch->vuln_flags  = race_table[race][ch->sex].vuln;
comm.c:        ch->form        = race_table[race][ch->sex].form;
comm.c:        ch->size = race_table[race][ch->sex].size;
comm.c:        ch->height = get_height_size( ch->size );
comm.c:        ch->weight = get_weight_size( ch->size );
comm.c:	sprintf( log_buf, "%s@@%s new player.", ch->name, d->host );
comm.c:	    strncpy( logon_data->name, ch->name, 30 );
comm.c:	    logon_data->level 	= IS_IMMORTAL(ch) ? 60 : ch->level;
comm.c:	    ch->logon_data 		= logon_data;
comm.c:	    strncpy( ch->logon_data->exit, "New-Char", 30 );
comm.c:	att_str = number_range( 1, 6 ) + number_range( 1, 6 ) + number_range( 1, 6 ) + attrib_adjust_table[ch->race][STAT_STR];
comm.c:	att_int = number_range( 1, 6 ) + number_range( 1, 6 ) + number_range( 1, 6 ) + attrib_adjust_table[ch->race][STAT_INT];
comm.c:	att_wis = number_range( 1, 6 ) + number_range( 1, 6 ) + number_range( 1, 6 ) + attrib_adjust_table[ch->race][STAT_WIS];
comm.c:	att_dex = number_range( 1, 6 ) + number_range( 1, 6 ) + number_range( 1, 6 ) + attrib_adjust_table[ch->race][STAT_DEX];
comm.c:	att_con = number_range( 1, 6 ) + number_range( 1, 6 ) + number_range( 1, 6 ) + attrib_adjust_table[ch->race][STAT_CON];
comm.c:	att_chr = number_range( 1, 6 ) + number_range( 1, 6 ) + number_range( 1, 6 ) + attrib_adjust_table[ch->race][STAT_CHR];
comm.c:	   	ch->perm_stat[STAT_STR] = URANGE( 3, att_str, 19 );
comm.c:	   	ch->perm_stat[STAT_INT] = URANGE( 3, att_int, 19 );
comm.c:	   	ch->perm_stat[STAT_WIS] = URANGE( 3, att_wis, 19 );
comm.c:	   	ch->perm_stat[STAT_DEX] = URANGE( 3, att_dex, 19 );
comm.c:	   	ch->perm_stat[STAT_CON] = URANGE( 3, att_con, 19 );
comm.c:	   	ch->perm_stat[STAT_CHR] = URANGE( 3, att_chr, 19 );
comm.c:		if ( ch->race >= 0 && ch->race < 3 )
comm.c:		else if ( ch->race >=3 && ch->race < 6 )
comm.c:		else if ( ch->race >= 6 && ch->race < 9 )
comm.c:		att_str = number_range( 1, 6 ) + number_range( 1, 6 ) + number_range( 1, 6 ) + attrib_adjust_table[ch->race][STAT_STR];
comm.c:		att_int = number_range( 1, 6 ) + number_range( 1, 6 ) + number_range( 1, 6 ) + attrib_adjust_table[ch->race][STAT_INT];
comm.c:		att_wis = number_range( 1, 6 ) + number_range( 1, 6 ) + number_range( 1, 6 ) + attrib_adjust_table[ch->race][STAT_WIS];
comm.c:		att_dex = number_range( 1, 6 ) + number_range( 1, 6 ) + number_range( 1, 6 ) + attrib_adjust_table[ch->race][STAT_DEX];
comm.c:		att_con = number_range( 1, 6 ) + number_range( 1, 6 ) + number_range( 1, 6 ) + attrib_adjust_table[ch->race][STAT_CON];
comm.c:		att_chr = number_range( 1, 6 ) + number_range( 1, 6 ) + number_range( 1, 6 ) + attrib_adjust_table[ch->race][STAT_CHR];
comm.c:		if ( ch->race >= 0 && ch->race < 3 )
comm.c:		else if ( ch->race >=3 && ch->race < 6 )
comm.c:		else if ( ch->race >= 6 && ch->race < 9 )
comm.c:	ch->guilds = guild_name_bit( guild_table[ guild ].name );
comm.c:	    SET_BIT(ch->plr, PLR_ANSI);
comm.c:	    ch->color = 1;
comm.c:	    SET_BIT(ch->act, PLR_ANSI);
comm.c:	if ( ch->level  == 0 )  /*if new char skip the menu */
comm.c:	    ch->color = 0;
comm.c:	if ( ch->level  == 0 )  /*if new char skip the menu */
comm.c:    	if (ch->color )
comm.c:	SET_BIT(ch->plr, PLR_ANSI);	
comm.c:	ch->next	= char_list;
comm.c:	if ( ch->level == 0 )
comm.c:	    ch->level				= 1;
comm.c:	    ch->kills				= 0;
comm.c:	    ch->pkills				= 0;
comm.c:	    ch->died				= 0;
comm.c:	    ch->exp				= exp_table[ch->level].exp_at_level;
comm.c:	    if ( ch->race == 18 )
comm.c:    	    	strncpy( ch->pcdata->prompt, "`RWelcome to Electric Dreams OCC > `w", 160 );
comm.c:		strncpy( ch->pcdata->prompt, "`yHp %c`y/`w%H `yMv %d`y/`w%V`y-> ", 160 );
comm.c:	    ch->pcdata->Oprompt[0]	   	= '\0';
comm.c:	    ch->max_move			=100;
comm.c:	    ch->pcdata->perm_move		=100;
comm.c:	    ch->played  			= 0;
comm.c:	    ch->birth_day 			= time_info[ race_table[ ch->race ][ ch->sex ].world ].day;
comm.c:	    ch->birth_month 			= time_info[ race_table[ ch->race ][ ch->sex ].world ].month;
comm.c:	    ch->pcdata->perm_hit		=20;
comm.c:	    ch->max_hit				=20;
comm.c:	    ch->hit				= 20;
comm.c:	        ch->max_mana[i] 		= race_table[ ch->race ][ ch->sex ].mana_die[ i ] * race_table[ ch->race ][ ch->sex ].mana_dice[ i ] + race_table[ ch->race ][ ch->sex ].mana_bonus[ i ];
comm.c:		ch->max_mana[i] 		*= 20; 
comm.c:	        ch->mana[i]			= ch->max_mana[ i ];
comm.c:	        ch->pcdata->perm_mana[i]	= ch->max_mana[ i ];
comm.c:	    ch->move				= 100;
comm.c:	    ch->infoact 			= INFOACT_DEATH|INFOACT_LEVEL;
comm.c:	    ch->lines	 			= 40;
comm.c:	    if ( ch->race == 18 )
comm.c:	    	ch->practice 			= 20;
comm.c:		ch->practice			= 0;
comm.c:	    ch->pcdata->security 		= 9;
comm.c:	    ch->in_room 			= NULL;
comm.c:    	    ch->short_descr[0]			= '\0';
comm.c:    	    ch->long_descr[0] 			= '\0';
comm.c:    	    ch->was_in_room 			= NULL;
comm.c:    	    ch->pet				= 0;
comm.c:    	    ch->mount				= 0;
comm.c:    	    ch->played				= 0;
comm.c:    	    ch->logon				= (int) (current_time);
comm.c:    	    ch->plr				= PLR_NOSUMMON;
comm.c:    	    ch->cmd_groups			= CMD_GROUP_PLAYER;
comm.c:	    if ( ch->race == 18 )
comm.c:    	    	ch->guilds			= DEFAULT;
comm.c:    	    if (ch->color )
comm.c:		SET_BIT(ch->plr, PLR_ANSI);	
comm.c:    	    ch->act				= 0;
comm.c:    	    ch->tmpact				= 0;
comm.c:	    if ( ch->race == 18 )
comm.c:    	    	ch->comm			= COMM_COMBINE|COMM_PROMPT|COMM_QUIET; 
comm.c:    	    	ch->comm			= COMM_COMBINE|COMM_PROMPT; 
comm.c:    	    ch->invis_level			= 0;
comm.c:    	    ch->room_template			= 0;
comm.c:    	    ch->regen_timer 			= current_time;
comm.c:    	    ch->position			= POS_STANDING;
comm.c:    	    ch->wimpy			 	= 0;
comm.c:    	    ch->gold[0]			        = 0;
comm.c:    	    ch->gold[1]			        = 0;
comm.c:    	    ch->gold[2]			        = 0;
comm.c:    	    ch->gold[3]			        = 0;
comm.c:    	    ch->pcdata->confirm_delete		= FALSE;
comm.c:    	    ch->pcdata->bamfin[0]		= '\0';
comm.c:    	    ch->pcdata->bamfout[0]		= '\0';
comm.c:    	    ch->pcdata->title[0]		= '\0';
comm.c:    	    ch->pcdata->corpse			= NULL;
comm.c:    	    ch->pcdata->read_notes		= NULL;
comm.c:    	    ch->pcdata->last_level		= 0;
comm.c:    	    ch->pcdata->condition[COND_THIRST]	= race_table[ ch->race ][ ch->sex ].max_condition[COND_THIRST]; 
comm.c:    	    ch->pcdata->condition[COND_FULL]	= race_table[ ch->race ][ ch->sex ].max_condition[COND_FULL];
comm.c:            ch->pcdata->pcclan			= NULL;
comm.c:    	    ch->bank				= 0;
comm.c:    	    ch->home				= 0;   
comm.c:    	    ch->inside_area			= NULL;   
comm.c:		    if ( race_table[ ch->race ][ ch->sex ].gained[sn] == TRUE )
comm.c:			ch->pcdata->learned[sn] = race_table[ ch->race ][ ch->sex ].starting[sn];
comm.c:		    if ( race_table[a][b].world == race_table[ ch->race ][ ch->sex ].world )
comm.c:			ch->pcdata->learned[ race_table[a][b].language ] = 50;
comm.c:            if ( race_table[ ch->race ][ ch->sex ].world == 0 )
comm.c:                ch->pcdata->learned[ gsn_swim ] = 100;
comm.c:	    if ( ch->race == 8 )
comm.c:		ch->pcdata->learned[ gsn_sneak ] = 100;
comm.c:            ch->pcdata->learned[ gsn_common ] = 100;
comm.c:	    ch->pcdata->learned[ race_table[ ch->race ][ ch->sex ].language ] = 100;
comm.c:	if ( ch->race == 18 )
comm.c:	    char_to_room( ch, get_room_index( race_table[ ch->race ][ ch->sex ].begin ) );
comm.c:	else if ( ch->in_room != NULL )
comm.c:	    char_to_room( ch, ch->in_room );
comm.c:	    char_to_room( ch, get_room_index( race_table[ ch->race ][ ch->sex ].begin ) );
comm.c:	if ( race_table[ ch->race ][ ch->sex ].gained[sn] == TRUE )
comm.c:	if ( ch->pcdata->learned[sn] == 0 )
comm.c:	 ch->pcdata->learned[sn] = race_table[ ch->race ][ ch->sex ].starting[sn];
comm.c:        sprintf (buf2,"%s has entered the game.\n\r",ch->name);
comm.c:	ch->regen_timer	= current_time;
comm.c:	if (ch->pet != NULL)
comm.c:	    char_to_room(ch->pet,ch->in_room);
comm.c:	    act("$n has entered the game.",ch->pet,NULL,NULL,TO_ROOM);
comm.c:	if (ch->mount != NULL)
comm.c:            if ( ch->mount->in_room == NULL )
comm.c:	    char_to_room(ch->mount,ch->in_room);
comm.c:	    act("$n has entered the game.",ch->mount,NULL,NULL,TO_ROOM);
comm.c:	    if (is_note_to(ch,pnote) && str_cmp(ch->name,pnote->sender)
comm.c:	if ( ch->level > 1 ) /* Creation OCC */
comm.c:    for ( ch = char_list; ch != NULL; ch = ch->next )
comm.c:	&&   (!fConn || ch->desc == NULL)
comm.c:	&&   !str_cmp( name, ch->name ) )
comm.c:		ch->desc	 = d;
comm.c:		ch->timer	 = 0;
comm.c:		sprintf( log_buf, "%s@@%s reconnected.", ch->name, d->host );
comm.c:    ||   ch->desc == NULL
comm.c:    ||   ch->desc->connected != CON_PLAYING
comm.c:    ||   ch->was_in_room == NULL 
comm.c:    ||   ch->in_room != get_room_index(ROOM_VNUM_LIMBO))
comm.c:    ch->timer = 0;
comm.c:    char_to_room( ch, ch->was_in_room );
comm.c:    ch->was_in_room	= NULL;
comm.c:    if ( txt != NULL && ch->desc != NULL )
comm.c:   	write_to_buffer( ch->desc, txt, strlen(txt) );
comm.c:    if (ch->color)
comm.c:    if ( txt == NULL || ch->desc == NULL)
comm.c:    if ( ch->lines == 0 )
comm.c:    free_string( ch->desc->showstr_head );
comm.c:    free_string( ch->desc->showstr_point );
comm.c:   /* if (ch->lines < 0 || ch->lines > 100 ) 
comm.c:	ch->lines = 100;
comm.c:    ch->desc->showstr_head = str_dup( txt );
comm.c:    ch->desc->showstr_point = ch->desc->showstr_head;
comm.c:    show_string(ch->desc,"");
comm.c:    if (ch->sex < 1 || ch->sex > 3)
comm.c:    	ch->sex = IS_NPC(ch) ? 1 : ch->pcdata->true_sex;
comm.c:    if (ch == NULL || ch->in_room == NULL)
comm.c:    to = ch->in_room->people;
comm.c:	if (vch->in_room == NULL)
comm.c:        to = vch->in_room->people;
comm.c:    room_snoop_list = ch->in_room->snoop_by;
comm.c:    if (ch == NULL || ch->in_room == NULL)
comm.c:    to = ch->in_room->people;
comm.c:	if (vch->in_room == NULL)
comm.c:        to = vch->in_room->people;
comm.c:    room_snoop_list = ch->in_room->snoop_by;
comm.c:    for ( vch = char_list; vch != NULL; vch = vch->next)
comm.c:	    if ( vch->level < 2 )
comm.c:		if (och->logon_data != NULL)
comm.c:		    strncpy( och->logon_data->exit, "HOTReboot", 30 );
comm.c:			sprintf(buf3, "%d %s %s\n", d->descriptor, och->name, d->host);
comm.c:/*			if (och->level == 1)
comm.c:                          och->level = 2;
comm.c:                          och->lvl[och->class] = 2;
db.c:		for ( rch = pRoomIndex->people ; rch != NULL ; rch = rch->next_in_room )
db.c:		    if ( IS_NPC( rch ) && rch->pIndexData->vnum == pReset->vnum )
db.c:			    vch->pet = mob;
db.c:			    vch->mount = mob;
db.c:load_room_triggers(ch, ch->in_room );
db.c:    pRoomIndex = ch->in_room;
db.c:    pracs = ch->pIndexData->prac_skills;
db.c:	  || ch->level < get_skill_level(ch, sn) ) 
db.c:	if ( ( IS_SET( ch->act, ACT_GAIN ) || IS_SET( ch->act, ACT_REPAIR ) ) && sn == gsn_shadowform )
db.c:        for ( skills = ch->skills ; skills != NULL && skills->sn != sn ; skills = skills->next );
db.c:	skills->next = ch->skills;
db.c:	ch->skills = skills;
db.c:    pracs = ch->pIndexData->prac_spells;
db.c:	  || ch->level < get_skill_level( ch, sn ) ) 
db.c:        for ( skills = ch->skills ; skills != NULL && skills->sn != sn ; skills = skills->next );
db.c:	skills->next = ch->skills;
db.c:	ch->skills = skills;
db.c:    ch->name[0]                 = '\0';
db.c:    ch->short_descr[0]		= '\0';
db.c:    ch->long_descr[0]           = '\0';
db.c:    ch->description             = &str_empty[0];
db.c:    ch->prefix[0]               = '\0';
db.c:    ch->logon                   = current_time;
db.c:    ch->lines                   = PAGELEN;
db.c:    ch->guilds                  = DEFAULT;
db.c:    ch->edit_flags              = 0;
db.c:    ch->armor 			= 100;
db.c:    ch->comm                    = 0;
db.c:    ch->regen_timer		= current_time;
db.c:    ch->position                = POS_STANDING;
db.c:    ch->practice                = 0;
db.c:    ch->edit_menu               = 0;
db.c:    ch->hit                     = 20;
db.c:    ch->max_hit                 = 20;
db.c:        ch->mana[i]                    = race_table[ ch->race ][ ch->sex ].mana_die[ i ] * race_table[ ch->race ][ ch->sex ].mana_dice[ i ] + race_table[ ch->race ][ ch->sex ].mana_bonus[ i ];
db.c:	ch->mana[i]		      *= 5; 
db.c:        ch->max_mana[i]                = ch->mana[i];
db.c:    ch->move                    = 100;
db.c:    ch->max_move                = 100;
db.c:    ch->tmpact			= 0;
db.c:    ch->infoact			= 0xFFFFFFFF;
db.c:    ch->follower		= NULL;
db.c:    ch->next_follower		= NULL;
db.c:    ch->group			= NULL;
db.c:    ch->next_in_group		= NULL;
db.c:    ch->race			= 1;
db.c:        ch->perm_stat[i] = 13; 
db.c:        ch->mod_stat[i] = 0;
db.c:    for ( trigger = ch->triggers; trigger != NULL; trigger = trigger_next )
db.c:    for ( var = ch->variables; var != NULL; var = var_next )
db.c:    	for ( skills = ch->innate_skills; skills != NULL; skills = skills_next )
db.c:    for ( skills = ch->skills; skills != NULL; skills = skills_next )
db.c:    for ( quests = ch->char_quests; quests != NULL; quests = quest_next )
db.c:    for ( obj = ch->carrying; obj != NULL; obj = obj_next )
db.c:    for ( paf = ch->affected; paf != NULL; paf = paf_next )
db.c:   	free_string( ch->description );
db.c:    if ( ch->pcdata != NULL )
db.c:        ch->pcdata->next = pcdata_free;
db.c:        pcdata_free      = ch->pcdata;
db.c:    	for ( read_notes = ch->pcdata->read_notes ; read_notes != NULL ; read_notes = read_notes_next )
db.c:    ch->next         = char_free;
db.c:	if (ch->level >= pArea->visible && pArea->visible >= 0)
db.c:	if (ch->level >= pArea->visible && pArea->visible >= 0)
db.c:	if (ch->level >= pArea->visible && pArea->visible >= 0)
db.c:	if (ch->level >= pArea->visible && pArea->visible >= 0)
db.c:    for (fch = char_list; fch != NULL; fch = fch->next)
db.c:	if (fch->pcdata != NULL)
db.c:	for (af = fch->affected; af != NULL; af = af->next)
db.c:    for (fch = char_free; fch != NULL; fch = fch->next)
db.c:            ch->in_room ? ch->in_room->vnum : 0, ch->name, str );
fight.c:    for ( ch = char_list; ch != NULL; ch = ch->next )
fight.c:	ch_next	= ch->next;
fight.c:	if ( ( victim = ch->fighting ) == NULL || ch->in_room == NULL )
fight.c:	if ( IS_SET( ch->plr, PLR_FLEE ) && ch->wait <= 0 )
fight.c:	if ( IS_AWAKE(ch) && ch->in_room == victim->in_room && !IS_SET( ch->plr, PLR_FLEE ) )
fight.c:	if ( ( victim = ch->fighting ) == NULL )
fight.c:    if ( IS_SET( ch->plr, PLR_PK ) )
fight.c:        cost = 100000 * ch->level;
fight.c:        if ( cost > get_money_total( ch, ch->in_room->area->world ) )
fight.c:	REMOVE_BIT( ch->plr, PLR_PK );
fight.c:        get_char_money( ch, cost, ch->in_room->area->world );
fight.c:    cost = 10000 * ch->level;
fight.c:    if ( cost > get_money_total( ch, ch->in_room->area->world ) )
fight.c:    get_char_money( ch, cost, ch->in_room->area->world );
fight.c:    SET_BIT( ch->plr, PLR_PK );
fight.c:    for (rch = ch->in_room->people; rch != NULL; rch = rch_next)
fight.c:	rch_next = rch->next_in_room;
fight.c:	if (IS_AWAKE(rch) && rch->fighting == NULL)
fight.c:	    && IS_SET(rch->off_flags,ASSIST_PLAYERS)
fight.c:	    &&  rch->level + 6 > victim->level)
fight.c:		if ( ( (!IS_NPC(rch) && IS_SET(rch->plr,PLR_AUTOASSIST))
fight.c:		if ( (IS_NPC(rch) && IS_SET(rch->off_flags,ASSIST_ALL))
fight.c:		||   (IS_NPC(rch) && rch->race == ch->race 
fight.c:		   && IS_SET(rch->off_flags,ASSIST_RACE))
fight.c:		||   (rch->pIndexData == ch->pIndexData 
fight.c:		   && IS_SET(rch->off_flags,ASSIST_VNUM))
fight.c:		    for (vch = ch->in_room->people; vch; vch = vch->next_in_room)
fight.c: if (ch->desc == NULL)
fight.c:    ch->wait = UMAX(0, ch->wait - PULSE_VIOLENCE);
fight.c: if (ch->position < POS_RESTING)
fight.c: if ( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
fight.c: if ( IS_SET(ch->affected_by_2, AFF_STUN) )
fight.c:     REMOVE_BIT(ch->affected_by_2, AFF_STUN);
fight.c: switch (ch->specattack)
fight.c:    if (ch->fighting != victim)
fight.c:    if ( IS_SET(ch->off_flags, OFF_FAST) && !IS_AFFECTED(ch, AFF_HASTE) && !IS_AFFECTED_2(ch, AFF_SLOW) )
fight.c:    if ( IS_SET(ch->off_flags, OFF_SECOND) )
fight.c:    if ( IS_SET( ch->off_flags, OFF_THIRD ) )
fight.c:    if ( ch->fighting != victim || dt == gsn_shadowstrike )
fight.c:	if ( ch->fighting != victim )
fight.c:	if ( ch->fighting != victim )
fight.c:	if ( ch->fighting != victim )
fight.c:	if ( ch->fighting != victim )
fight.c:    fast_chance = get_skill(ch,gsn_fast)/2 + (ch->level/2) - (victim->level/4);
fight.c:    shola_kick_chance = get_skill(ch,gsn_shola_kick)/2 + (ch->level/2) - (victim->level/4);
fight.c:    shola_punch_chance = get_skill(ch,gsn_shola_punch)/2 + (ch->level/2) - (victim->level/4);
fight.c:    high_kick_chance = get_skill(ch,gsn_high_kick)/2 + (ch->level/2) - (victim->level/4);
fight.c:    knee_punch_chance = get_skill(ch,gsn_knee_punch)/2 + (ch->level/2) - (victim->level/4);
fight.c:    if ( IS_SET( ch->affected_by_2, AFF_SLOW ) )
fight.c:    if ( IS_SET( ch->affected_by, AFF_HASTE ) )
fight.c:	    if ( ch->fighting != victim )
fight.c:	    		    if ( ch->fighting != victim )
fight.c:	    		    if ( ch->fighting != victim )
fight.c:	    		    if ( ch->fighting != victim )
fight.c:	if ( ch->fighting != victim )
fight.c:	if ( ch->fighting != victim )
fight.c:    if (IS_SET(ch->act, ACT_WIMPY) )
fight.c:    if ( IS_SET(ch->affected_by_2, AFF_STUN) )
fight.c:	REMOVE_BIT(ch->affected_by_2, AFF_STUN);
fight.c:    if (ch->fighting != victim)
fight.c:    if (IS_SET(ch->off_flags,OFF_AREA_ATTACK))
fight.c:	for (vch = ch->in_room->people; vch != NULL; vch = vch_next)
fight.c:	    vch_next = vch->next_in_room;
fight.c:	    if ((vch != victim && vch->fighting == ch))
fight.c:    if (ch->fighting != victim || dt == gsn_shadowstrike)
fight.c:    if ( victim->position == POS_DEAD || ch->in_room != victim->in_room )
fight.c:    if ( IS_SET(ch->affected_by_2, AFF_STUN) )
fight.c:	REMOVE_BIT(ch->affected_by_2, AFF_STUN); 
fight.c:	    dt += ch->dam_type;
fight.c:    	    dam_type = attack_table[ch->dam_type].damage;
fight.c:    if ( ch->mount != NULL && IS_AFFECTED( ch->mount, AFF_MOUNTED) )
fight.c:	chance += ( IS_AFFECTED(ch->mount, AFF_FLYING|AFF_LEVITATING) ? get_skill( ch,gsn_riding_air ) : get_skill( ch, gsn_riding ) ) / 5;
fight.c:    chance += ch->level;
fight.c:		obj_to_room( wield, ch->in_room );
fight.c:		SET_BIT(ch->act2, ACT2_WEAPON_LOST );
fight.c:	       	af.level        = ch->level;
fight.c:	    	damage( ch, ch, number_range(1,ch->level), dt, dam_type );
fight.c:	    	damage( ch, ch, number_range(1,ch->level), dt, dam_type );
fight.c:	    dam = dice(ch->damage[DICE_NUMBER],ch->damage[DICE_TYPE]);
fight.c:	    dam = dice( get_skill( ch, dt ) / 15, 6 ) + ( ch->level / 4 );
fight.c:    if ( ch->mount != NULL && IS_AFFECTED(ch->mount, AFF_MOUNTED) )
fight.c:	dam += ch->mount->level / 10 + ( IS_AFFECTED(ch->mount, AFF_FLYING|AFF_LEVITATING) ? get_skill( ch, gsn_riding_air ) : get_skill( ch, gsn_riding ) ) / 10;
fight.c:		dam *= 2 + ch->level / 10; 
fight.c:		dam *= 2 + ch->level / 8;
fight.c:	dam *= 2 + ch->level / 12;
fight.c:	    ch->hit = UMIN( ch->hit + ( dam / 5 ), ch->max_hit);
fight.c:	    if ( ch->fighting == NULL )
fight.c:	    &&   victim->master->in_room == ch->in_room
fight.c:	REMOVE_BIT( ch->affected_by, AFF_SHADOWFORM );
fight.c:		if (IS_SET(ch->imm_flags, IMM_FIRE) )
fight.c:		else if (IS_SET(ch->res_flags, RES_FIRE) )
fight.c:		else if (IS_SET(ch->vuln_flags, VULN_FIRE) )
fight.c:	    if ( ch->group != NULL )
fight.c:	    ch->group->pkills++;
fight.c:	    ch->pkills ++;
fight.c:	    check_top_ten( ch, ch->pkills, 0 );
fight.c:	    if (ch->logon_data != NULL)
fight.c:	    ch->logon_data->pkills++;
fight.c:	    trig = do_trigger( ch->in_room, ch, NULL, NULL, TRIG_KILLS_PLAYER, TRIG_TYPE_ROOM);
fight.c:	    if ( ch->group != NULL )
fight.c:	    ch->group->mob_kills++;
fight.c:	    ch->kills ++;
fight.c:	    check_top_ten( ch, ch->kills,  1 );
fight.c:	    if (ch->logon_data != NULL)
fight.c:	    ch->logon_data->kills++;
fight.c:	    trig = do_trigger( ch->in_room, ch, NULL, NULL, TRIG_KILLS_MOB, TRIG_TYPE_ROOM);
fight.c:		act_trigger( victim, pTrig->name, NULL, IS_NPC(ch) ? ch->short_descr : ch->name, NULL );
fight.c:		(IS_NPC(ch) ? ch->short_descr : ch->name) );
fight.c:	if ( is_name( ch->hunting, victim->name ) )
fight.c:	    ch->hunting[0] = '\0';
fight.c:	strncpy(victim->dislikes, ch->name,30);
fight.c:	    fch_next = fch->next;
fight.c:	    if ( is_name( fch->dislikes ,victim->name ) )
fight.c:            	fch->dislikes[0] = '\0';
fight.c:	    	if ( IS_NPC(fch) && ( fch->spec_fun == spec_thug || fch->spec_fun == spec_nightmare || fch->spec_fun == spec_assassin ) )
fight.c:	if( ch->group && IS_NPC( victim ) && victim->in_room == ch->group->treasurer->in_room )
fight.c:	    do_get( ch->group->treasurer, "all corpse" );
fight.c:	   corpse = get_obj_list( ch, "corpse", ch->in_room->contents ); 
fight.c:	    if ( IS_SET(ch->plr, PLR_AUTOLOOT) && 
fight.c: 	    if (IS_SET(ch->plr,PLR_AUTOGOLD)
fight.c:		&& !IS_SET(ch->plr,PLR_AUTOLOOT))
fight.c:	    if ( IS_SET(ch->plr, PLR_AUTOSAC) && IS_NPC(victim))
fight.c:    strncpy( name, ch->name, 16 );
fight.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SAFE ) )
fight.c:	||  IS_SET(ch->act,ACT_PET) || IS_SET(ch->act,ACT_MOUNT)))
fight.c:	if (!IS_NPC(victim) && ( victim->level <= 15 || IS_SET( ch->in_room->area->area_flags, AREA_PKSAFE ) ) )
fight.c:	     && IS_SET( ch->plr, PLR_PK ) && ch->group == NULL && victim->group == NULL )
fight.c:	    if ( IS_SET( ch->in_room->area->area_flags, AREA_PKSAFE ) )
fight.c:	    else if ( ch->pcdata->pcclan == NULL )
fight.c:	    else if ( ch->pcdata->pcclan->clan->name == victim->pcdata->pcclan->clan->name )
fight.c:    if (IS_SET(ch->in_room->room_flags,ROOM_SAFE))
fight.c:            || IS_SET(ch->act,ACT_PET) || IS_SET(ch->act,ACT_MOUNT)))
fight.c:	     && IS_SET( ch->plr, PLR_PK ) && ch->group == NULL && victim->group == NULL )
fight.c:	    if ( IS_SET( ch->in_room->area->area_flags, AREA_PKSAFE ) )
fight.c:	    else if ( ch->pcdata->pcclan == NULL )
fight.c:	    else if ( ch->pcdata->pcclan->clan->name == victim->pcdata->pcclan->clan->name )
fight.c:    if ( number_percent( ) >= chance + victim->level - ch->level )
fight.c:    if ( !IS_SET( ch->plr2, PLR_NOMISS ) )
fight.c:    for ( rch = ch->in_room->people ; rch != NULL ; rch = rch->next_in_room )
fight.c:	if ( !IS_SET( rch->plr2, PLR_NOMISS ) )
fight.c:	if ( number_percent( ) <= chance + victim->level - ch->level )
fight.c:    if ( number_percent( ) >= chance + victim->level - ch->level )
fight.c:    if ( !IS_SET( ch->plr2, PLR_NOMISS ) )
fight.c:    for ( rch = ch->in_room->people ; rch != NULL ; rch = rch->next_in_room )
fight.c:	if ( !IS_SET( rch->plr2, PLR_NOMISS ) )
fight.c:    if ( chance <= 0 || number_percent( ) >= chance + victim->level - ch->level )
fight.c:    if ( !IS_SET( ch->plr2, PLR_NOMISS ) )
fight.c:    for ( rch = ch->in_room->people ; rch != NULL ; rch = rch->next_in_room )
fight.c:	if ( !IS_SET( rch->plr2, PLR_NOMISS ) )
fight.c:    if ( chance <= 0 || number_percent( ) >= chance + victim->level - ch->level )
fight.c:    if ( !IS_SET( ch->plr2, PLR_NOMISS ) )
fight.c:    for ( rch = ch->in_room->people ; rch != NULL ; rch = rch->next_in_room )
fight.c:	if ( !IS_SET( rch->plr2, PLR_NOMISS ) )
fight.c:    if ( ch->fighting != NULL )
fight.c:    ch->fighting = victim;
fight.c:    strncpy(ch->dislikes, victim->name,30);
fight.c:    ch->happy_hour = 0;
fight.c:    for ( fch = char_list; fch != NULL; fch = fch->next )
fight.c:	if ( fch == ch || ( fBoth && fch->fighting == ch ) )
fight.c:	    switch (fch->specattack) {
fight.c:                case 1 : fch->specattack = 0; break; 
fight.c:                default : fch->specattack = fch->specattack; 
fight.c:            fch->fighting	= NULL;
fight.c:	    set_position( fch, IS_NPC(fch) ? ch->default_pos : POS_STANDING );
fight.c:	    REMOVE_BIT(fch->affected_by_2, AFF_STUN);
fight.c:	if ( IS_SET( ch->form, FORM_INSTANT_DECAY ) )
fight.c:	strcpy( name, ch->short_descr);
fight.c:	if ( ch->gold[0] > 0 && !empty )
fight.c:	    obj_to_obj( create_money( ch->gold[0] , 0 ), corpse );
fight.c:	    ch->gold[0] = 0;
fight.c:	if ( ch->gold[1] > 0 && !empty )
fight.c:	    obj_to_obj( create_money( ch->gold[1] , 1 ), corpse );
fight.c:	    ch->gold[1] = 0;
fight.c:	if ( ch->gold[2] > 0 && !empty )
fight.c:	    obj_to_obj( create_money( ch->gold[2] , 2 ), corpse );
fight.c:	    ch->gold[2] = 0;
fight.c:	if ( ch->gold[3] > 0 && !empty )
fight.c:	    obj_to_obj( create_money( ch->gold[3] , 3 ), corpse );
fight.c:	    ch->gold[3] = 0;
fight.c:	strcpy( name, ch->name );
fight.c:	strncpy( corpse->owner, ch->name, 30 );
fight.c:	if ( ch->gold[0] > 0 && !empty )
fight.c:	    obj_to_obj( create_money( ch->gold[0] , 0 ), corpse );
fight.c:	    ch->gold[0] = 0;
fight.c:	if ( ch->gold[1] > 0 && !empty )
fight.c:	    obj_to_obj( create_money( ch->gold[1] , 1 ), corpse );
fight.c:	    ch->gold[1] = 0;
fight.c:	if ( ch->gold[2] > 0 && !empty )
fight.c:	    obj_to_obj( create_money( ch->gold[2] , 2 ), corpse );
fight.c:	    ch->gold[2] = 0;
fight.c:	if ( ch->gold[3] > 0 && !empty )
fight.c:	    obj_to_obj( create_money( ch->gold[3] , 3 ), corpse );
fight.c:	    ch->gold[3] = 0;
fight.c:        for ( obj = ch->carrying; obj != NULL; obj = obj_next )
fight.c:    obj_to_room( corpse, ch->in_room );
fight.c:	ch->pcdata->corpse = corpse;	
fight.c:    for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
fight.c:	    group_levels += gch->level;
fight.c:    if (ch->group != NULL )
fight.c:	    group_levels = ch->level ;
fight.c:    lch = (ch->leader != NULL) ? ch->leader : ch;
fight.c:    for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
fight.c:	    if (ch->logon_data != NULL)
fight.c:		ch->logon_data->exp += xp;
fight.c:	for ( obj = ch->carrying; obj != NULL; obj = obj_next )
fight.c:	    if ( ( IS_OBJ_STAT(obj, ITEM_ANTI_NENKEMEN)  && race_table[ ch->race ][ch->sex].world == 0 )
fight.c:	    ||   ( IS_OBJ_STAT(obj, ITEM_ANTI_MAEGMENEL)  && race_table[ ch->race ][ ch->sex ].world == 1 )
fight.c:	    ||   ( IS_OBJ_STAT(obj, ITEM_ANTI_LITHDOR)  && race_table[ ch->race ][ ch->sex ].world == 2 ) )
fight.c:		obj_to_room( obj, ch->in_room );
fight.c:    xp = xp / total_levels * gch->level;
fight.c:    if ( xp > exp_table[ gch->level + 1 ].exp_at_level - exp_table[ gch->level ].exp_at_level )
fight.c:	xp = exp_table[ gch->level + 1 ].exp_at_level - exp_table[ gch->level ].exp_at_level;
fight.c:    if (IS_SET(gch->plr2, PLR_FASTEXP ) )
fight.c:	if ( dam > 1 || !IS_SET( ch->plr2, PLR_NOMISS ) )
fight.c:	for ( rch = ch->in_room->people ; rch != NULL ; rch = rch->next_in_room )
fight.c:	     if ( dam > 1 || !IS_SET( rch->plr2, PLR_NOMISS ) )
fight.c:	if ( dam > 1 || !IS_SET( ch->plr2, PLR_NOMISS ) )
fight.c:	for ( rch = ch->in_room->people ; rch != NULL ; rch = rch->next_in_room )
fight.c:	     if ( dam > 1 || !IS_SET( rch->plr2, PLR_NOMISS ) )
fight.c:    if ( ch->fighting == NULL || ch->position != POS_FIGHTING)
fight.c:    hp_percent = 100 * ch->hit/ch->max_hit;
fight.c:	ch->move /= 2;
fight.c:	ch->hit += ch->level * 2;
fight.c:	ch->hit = UMIN(ch->hit,ch->max_hit);
fight.c:	af.modifier	= UMAX(10, 5 * (ch->level/5));
fight.c:	ch->move /= 2;
fight.c:    if ( ch->move < 9 )
fight.c:	ch->move -= 10;
fight.c:	ch->move = UMAX( ch->move, 0 );
fight.c:	ch->move -= 5;
fight.c:	ch->move = UMAX( ch->move, 0 );
fight.c:    if (ch->move < ch->level * 3 / 2)
fight.c:    if (ch->position == POS_FIGHTING)
fight.c:	ch->move -= ch->level * 3;
fight.c:	ch->move = UMAX(ch->move,0);
fight.c:	af.level	= ch->level;
fight.c:	af.duration	= ch->level / 10 + 3;
fight.c:	af.modifier	= UMIN(-1,-(ch->level * 3 / 2) );
fight.c:    	for ( pill = ch->carrying; pill != NULL && pill->pIndexData->vnum != OBJ_VNUM_BREATHFIRE ; pill = pill->next_content );
fight.c:	victim = ch->fighting;
fight.c:    if (IS_AFFECTED(ch,AFF_CONTROL_MIND) && ch->master == victim)
fight.c:    if (ch->size < victim->size)
fight.c:	chance += (ch->size - victim->size) * 25;
fight.c:	chance += (ch->size - victim->size) * 10; 
fight.c:    if (IS_SET(ch->off_flags,OFF_FAST))
fight.c:    chance += (ch->level - victim->level) * 2;
fight.c:	damage(ch,victim,number_range(2,2 + 1 * ch->level + chance/20),gsn_breathfire,
fight.c:    victim = ch->fighting;
fight.c:    chance += ch->level / 3;
fight.c:    	af.level     = ch->level;
fight.c:    	affect_apply_room( ch->in_room, &af );
fight.c:	af.level	= ch->level;
fight.c:	af.duration	= ch->level/2;
fight.c:	victim = ch->fighting;
fight.c:    if (IS_AFFECTED(ch,AFF_CONTROL_MIND) && ch->master == victim)
fight.c:    if (ch->size < victim->size)
fight.c:	chance += (ch->size - victim->size) * 25;
fight.c:	chance += (ch->size - victim->size) * 10; 
fight.c:    chance += (ch->level - victim->level) * 2;
fight.c:	victim = ch->fighting;
fight.c:    if (IS_AFFECTED(ch,AFF_CONTROL_MIND) && ch->master == victim)
fight.c:    chance += ch->carry_weight / 25;
fight.c:    if (ch->size < victim->size)
fight.c:	chance += (ch->size - victim->size) * 25;
fight.c:	chance += (ch->size - victim->size) * 10; 
fight.c:    if (IS_SET(ch->off_flags,OFF_FAST))
fight.c:    chance += (ch->level - victim->level) * 2;
fight.c:	damage(ch,victim,number_range(2,2 + 2 * ch->size + chance/20),gsn_bash,
fight.c:	victim = ch->fighting;
fight.c:    if (ch->mount != NULL && IS_SET(ch->mount->affected_by,AFF_MOUNTED) )
fight.c:    if (IS_AFFECTED(ch,AFF_CONTROL_MIND) && ch->master == victim)
fight.c:    if ((IS_SET(ch->off_flags,OFF_FAST) || IS_AFFECTED(ch,AFF_HASTE)) && !IS_AFFECTED_2(ch,AFF_SLOW))
fight.c:    chance += (ch->level - victim->level) * 2;
fight.c:    switch(ch->in_room->sector_type)
fight.c:	af.level 	= ch->level;
fight.c:	victim = ch->fighting;
fight.c:    if (IS_AFFECTED(ch,AFF_CONTROL_MIND) && ch->master == victim)
fight.c:    if (ch->size < victim->size)
fight.c:        chance += (ch->size - victim->size) * 10;  /* bigger = harder to trip */
fight.c:    if ((IS_SET(ch->off_flags,OFF_FAST) || IS_AFFECTED(ch,AFF_HASTE)) && !IS_AFFECTED_2(ch,AFF_SLOW))
fight.c:    chance += (ch->level - victim->level) * 2;
fight.c:    for ( victim = ch->in_room->people ; victim != NULL ; victim = victim->next_in_room )
fight.c:        if (IS_AFFECTED(ch,AFF_CONTROL_MIND) && ch->master == victim)
fight.c:        if (ch->size < victim->size)
fight.c:            chance += (ch->size - victim->size) * 10;  /* bigger = harder to trip */
fight.c:        if ((IS_SET(ch->off_flags,OFF_FAST) || IS_AFFECTED(ch,AFF_HASTE)) && !IS_AFFECTED_2(ch,AFF_SLOW))
fight.c:        chance += (ch->level - victim->level) * 2;
fight.c:	victim = ch->fighting;
fight.c:    if (IS_AFFECTED(ch,AFF_CONTROL_MIND) && ch->master == victim)
fight.c:    chance += ch->carry_weight / 25;
fight.c:    if (ch->size < victim->size)
fight.c:        chance += (ch->size - victim->size) * 10;  /* bigger = harder to slam */
fight.c:    if ((IS_SET(ch->off_flags,OFF_FAST) || IS_AFFECTED(ch,AFF_HASTE)) && !IS_AFFECTED_2(ch,AFF_SLOW))
fight.c:    chance += (ch->level - victim->level) * 2;
fight.c:	damage(ch,victim,number_range(ch->level * ch->size, ( ch->level * 2 ) * ch->size),gsn_slam,
fight.c:	damage(ch,victim,number_range(ch->level*ch->size/10, ch->level*ch->size/15),gsn_slam,DAM_BASH);
fight.c:    if ( ( victim = ch->fighting ) == NULL )
fight.c:        if ( ch->position == POS_FIGHTING )
fight.c:	victim = ch->fighting;
fight.c:    if (IS_AFFECTED(ch,AFF_CONTROL_MIND) && ch->master == victim)
fight.c:    if ( ch->move < 21 )
fight.c:    ch->move -= 20;
fight.c:    ch->move = UMAX( ch->move,1 );
fight.c:    chance += (ch->level - victim->level) * 2;
fight.c:    if ( ( victim = ch->fighting ) == NULL )
fight.c:        if ( ch->position == POS_FIGHTING )
fight.c:	victim = ch->fighting;
fight.c:    if (IS_AFFECTED(ch,AFF_CONTROL_MIND) && ch->master == victim)
fight.c:    if ( ch->move < 31 )
fight.c:    ch->move -= 50;
fight.c:    ch->move = UMAX( ch->move,1 );
fight.c:    chance += (ch->level - victim->level) * 2;
fight.c:    	    damage( ch, victim, number_range( 10, ch->level / 2 ), gsn_ki_force, DAM_BASH );
fight.c:	    damage( ch, victim, number_range( 10, ch->level / 2 ), gsn_ki_force, DAM_BASH );
fight.c:	ch->hit -=5;
fight.c:    if ( IS_AFFECTED(ch, AFF_CONTROL_MIND) && ch->master == victim )
fight.c:    if ( ch->position == POS_FIGHTING )
fight.c:       ( IS_SET(ch->act,ACT_PET) || IS_SET( ch->act,ACT_MOUNT))))
fight.c:    if ( IS_AFFECTED(ch, AFF_CONTROL_MIND) && ch->master == victim )
fight.c:    if ( ch->position == POS_FIGHTING )
fight.c:    if ( ch->level > victim->level+5 )
fight.c:    if ( !IS_NPC(victim) && ch->pcdata->pcclan == NULL )
fight.c:    if ( !IS_NPC(victim) && ch->pcdata->pcclan->clan == victim->pcdata->pcclan->clan )
fight.c:	sprintf(buf, "Help! I am being attacked by %s!",ch->short_descr);
fight.c:    	sprintf( buf, "Help!  I am being attacked by %s!", ch->name );
fight.c:    if ( ( victim = ch->fighting ) == NULL )
fight.c:    if ( victim->hit < victim->max_hit && ch->position >= POS_STANDING )
fight.c:    if ( ( victim = ch->fighting ) == NULL )
fight.c:        if ( ch->position == POS_FIGHTING )
fight.c:   if ( ch->move < 31 )
fight.c:   ch->move -= 30;
fight.c:   ch->move = UMAX( ch->move,1 );
fight.c:   if ( ch->level >= victim->level )
fight.c:   	chance += (ch->level - victim->level) / 2;
fight.c:   	chance += (ch->level - victim->level) * 2;
fight.c:		if ( number_percent( ) < 2 * ( ch->level/6 ) && !saves_spell( ch->level, victim ) )
fight.c:			damage( ch, victim, 3 * ( ( ch->level * 3 ) / 4 )  , gsn_precision_strike,DAM_NONE );
fight.c:			damage( ch, victim, 3 * ( ( ch->level * 3 ) / 4 )  , gsn_precision_strike,DAM_NONE );
fight.c:		if ( number_percent() < ( 2 * ( ch->level / 3 ) ) )
fight.c:			damage( ch, victim, 3 *  ( ch->level / 4 )  , gsn_precision_strike,DAM_NONE );
fight.c:	        	af.level        = ch->level;
fight.c:	        	af.duration     = ch->level;
fight.c:			damage( ch, victim, 3 * ( ch->level / 4 )  , gsn_precision_strike,DAM_NONE );
fight.c:	victim = ch->fighting;
fight.c:    if (ch->move < 30 )
fight.c:	ch->move -= 30;
fight.c:	ch->move = UMAX(ch->move,0);
fight.c:    if ( ( victim = ch->fighting ) == NULL )
fight.c:        if ( ch->position == POS_FIGHTING )
fight.c:	act( "No Surender! No Retreat! $N must die!", ch, ch->fighting, ch->fighting, TO_CHAR );
fight.c:    for ( rch = ch->in_room->people ; rch != NULL ; rch = rch->next_in_room )
fight.c:	if ( rch->fighting == ch )
fight.c:	    skill -= rch->level / 8;
fight.c:    SET_BIT( ch->plr, PLR_FLEE );
fight.c:	if ( ( pexit = ch->in_room->exit[door] ) != NULL
fight.c:    if ( ch->fighting == NULL )
fight.c:        if ( ch->position == POS_FIGHTING )
fight.c:	act( "Never! $N must die!", ch, ch->fighting, ch->fighting, TO_CHAR );
fight.c:    if ( IS_SET( ch->plr, PLR_FLEE ) )
fight.c:    SET_BIT( ch->plr, PLR_FLEE );
fight.c:    ROOM_INDEX_DATA *was_in = ch->in_room;
fight.c:    CHAR_DATA *victim = ch->fighting;
fight.c:    if ( ch->pcdata != NULL )
fight.c:	ch->pcdata->home_timer = 0;
fight.c:    for ( paf = ch->affected ; paf != NULL ; paf = paf_next )
fight.c:    if ( IS_AFFECTED( ch, AFF_BERSERK ) && ch->fighting != NULL )
fight.c:	act( "Never! $N must die!", ch, ch->fighting, ch->fighting, TO_CHAR );
fight.c:	REMOVE_BIT( ch->plr, PLR_FLEE );
fight.c:	REMOVE_BIT( ch->plr, PLR_FLEE );
fight.c:    was_in = ch->in_room;
fight.c:    REMOVE_BIT( ch->plr, PLR_FLEE );
fight.c:    if ( ( now_in = ch->in_room ) == was_in )
fight.c:    ch->in_room = was_in;
fight.c:    ch->in_room = now_in;
fight.c:		for ( rch = victim->in_room->people ; rch != NULL && rch->fighting != victim ; rch = rch->next_in_room );
fight.c:		    strncpy(victim->dislikes, ch->name,30);
fight.c:        if ( IS_SET( ch->pIndexData->affected_by, AFF_HIDE ) )
fight.c:		SET_BIT( ch->affected_by, AFF_HIDE );
fight.c:        if ( IS_SET( ch->pIndexData->affected_by_2, AFF_FADE ) )
fight.c:		SET_BIT( ch->affected_by_2, AFF_FADE );
fight.c:        if ( IS_SET( ch->pIndexData->affected_by, AFF_SHADOWFORM ) )
fight.c:		(*skill_table[gsn_shadowform].spell_fun) ( gsn_shadowform, ch->level, ch, ch );
fight.c:    if ( ch->fighting == victim )
fight.c:    if ( ch->fighting == NULL )
fight.c:    if ( fch->fighting == NULL )
fight.c:    if ( ( victim = ch->fighting ) == NULL )
fight.c:    if ( ( victim = ch->fighting ) == NULL )
fight.c:    if ( ( victim = ch->fighting ) == NULL )
fight.c:    	for ( vch = ch->in_room->people; vch != NULL; vch = vch_next )
fight.c:            vch_next = vch->next_in_room;
fight.c:    if ( ( victim = ch->fighting ) == NULL )
fight.c:	damage( ch, victim, number_range( 1, ch->level ), gsn_kick,DAM_BASH );
fight.c:    ||    (IS_NPC(ch) && !IS_SET(ch->off_flags,OFF_DISARM))))
fight.c:    if ( ( victim = ch->fighting ) == NULL )
fight.c:    chance += (ch->level - victim->level) * 2;
forge.c:    if ( !IS_SET( ch->in_room->room_flags, ROOM_FORGE ) )
forge.c:    for ( hammer = ch->carrying; hammer != NULL && !IS_SET( hammer->extra_flags, ITEM_HAMMER ); hammer = hammer->next_content );
forge.c:    if ( ch->pet != NULL )
forge.c:    steel_magic = ch->pcdata->forge[MINERAL_STEEL];
forge.c:    gold_magic = ch->pcdata->forge[MINERAL_GOLD];
forge.c:    diamond_magic = ch->pcdata->forge[MINERAL_DIAMOND];
forge.c:    silver_magic = ch->pcdata->forge[MINERAL_SILVER];
forge.c:    sapphire_magic = ch->pcdata->forge[MINERAL_SAPPHIRE];
forge.c:    ruby_magic = ch->pcdata->forge[MINERAL_RUBY];
forge.c:    emerald_magic = ch->pcdata->forge[MINERAL_EMERALD];
forge.c:    mithril_magic = ch->pcdata->forge[MINERAL_MITHRIL];
forge.c:    obsidian_magic = ch->pcdata->forge[MINERAL_OBSIDIAN];
forge.c:    platinum_magic = ch->pcdata->forge[MINERAL_PLATINUM];
forge.c:    copper_magic = ch->pcdata->forge[MINERAL_COPPER];
forge.c:    iron_magic = ch->pcdata->forge[MINERAL_IRON];
forge.c:    bronze_magic = ch->pcdata->forge[MINERAL_BRONZE];
forge.c:    adamantite_magic = ch->pcdata->forge[MINERAL_ADAMANTITE];
forge.c:    titanium_magic = ch->pcdata->forge[MINERAL_TITANIUM];
forge.c:    alabaster_magic = ch->pcdata->forge[MINERAL_ALABASTER];
forge.c:    if ( steel_magic < ( ch->level * 5 ) )
forge.c:    if ( gem_magic < ( ( ch->level * 3 ) * 3 / 2 ) )
forge.c:    if ( !IS_SET(ch->forge_flags, FORGE_COMPLETE ) )
forge.c:	SET_BIT(ch->forge_flags, IS_FORGING );
forge.c:	strncpy( ch->forge_item, "golem", 10 );
forge.c:	ch->forge_from = 3;
forge.c:	ch->forge_count = 5;
forge.c:    REMOVE_BIT(ch->forge_flags, FORGE_COMPLETE );
forge.c:	    if ( silver_magic >= ( ( ch->level * 3 ) * 3 / 2 ) )
forge.c:		level 					= ch->level;
forge.c:    		forged_golem->hit 			= number_range( ch->max_hit - 100, ch->max_hit + 100 );
forge.c:		if ( IS_SET( ch->guilds, MAJHERE ) )
forge.c:		    if ( race_table[ ch->race ][ ch->sex ].world == 0 )
forge.c:		    if ( race_table[ ch->race ][ ch->sex ].world == 1 )
forge.c:		    if ( race_table[ ch->race ][ ch->sex ].world == 0 )
forge.c:		    forged_golem->guilds		= ch->guilds;
forge.c:	    else if ( gold_magic >= ( ( ch->level * 3 ) * 3 / 2 ) )
forge.c:		level 					= ch->level;
forge.c:    		forged_golem->hit 			= number_range( ch->max_hit - 100, ch->max_hit + 100 );
forge.c:		if ( IS_SET( ch->guilds, MAJHERE ) )
forge.c:		    if ( race_table[ ch->race ][ ch->sex ].world == 0 )
forge.c:		    if ( race_table[ ch->race ][ ch->sex ].world == 1 )
forge.c:		    if ( race_table[ ch->race ][ ch->sex ].world == 0 )
forge.c:		    forged_golem->guilds		= ch->guilds;
forge.c:	    else if ( copper_magic >= ( ( ch->level * 3 ) * 3 / 2 ) )
forge.c:		level 					= ch->level;
forge.c:    		forged_golem->hit 			= number_range( ch->max_hit - 100, ch->max_hit + 100 );
forge.c:		if ( IS_SET( ch->guilds, MAJHERE ) )
forge.c:		    if ( race_table[ ch->race ][ ch->sex ].world == 0 )
forge.c:		    if ( race_table[ ch->race ][ ch->sex ].world == 1 )
forge.c:		    if ( race_table[ ch->race ][ ch->sex ].world == 0 )
forge.c:		    forged_golem->guilds		= ch->guilds;
forge.c:	    else if ( iron_magic >= ( ( ch->level * 3 ) * 3 / 2 ) )
forge.c:		level 					= ch->level;
forge.c:    		forged_golem->hit 			= number_range( ch->max_hit - 100, ch->max_hit + 100 );
forge.c:		if ( IS_SET( ch->guilds, MAJHERE ) )
forge.c:		    if ( race_table[ ch->race ][ ch->sex ].world == 0 )
forge.c:		    if ( race_table[ ch->race ][ ch->sex ].world == 1 )
forge.c:		    if ( race_table[ ch->race ][ ch->sex ].world == 0 )
forge.c:		    forged_golem->guilds		= ch->guilds;
forge.c:	    else if ( bronze_magic >= ( ( ch->level * 3 ) * 3 / 2 ) )
forge.c:		level 					= ch->level;
forge.c:    		forged_golem->hit 			= number_range( ch->max_hit - 100, ch->max_hit + 100 );
forge.c:		if ( IS_SET( ch->guilds, MAJHERE ) )
forge.c:		    if ( race_table[ ch->race ][ ch->sex ].world == 0 )
forge.c:		    if ( race_table[ ch->race ][ ch->sex ].world == 1 )
forge.c:		    if ( race_table[ ch->race ][ ch->sex ].world == 0 )
forge.c:		    forged_golem->guilds		= ch->guilds;
forge.c:	    else if ( ruby_magic >= ( ( ch->level * 3 ) * 3 / 2 ) )
forge.c:		level 					= ch->level;
forge.c:    		forged_golem->hit 			= number_range( ch->max_hit - 100, ch->max_hit + 100 );
forge.c:		if ( race_table[ ch->race ][ ch->sex ].world == 0 )
forge.c:		else if ( race_table[ ch->race ][ ch->sex ].world == 1 )
forge.c:		else if ( race_table[ ch->race ][ ch->sex ].world == 2 )
forge.c:	    else if ( sapphire_magic >= ( ( ch->level * 3 ) * 3 / 2 ) )
forge.c:		level 					= ch->level;
forge.c:    		forged_golem->hit 			= number_range( ch->max_hit - 100, ch->max_hit + 100 );
forge.c:		if ( race_table[ ch->race ][ ch->sex ].world == 0 )
forge.c:		else if ( race_table[ ch->race ][ ch->sex ].world == 1 )
forge.c:		else if ( race_table[ ch->race ][ ch->sex ].world == 2 )
forge.c:	    else if ( emerald_magic >= ( ( ch->level * 3 ) * 3 / 2 ) )
forge.c:		level 					= ch->level;
forge.c:    		forged_golem->hit 			= number_range( ch->max_hit - 100, ch->max_hit + 100 );
forge.c:		if ( race_table[ ch->race ][ ch->sex ].world == 0 )
forge.c:		else if ( race_table[ ch->race ][ ch->sex ].world == 1 )
forge.c:		else if ( race_table[ ch->race ][ ch->sex ].world == 2 )
forge.c:	    else if ( diamond_magic >= ( ( ch->level * 3 ) * 3 / 2 ) )
forge.c:		level 					= ch->level;
forge.c:    		forged_golem->hit 			= number_range( ch->max_hit - 100, ch->max_hit + 100 );
forge.c:		if ( race_table[ ch->race ][ ch->sex ].world == 0 )
forge.c:		else if ( race_table[ ch->race ][ ch->sex ].world == 1 )
forge.c:		else if ( race_table[ ch->race ][ ch->sex ].world == 2 )
forge.c:	    else if ( alabaster_magic >= ( ( ch->level * 3 ) * 3 / 2 ) )
forge.c:		level 					= ch->level;
forge.c:    		forged_golem->hit 			= number_range( ch->max_hit - 100, ch->max_hit + 100 );
forge.c:	    else if ( adamantite_magic >= ( ( ch->level * 3 ) * 3 / 2 ) )
forge.c:		level 					= ch->level;
forge.c:    		forged_golem->hit 			= number_range( ch->max_hit - 100, ch->max_hit + 100 );
forge.c:		if ( IS_SET( ch->guilds, MAJHERE ) )
forge.c:		    if ( race_table[ ch->race ][ ch->sex ].world == 0 )
forge.c:		    if ( race_table[ ch->race ][ ch->sex ].world == 1 )
forge.c:		    if ( race_table[ ch->race ][ ch->sex ].world == 0 )
forge.c:		    forged_golem->guilds		= ch->guilds;
forge.c:	    else if ( titanium_magic >= ( ( ch->level * 3 ) * 3 / 2 ) )
forge.c:		level 					= ch->level;
forge.c:    		forged_golem->hit 			= number_range( ch->max_hit - 100, ch->max_hit + 100 );
forge.c:		if ( IS_SET( ch->guilds, MAJHERE ) )
forge.c:		    if ( race_table[ ch->race ][ ch->sex ].world == 0 )
forge.c:		    if ( race_table[ ch->race ][ ch->sex ].world == 1 )
forge.c:		    if ( race_table[ ch->race ][ ch->sex ].world == 0 )
forge.c:		    forged_golem->guilds		= ch->guilds;
forge.c:	    else if ( obsidian_magic >= ( ( ch->level * 3 ) * 3 / 2 ) )
forge.c:		level 					= ch->level;
forge.c:    		forged_golem->hit 			= number_range( ch->max_hit - 100, ch->max_hit + 100 );
forge.c:		if ( IS_SET( ch->guilds, MAJHERE ) )
forge.c:		    if ( race_table[ ch->race ][ ch->sex ].world == 0 )
forge.c:		    if ( race_table[ ch->race ][ ch->sex ].world == 1 )
forge.c:		    if ( race_table[ ch->race ][ ch->sex ].world == 0 )
forge.c:		    forged_golem->guilds		= ch->guilds;
forge.c:	    else if ( mithril_magic >= ( ( ch->level * 3 ) * 3 / 2 ) )
forge.c:		level 					= ch->level;
forge.c:    		forged_golem->hit 			= number_range( ch->max_hit - 100, ch->max_hit + 100 );
forge.c:	    else if ( platinum_magic >= ( ( ch->level * 3 ) * 3 / 2 ) )
forge.c:		level 					= ch->level;
forge.c:    		forged_golem->hit 			= number_range( ch->max_hit - 100, ch->max_hit + 100 );
forge.c:		if ( IS_SET( ch->guilds, MAJHERE ) )
forge.c:		    if ( race_table[ ch->race ][ ch->sex ].world == 0 )
forge.c:		    if ( race_table[ ch->race ][ ch->sex ].world == 1 )
forge.c:		    if ( race_table[ ch->race ][ ch->sex ].world == 0 )
forge.c:		    forged_golem->guilds		= ch->guilds;
forge.c:	else if ( steel_magic >= ( ( ch->level * 3 ) * 2 / 3 ) )
forge.c:		level 					= ch->level;
forge.c:    		forged_golem->hit 			= number_range( ch->max_hit - 100, ch->max_hit + 100 );
forge.c:    if ( race_table[ ch->race ][ ch->sex ].world == 0 )
forge.c:    char_to_room( forged_golem, ch->in_room );
forge.c:	ch->pet = forged_golem;
forge.c:            strncpy( forged_golem->dislikes, ch->name,30 );
forge.c:            strncpy( forged_golem->hunting, ch->name,30 );
forge.c:    if ( !IS_SET( ch->in_room->room_flags, ROOM_FORGE ) )
forge.c:    for ( hammer = ch->carrying; hammer != NULL && !IS_SET( hammer->extra_flags, ITEM_HAMMER ); hammer = hammer->next_content );
forge.c:    if ( !IS_SET(ch->forge_flags, FORGE_COMPLETE ) )
forge.c:	SET_BIT(ch->forge_flags, IS_FORGING );
forge.c:	strncpy( ch->forge_item, arg, 10 );
forge.c:	ch->forge_from = 2;
forge.c:	ch->forge_count = 5;
forge.c:    REMOVE_BIT(ch->forge_flags, FORGE_COMPLETE );
forge.c:    steel_magic = ch->pcdata->forge[MINERAL_STEEL];
forge.c:    diamond_magic = ch->pcdata->forge[MINERAL_DIAMOND];
forge.c:    silver_magic = ch->pcdata->forge[MINERAL_SILVER];
forge.c:    sapphire_magic = ch->pcdata->forge[MINERAL_SAPPHIRE];
forge.c:    ruby_magic = ch->pcdata->forge[MINERAL_RUBY];
forge.c:    emerald_magic = ch->pcdata->forge[MINERAL_EMERALD];
forge.c:    mithril_magic = ch->pcdata->forge[MINERAL_MITHRIL];
forge.c:    obsidian_magic = ch->pcdata->forge[MINERAL_OBSIDIAN];
forge.c:    platinum_magic = ch->pcdata->forge[MINERAL_PLATINUM];
forge.c:    copper_magic = ch->pcdata->forge[MINERAL_COPPER];
forge.c:    iron_magic = ch->pcdata->forge[MINERAL_IRON];
forge.c:    bronze_magic = ch->pcdata->forge[MINERAL_BRONZE];
forge.c:    adamantite_magic = ch->pcdata->forge[MINERAL_ADAMANTITE];
forge.c:    titanium_magic = ch->pcdata->forge[MINERAL_TITANIUM];
forge.c:    alabaster_magic = ch->pcdata->forge[MINERAL_ALABASTER];
forge.c:			if ( number_range( 1, URANGE( 2, 200 - ( bonus + ch->level ), 200 ) ) == 1 )
forge.c:			if ( number_range( 1, URANGE( 2, 200 - ( bonus + ch->level ), 200 ) ) == 1 )
forge.c:			if ( number_range( 1, URANGE( 2, 200 - ( bonus + ch->level ), 200 ) ) == 1 )
forge.c:			if ( number_range( 1, URANGE( 2, 200 - ( bonus + ch->level ), 200 ) ) == 1 )
forge.c:			if ( number_range( 1, URANGE( 2, 200 - ( bonus + ch->level ), 200 ) ) == 1 )
forge.c:		    added = URANGE( 1, number_range( 2 * ch->level, skill * 3 ), 250 );
forge.c:		    if ( ( titanium_magic > 0 || number_range( 1, URANGE( 1, 200 - ( bonus + ch->level ), 200 ) ) == 1 ) && max2 < 1 && alabaster_magic >= ( steel_magic ) * 3 / 2 )
forge.c:		    	    added = URANGE( 1, number_range( 5 * ch->level, skill * 3 ), 250 );
forge.c:		    added = URANGE( 1, number_range( 5 * ch->level, skill * 2 ), 200 );
forge.c:		    if ( ( titanium_magic > 0 || number_range( 1, URANGE( 1, 200 - ( bonus + ch->level ), 200 ) ) == 1 ) && max2 < 1 && adamantite_magic >= ( steel_magic ) * 3 / 2 )
forge.c:    sprintf( name, " `Rforged by %s`w", ch->name );
forge.c:    if ( !IS_SET( ch->in_room->room_flags, ROOM_FORGE ) )
forge.c:    for ( hammer = ch->carrying; hammer != NULL && !IS_SET( hammer->extra_flags, ITEM_HAMMER ); hammer = hammer->next_content );
forge.c:    if ( !IS_SET(ch->forge_flags, FORGE_COMPLETE ) )
forge.c:	SET_BIT(ch->forge_flags, IS_FORGING );
forge.c:	strncpy( ch->forge_item, arg, 10 );
forge.c:	ch->forge_from = 1;
forge.c:	ch->forge_count = 5;
forge.c:    REMOVE_BIT(ch->forge_flags, FORGE_COMPLETE );
forge.c:    steel_magic = ch->pcdata->forge[MINERAL_STEEL];
forge.c:    diamond_magic = ch->pcdata->forge[MINERAL_DIAMOND];
forge.c:    silver_magic = ch->pcdata->forge[MINERAL_SILVER];
forge.c:    sapphire_magic = ch->pcdata->forge[MINERAL_SAPPHIRE];
forge.c:    ruby_magic = ch->pcdata->forge[MINERAL_RUBY];
forge.c:    emerald_magic = ch->pcdata->forge[MINERAL_EMERALD];
forge.c:    mithril_magic = ch->pcdata->forge[MINERAL_MITHRIL];
forge.c:    obsidian_magic = ch->pcdata->forge[MINERAL_OBSIDIAN];
forge.c:    platinum_magic = ch->pcdata->forge[MINERAL_PLATINUM];
forge.c:    copper_magic = ch->pcdata->forge[MINERAL_COPPER];
forge.c:    iron_magic = ch->pcdata->forge[MINERAL_IRON];
forge.c:    bronze_magic = ch->pcdata->forge[MINERAL_BRONZE];
forge.c:    adamantite_magic = ch->pcdata->forge[MINERAL_ADAMANTITE];
forge.c:    titanium_magic = ch->pcdata->forge[MINERAL_TITANIUM];
forge.c:    alabaster_magic = ch->pcdata->forge[MINERAL_ALABASTER];
forge.c:		    if ( ( titanium_magic > 0 || number_range( 1, URANGE( 1, 200 - ( bonus + ch->level ), 200 ) ) == 1 ) && max2 < 1 && silver_magic >= 20 )
forge.c:			if ( number_range( 1, URANGE( 2, 200 - ( bonus + ch->level ), 200 ) ) == 1 )
forge.c:			if ( number_range( 1, URANGE( 2, 200 - ( bonus + ch->level ), 200 ) ) == 1 )
forge.c:			if ( number_range( 1, URANGE( 2, 200 - ( bonus + ch->level ), 200 ) ) == 1 )
forge.c:		    if ( ( titanium_magic > 0 || number_range( 1, URANGE( 1, 200 - ( bonus + ch->level ), 200 ) ) == 1 ) && max2 < 1 && ruby_magic >= 20 )
forge.c:			if ( number_range( 1, URANGE( 2, 200 - ( bonus + ch->level ), 200 ) ) == 1 )
forge.c:		    if ( ( titanium_magic > 0 || number_range( 1, URANGE( 1, 200 - ( bonus + ch->level ), 200 ) ) == 1 ) && max2 < 1 && sapphire_magic >= 20 )
forge.c:			if ( number_range( 1, URANGE( 2, 200 - ( bonus + ch->level ), 200 ) ) == 1 )
forge.c:		    if ( ( titanium_magic > 0 || number_range( 1, URANGE( 1, 200 - ( bonus + ch->level ), 200 ) ) == 1 ) && max2 < 1 && emerald_magic >= 20 )
forge.c:		    added = URANGE( 1, number_range( 2 * ch->level, skill * 3 ), 250 );
forge.c:                if ( ( titanium_magic > 0 || number_range( 1, URANGE( 1, 200 - ( bonus + ch->level ), 200 ) ) == 1 ) && max2 < 1 && diamond_magic >= 20 )
forge.c:		    if ( ( titanium_magic > 0 || number_range( 1, URANGE( 1, 200 - ( bonus + ch->level ), 200 ) ) == 1 ) && max2 < 1 && alabaster_magic >= 20 )
forge.c:		    	    added = URANGE( 1, number_range( 5 * ch->level, skill * 5 ), 500 );
forge.c:		    added = URANGE( 1, number_range( 5 * ch->level, skill * 2 ), 200 );
forge.c:		    if ( ( titanium_magic > 0 || number_range( 1, URANGE( 1, 200 - ( bonus + ch->level ), 200 ) ) == 1 ) && max2 < 1 && adamantite_magic >= 20 )
forge.c:    sprintf( name, " `Rforged by %s`w", ch->name );
forge.c:    for ( kit = ch->carrying; kit != NULL && kit->pIndexData->vnum != OBJ_VNUM_EXTRACTING_KIT ; kit = kit->next_content );
forge.c:            if ( ch->in_room->area->world == 0 )
forge.c:		if ( ch->pcdata->minerals[MINERAL_PLATINUM] >= 1000 )
forge.c:		    ch->pcdata->minerals[MINERAL_PLATINUM] += 10;
forge.c:            else if ( ch->in_room->area->world == 1 )
forge.c:		if ( ch->pcdata->minerals[MINERAL_MITHRIL] >= 1000 )
forge.c:		    ch->pcdata->minerals[MINERAL_MITHRIL] += 10;
forge.c:            else if ( ch->in_room->area->world == 2 )
forge.c:		if ( ch->pcdata->minerals[MINERAL_OBSIDIAN] >= 1000 )
forge.c:		    ch->pcdata->minerals[MINERAL_OBSIDIAN] += 10;
forge.c:            if ( ch->pcdata->minerals[MINERAL_DIAMOND] >= 1000 )
forge.c:                ch->pcdata->minerals[MINERAL_DIAMOND] += 10;
forge.c:            if ( ch->pcdata->minerals[MINERAL_RUBY] >= 1000 )
forge.c:                ch->pcdata->minerals[MINERAL_RUBY] += 10;
forge.c:            	if ( ch->pcdata->minerals[MINERAL_GOLD] >= 1000 )
forge.c:                    ch->pcdata->minerals[MINERAL_GOLD] += 10;
forge.c:            	if ( ch->pcdata->minerals[MINERAL_SILVER] >= 1000 )
forge.c:                    ch->pcdata->minerals[MINERAL_SILVER] += 10;
forge.c:                if ( ch->pcdata->minerals[MINERAL_COPPER] >= 1000 )
forge.c:                    ch->pcdata->minerals[MINERAL_COPPER] += 10;
forge.c:                if ( ch->pcdata->minerals[MINERAL_IRON] >= 1000 )
forge.c:                    ch->pcdata->minerals[MINERAL_IRON] += 10;
forge.c:                if ( ch->pcdata->minerals[MINERAL_BRONZE] >= 1000 )
forge.c:                    ch->pcdata->minerals[MINERAL_BRONZE] += 10;
forge.c:            if ( ch->pcdata->minerals[MINERAL_STEEL] >= 1000 )
forge.c:                ch->pcdata->minerals[MINERAL_STEEL] += 10;
forge.c:            	if ( ch->pcdata->minerals[MINERAL_GOLD] >= 1000 )
forge.c:                    ch->pcdata->minerals[MINERAL_GOLD] += 10;
forge.c:            	if ( ch->pcdata->minerals[MINERAL_SILVER] >= 1000 )
forge.c:                    ch->pcdata->minerals[MINERAL_SILVER] += 10;
forge.c:                if ( ch->pcdata->minerals[MINERAL_COPPER] >= 1000 )
forge.c:                    ch->pcdata->minerals[MINERAL_COPPER] += 10;
forge.c:                if ( ch->pcdata->minerals[MINERAL_IRON] >= 1000 )
forge.c:                    ch->pcdata->minerals[MINERAL_IRON] += 10;
forge.c:                if ( ch->pcdata->minerals[MINERAL_BRONZE] >= 1000 )
forge.c:                    ch->pcdata->minerals[MINERAL_BRONZE] += 10;
forge.c:            if ( ch->pcdata->minerals[MINERAL_SAPPHIRE] >= 1000 )
forge.c:                ch->pcdata->minerals[MINERAL_SAPPHIRE] += 10;
forge.c:            if ( ch->pcdata->minerals[MINERAL_EMERALD] >= 1000 )
forge.c:                ch->pcdata->minerals[MINERAL_EMERALD] += 10;
forge.c:            	    if ( ch->pcdata->minerals[MINERAL_TITANIUM] >= 1000 )
forge.c:                	ch->pcdata->minerals[MINERAL_TITANIUM] += 10;
forge.c:                    if ( ch->pcdata->minerals[MINERAL_ADAMANTITE] >= 1000 )
forge.c:                        ch->pcdata->minerals[MINERAL_ADAMANTITE] += 10;
forge.c:                if ( ch->pcdata->minerals[MINERAL_ALABASTER] >= 1000 )
forge.c:                    ch->pcdata->minerals[MINERAL_ALABASTER] += 10;
forge.c:            if ( ch->in_room->area->world == 0 )
forge.c:		if ( ch->pcdata->minerals[MINERAL_PLATINUM] >= 1000 )
forge.c:		    ch->pcdata->minerals[MINERAL_PLATINUM] += 4;
forge.c:            else if ( ch->in_room->area->world == 1 )
forge.c:		if ( ch->pcdata->minerals[MINERAL_MITHRIL] >= 1000 )
forge.c:		    ch->pcdata->minerals[MINERAL_MITHRIL] += 4;
forge.c:            else if ( ch->in_room->area->world == 2 )
forge.c:		if ( ch->pcdata->minerals[MINERAL_OBSIDIAN] >= 1000 )
forge.c:		    ch->pcdata->minerals[MINERAL_OBSIDIAN] += 4;
forge.c:            if ( ch->pcdata->minerals[MINERAL_DIAMOND] >= 1000 )
forge.c:                ch->pcdata->minerals[MINERAL_DIAMOND] += 4;
forge.c:            if ( ch->pcdata->minerals[MINERAL_RUBY] >= 1000 )
forge.c:                ch->pcdata->minerals[MINERAL_RUBY] += 4;
forge.c:            	if ( ch->pcdata->minerals[MINERAL_GOLD] >= 1000 )
forge.c:                    ch->pcdata->minerals[MINERAL_GOLD] += 4;
forge.c:            	if ( ch->pcdata->minerals[MINERAL_SILVER] >= 1000 )
forge.c:                    ch->pcdata->minerals[MINERAL_SILVER] += 4;
forge.c:                if ( ch->pcdata->minerals[MINERAL_COPPER] >= 1000 )
forge.c:                    ch->pcdata->minerals[MINERAL_COPPER] += 4;
forge.c:                if ( ch->pcdata->minerals[MINERAL_IRON] >= 1000 )
forge.c:                    ch->pcdata->minerals[MINERAL_IRON] += 4;
forge.c:                if ( ch->pcdata->minerals[MINERAL_BRONZE] >= 1000 )
forge.c:                    ch->pcdata->minerals[MINERAL_BRONZE] += 4;
forge.c:            if ( ch->pcdata->minerals[MINERAL_STEEL] >= 1000 )
forge.c:                ch->pcdata->minerals[MINERAL_STEEL] += 4;
forge.c:            	if ( ch->pcdata->minerals[MINERAL_GOLD] >= 1000 )
forge.c:                    ch->pcdata->minerals[MINERAL_GOLD] += 4;
forge.c:            	if ( ch->pcdata->minerals[MINERAL_SILVER] >= 1000 )
forge.c:                    ch->pcdata->minerals[MINERAL_SILVER] += 4;
forge.c:                if ( ch->pcdata->minerals[MINERAL_COPPER] >= 1000 )
forge.c:                    ch->pcdata->minerals[MINERAL_COPPER] += 4;
forge.c:                if ( ch->pcdata->minerals[MINERAL_IRON] >= 1000 )
forge.c:                    ch->pcdata->minerals[MINERAL_IRON] += 4;
forge.c:                if ( ch->pcdata->minerals[MINERAL_BRONZE] >= 1000 )
forge.c:                    ch->pcdata->minerals[MINERAL_BRONZE] += 4;
forge.c:            if ( ch->pcdata->minerals[MINERAL_SAPPHIRE] >= 1000 )
forge.c:                ch->pcdata->minerals[MINERAL_SAPPHIRE] += 4;
forge.c:            if ( ch->pcdata->minerals[MINERAL_EMERALD] >= 1000 )
forge.c:                ch->pcdata->minerals[MINERAL_EMERALD] += 4;
forge.c:            	    if ( ch->pcdata->minerals[MINERAL_TITANIUM] >= 1000 )
forge.c:                	ch->pcdata->minerals[MINERAL_TITANIUM] += 4;
forge.c:                    if ( ch->pcdata->minerals[MINERAL_ADAMANTITE] >= 1000 )
forge.c:                        ch->pcdata->minerals[MINERAL_ADAMANTITE] += 4;
forge.c:                if ( ch->pcdata->minerals[MINERAL_ALABASTER] >= 1000 )
forge.c:                    ch->pcdata->minerals[MINERAL_ALABASTER] += 4;
forge.c:            if ( ch->in_room->area->world == 0 )
forge.c:		if ( ch->pcdata->minerals[MINERAL_PLATINUM] >= 1000 )
forge.c:		    ch->pcdata->minerals[MINERAL_PLATINUM] += 2;
forge.c:            else if ( ch->in_room->area->world == 1 )
forge.c:		if ( ch->pcdata->minerals[MINERAL_MITHRIL] >= 1000 )
forge.c:		    ch->pcdata->minerals[MINERAL_MITHRIL] += 2;
forge.c:            else if ( ch->in_room->area->world == 2 )
forge.c:		if ( ch->pcdata->minerals[MINERAL_OBSIDIAN] >= 1000 )
forge.c:		    ch->pcdata->minerals[MINERAL_OBSIDIAN] += 2;
forge.c:            if ( ch->pcdata->minerals[MINERAL_DIAMOND] >= 1000 )
forge.c:                ch->pcdata->minerals[MINERAL_DIAMOND] += 2;
forge.c:            if ( ch->pcdata->minerals[MINERAL_RUBY] >= 1000 )
forge.c:                ch->pcdata->minerals[MINERAL_RUBY] += 2;
forge.c:            	if ( ch->pcdata->minerals[MINERAL_GOLD] >= 1000 )
forge.c:                    ch->pcdata->minerals[MINERAL_GOLD] += 2;
forge.c:            	if ( ch->pcdata->minerals[MINERAL_SILVER] >= 1000 )
forge.c:                    ch->pcdata->minerals[MINERAL_SILVER] += 2;
forge.c:                if ( ch->pcdata->minerals[MINERAL_COPPER] >= 1000 )
forge.c:                    ch->pcdata->minerals[MINERAL_COPPER] += 2;
forge.c:                if ( ch->pcdata->minerals[MINERAL_IRON] >= 1000 )
forge.c:                    ch->pcdata->minerals[MINERAL_IRON] += 2;
forge.c:                if ( ch->pcdata->minerals[MINERAL_BRONZE] >= 1000 )
forge.c:                    ch->pcdata->minerals[MINERAL_BRONZE] += 2;
forge.c:            if ( ch->pcdata->minerals[MINERAL_STEEL] >= 1000 )
forge.c:                ch->pcdata->minerals[MINERAL_STEEL] += 2;
forge.c:            	if ( ch->pcdata->minerals[MINERAL_GOLD] >= 1000 )
forge.c:                    ch->pcdata->minerals[MINERAL_GOLD] += 2;
forge.c:            	if ( ch->pcdata->minerals[MINERAL_SILVER] >= 1000 )
forge.c:                    ch->pcdata->minerals[MINERAL_SILVER] += 2;
forge.c:                if ( ch->pcdata->minerals[MINERAL_COPPER] >= 1000 )
forge.c:                    ch->pcdata->minerals[MINERAL_COPPER] += 2;
forge.c:                if ( ch->pcdata->minerals[MINERAL_IRON] >= 1000 )
forge.c:                    ch->pcdata->minerals[MINERAL_IRON] += 2;
forge.c:                if ( ch->pcdata->minerals[MINERAL_BRONZE] >= 1000 )
forge.c:                    ch->pcdata->minerals[MINERAL_BRONZE] += 2;
forge.c:            if ( ch->pcdata->minerals[MINERAL_SAPPHIRE] >= 1000 )
forge.c:                ch->pcdata->minerals[MINERAL_SAPPHIRE] += 2;
forge.c:            if ( ch->pcdata->minerals[MINERAL_EMERALD] >= 1000 )
forge.c:                ch->pcdata->minerals[MINERAL_EMERALD] += 2;
forge.c:            	    if ( ch->pcdata->minerals[MINERAL_TITANIUM] >= 1000 )
forge.c:                	ch->pcdata->minerals[MINERAL_TITANIUM] += 2;
forge.c:                    if ( ch->pcdata->minerals[MINERAL_ADAMANTITE] >= 1000 )
forge.c:                        ch->pcdata->minerals[MINERAL_ADAMANTITE] += 2;
forge.c:                if ( ch->pcdata->minerals[MINERAL_ALABASTER] >= 1000 )
forge.c:                    ch->pcdata->minerals[MINERAL_ALABASTER] += 2;
forge.c:    if ( !IS_SET( ch->in_room->room_flags, ROOM_FORGE ) )
forge.c:    if ( amount < 0 && ch->pcdata->forge[mineral] < ( amount * -1 ) )
forge.c:	ch->pcdata->forge[mineral] += amount;
forge.c:	ch->pcdata->minerals[mineral] -= amount;
forge.c:    if ( amount > 0 && ch->pcdata->minerals[mineral] < amount )
forge.c:	ch->pcdata->forge[mineral] += amount;
forge.c:	ch->pcdata->minerals[mineral] -= amount;
forge.c:	sprintf( buf, "%-20s: %d\n\r", mineral_type_name( i ), ch->pcdata->minerals[i] );
forge.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_FORGE ) )
forge.c:	    sprintf( buf, "%-20s: %d\n\r", mineral_type_name( i ), ch->pcdata->forge[i] );
forge.c:	ch->pcdata->forge[i] = 0;
gamble.c:    for ( ch = pRoom->people ; ch != NULL ; ch = ch->next_in_room )
gamble.c:	if ( ch->pcdata == NULL )
gamble.c:	for ( card = ch->pcdata->discarded ; card != NULL ; card = card_next )
gamble.c:	for ( card = ch->pcdata->deck ; card != NULL ; card = card_next )
gamble.c:	for ( card = ch->pcdata->hand ; card != NULL ; card = card_next )
gamble.c:	for ( card = ch->pcdata->played ; card != NULL ; card = card_next )
gamble.c:	ch->pcdata->discarded = NULL;
gamble.c:	ch->pcdata->played = NULL;
gamble.c:	ch->pcdata->hand = NULL;
gamble.c:	ch->pcdata->deck = NULL;
gamble.c:    CARD_DATA * cards = ch->pcdata->hand;
gamble.c:    ch->pcdata->hand = NULL;
gamble.c:		    cards->next = ch->pcdata->hand;
gamble.c:		    ch->pcdata->hand = cards;
gamble.c:			card_next->next = ch->pcdata->hand;
gamble.c:			ch->pcdata->hand = card_next;
gamble.c:		    cards->next = ch->pcdata->hand;
gamble.c:		    ch->pcdata->hand = cards;
gamble.c:			card_next->next = ch->pcdata->hand;
gamble.c:			ch->pcdata->hand = card_next;
gamble.c:		    cards->next = ch->pcdata->hand;
gamble.c:		    ch->pcdata->hand = cards;
gamble.c:			card_next->next = ch->pcdata->hand;
gamble.c:			ch->pcdata->hand = card_next;
gamble.c:    if ( ch->pcdata == NULL )
gamble.c:	if ( ch->pcdata->deck == NULL )
gamble.c:	clear_deck( ch->in_room );
gamble.c:    for ( victim = ch->in_room->people ; victim != NULL ; victim = victim->next_in_room )
gamble.c:	if ( ch->pcdata->deck == NULL )
gamble.c:	    card->next = ch->pcdata->deck;
gamble.c:	    ch->pcdata->deck = card;
gamble.c:    clear_deck( ch->in_room );
gamble.c:		    card->next = ch->pcdata->deck;
gamble.c:		    ch->pcdata->deck = card;
gamble.c:		    card->next = ch->pcdata->deck;
gamble.c:		    ch->pcdata->deck = card;
gamble.c:    if ( ch->pcdata == NULL || ch->pcdata->deck == NULL )
gamble.c:    for ( card = ch->pcdata->deck ; card != NULL ; card = card->next )
gamble.c:	if ( ch->pcdata->deck == NULL )
gamble.c:	delt = ch->pcdata->deck;
gamble.c:	for ( card = ch->pcdata->deck ; card != NULL ; card = card_next )
gamble.c:	if ( delt == ch->pcdata->deck )
gamble.c:	    ch->pcdata->deck = delt->next;
gamble.c:	    for ( card = ch->pcdata->deck ; card != NULL && card->next != delt; card = card->next );
gamble.c:	    delt->next = ch->pcdata->discarded;
gamble.c:	    ch->pcdata->discarded = delt;
gamble.c:    if ( ch->pcdata == NULL || ch->pcdata->hand == NULL )
gamble.c:    for ( victim = ch->in_room->people ; victim != NULL && ( victim->pcdata == NULL || ( victim->pcdata->deck == NULL && victim->pcdata->discarded == NULL ) ) ; victim = victim->next_in_room );
gamble.c:	delt->next = ch->pcdata->hand;
gamble.c:	ch->pcdata->hand = delt;
gamble.c:	    card->next = ch->pcdata->hand;
gamble.c:	    ch->pcdata->hand = card;
gamble.c:   if ( ch->pcdata == NULL || ch->pcdata->hand == NULL )
gamble.c:    if ( ch->pcdata == NULL || ch->pcdata->hand == NULL )
gamble.c:	    for ( cards = ch->pcdata->hand ; cards != NULL && card != 0 ; cards = cards->next )
gamble.c:    while( selected[ card  ] && ch->pcdata->hand != NULL )
gamble.c:	discard = ch->pcdata->hand;
gamble.c:	ch->pcdata->hand = discard->next;
gamble.c:    for ( cards = ch->pcdata->hand ; cards != NULL ; cards = card_next )
gamble.c:        for ( victim = ch->in_room->people ; victim != NULL && ( victim->pcdata == NULL || ( victim->pcdata->deck == NULL && victim->pcdata->discarded == NULL ) ) ; victim = victim->next_in_room );
gamble.c:	cards->next = ch->pcdata->played;
gamble.c:	ch->pcdata->played = played;
gamble.c:    if ( ( ch->pcdata == NULL || ch->pcdata->hand == NULL )
gamble.c:    for ( victim = ch->in_room->people ; victim != NULL && ( victim->pcdata == NULL || ( victim->pcdata->deck == NULL && victim->pcdata->discarded == NULL ) ) ; victim = victim->next_in_room );
gamble.c:	    for ( cards = ch->pcdata->hand ; cards != NULL && card != 0 ; cards = cards->next )
gamble.c:	    for ( cards = ch->pcdata->played ; cards != NULL && card != 0 ; cards = cards->next )
gamble.c:    while( selected[ card  ] && ch->pcdata->hand != NULL )
gamble.c:	discard = ch->pcdata->hand;
gamble.c:	ch->pcdata->hand = discard->next;
gamble.c:    for ( cards = ch->pcdata->hand ; cards != NULL ; cards = card_next )
gamble.c:    while( selected[ card  ] && ch->pcdata->played != NULL )
gamble.c:	discard = ch->pcdata->played;
gamble.c:	ch->pcdata->played = discard->next;
gamble.c:    for ( cards = ch->pcdata->played ; cards != NULL ; cards = card_next )
gamble.c:    if ( ch->pcdata == NULL || ch->pcdata->hand == NULL )
gamble.c:	    for ( cards = ch->pcdata->hand ; cards != NULL && card != 0 ; cards = cards->next )
gamble.c:	    for ( cards = ch->pcdata->played ; cards != NULL && card != 0 ; cards = cards->next )
gamble.c:    while( selected[ card  ] && ch->pcdata->hand != NULL )
gamble.c:	discard = ch->pcdata->hand;
gamble.c:	ch->pcdata->hand = discard->next;
gamble.c:    for ( cards = ch->pcdata->hand ; cards != NULL ; cards = card_next )
gamble.c:    while( selected[ card  ] && ch->pcdata->played != NULL )
gamble.c:	discard = ch->pcdata->played;
gamble.c:	ch->pcdata->played = discard->next;
gamble.c:    for ( cards = ch->pcdata->played ; cards != NULL ; cards = card_next )
gamble.c:        if ( ch->pcdata == NULL )
gamble.c:	if ( ch->pcdata->hand != NULL )
gamble.c:            send_to_char( format_cards( ch->pcdata->hand ), ch );
gamble.c:	if ( ch->pcdata->played != NULL )
gamble.c:	    send_to_char( format_cards( ch->pcdata->played ), ch );
gamble.c:    coin_type = ( *argument == '\0' ? ch->in_room->area->world : get_coin_type( argument ) );
gamble.c:    if ( value > ch->gold[ coin_type ] )
gamble.c:	    ch->gold[ coin_type ] += value;
gamble.c:	ch->gold[ coin_type ] += value;
gamble.c:	ch->gold[ coin_type ] -= value;
gamble.c:	if ( horse_race_list[ i ].in_room == ch->in_room->vnum )
gamble.c:	if ( horse_race_list[ i ].in_room == ch->in_room->vnum )
gamble.c:	coin_type = ch->in_room->area->world;
gamble.c:    if ( ch->gold[ coin_type ] < amount )
gamble.c:    ch->gold[ coin_type ] -= amount;
gamble.c:	if ( horse_race_list[ i ].in_room == ch->in_room->vnum )
gamble.c:		    ch->gold[ bets->coin_type ] += ( ( ( long ) ( bets->odds ) + 1 ) * bets->amount );
gedit.c:        ch->desc->pEdit = NULL;
gedit.c:        ch->desc->connected = CON_PLAYING;
gedit.c:	ch->edit_menu = 0;
gedit.c:	ch->edit_buffer[0] = '\0';
gedit.c:		ch->edit_menu = GEDIT_MENU ;
gedit.c:		ch->edit_buffer[0] = '\0';
gedit.c:		ch->edit_menu = GEDIT_MENU ;
gedit.c:		ch->edit_buffer[0] = '\0';
gedit.c:		ch->edit_menu = GEDIT_MENU ;
gedit.c:		ch->edit_buffer[0] = '\0';
gedit.c:	if (ch->edit_menu > 2 )
gedit.c:	ch->edit_menu = GEDIT_GLOBAL ;
gedit.c:	strncpy( ch->edit_buffer, "Global->", 80 );
gedit.c:	ch->edit_menu = GEDIT_WORLD ;
gedit.c:	strncpy( ch->edit_buffer, "World->", 80 );
gedit.c:	ch->edit_menu = GEDIT_AREA ;
gedit.c:	strncpy( ch->edit_buffer, "Area->", 80 );
gedit.c:	    if ( ch->edit_menu > 2 )
gedit.c:	    	if ( ch->edit_menu == GEDIT_GLOBAL )
gedit.c:	    	if ( ch->edit_menu == GEDIT_WORLD )
gedit.c:	    	    random->world = ch->in_room->area->world;
gedit.c:	    	if ( ch->edit_menu == GEDIT_AREA )
gedit.c:	    	    random->area = ch->in_room->area->vnum;
gedit.c:	    if ( ch->edit_menu > 2 )
gedit.c:	    if ( ch->edit_menu > 2 )
gedit.c:	    if ( ch->edit_menu > 2 )
gedit.c:	    if ( ch->edit_menu > 2 )
gedit.c:		    if ( ch->edit_menu == GEDIT_GLOBAL && random->global > 0 )
gedit.c:		    if ( ch->edit_menu == GEDIT_WORLD && random->world == ch->in_room->area->world )
gedit.c:		    if ( ch->edit_menu == GEDIT_AREA && random->area == ch->in_room->area->vnum ) 
gedit.c:	    if ( ch->edit_menu > 2 )
gedit.c:    ch->desc->connected = CON_GEDITOR;
gedit.c:    ch->edit_menu	= GEDIT_MENU;
gedit.c:    ch->edit_buffer[0] = '\0';
generate.c:	newarea->dungeon_data->level = ch->level;
generate.c:    		    	make_exit( pRoomIndex, ch->in_room, 4 );
generate.c:	if ( ch->in_room->exit[5] != NULL )
generate.c:    	    free_exit(ch->in_room->exit[5]);
generate.c:	SET_BIT( ch->in_room->room_flags, ROOM_NO_MOB );
generate.c:    	ch->in_room->exit[5] = NULL;
generate.c:    	make_exit(ch->in_room, pRoomIndex, 5 );
generate.c:    		    	make_exit( pRoomIndex, ch->in_room, 2 );
generate.c:    		    	make_exit( pRoomIndex, ch->in_room, 3 );
generate.c:    		    	make_exit( pRoomIndex, ch->in_room, 0 );
generate.c:    		    	make_exit( pRoomIndex, ch->in_room, 1 );
generate.c:    		    	make_exit( pRoomIndex, ch->in_room, 4 );
generate.c:	if ( ch->in_room->exit[dir] != NULL )
generate.c:    	    free_exit(ch->in_room->exit[dir]);
generate.c:	SET_BIT( ch->in_room->room_flags, ROOM_NO_MOB );
generate.c:    	ch->in_room->exit[dir] = NULL;
generate.c:    	make_exit(ch->in_room, pRoomIndex, dir );
handler.c:    for ( char_quests = ch->char_quests ; char_quests != NULL ; char_quests = char_quests->next )
handler.c:	char_quests->next = ch->char_quests;
handler.c:	ch->char_quests = char_quests;
handler.c:    ch->quest_points += points;
handler.c:        tracks->room = ch->in_room;
handler.c:    max_number = ch->in_room->area->uvnum - ch->in_room->area->lvnum;
handler.c:        number = number_range(ch->in_room->area->lvnum, ch->in_room->area->uvnum );
handler.c:        level = UMAX( 1, ch->level - 8 + number_range( 1 , 8 ) );
handler.c:    sprintf( buf, "`wA creature of `Kdarkness`w is here stalking %s.\n\r", ch->name );
handler.c:    mob->guilds = ch->guilds;
handler.c:        mob->perm_stat[i] = ch->perm_stat[i];
handler.c:    strncpy(mob->hunting, ch->name,30);
handler.c:    if ( ch->pcdata->debt->timer == 3 )
handler.c:	level = ch->level - 5;
handler.c:	level = ch->level + ch->pcdata->debt->timer - 5;
handler.c:    sprintf( buf, "%s the thug is trying to collect a debt from %s.", name, ch->name );
handler.c:    in_room = get_room_index( ch->pcdata->debt->vnum );
handler.c:	ch->name, 
handler.c:    strncpy(mob->hunting, ch->name,30);
handler.c:    if ( ( in_room = get_room_index( ch->pcdata->debt->vnum ) ) == NULL )
handler.c:    if ( ch->pcdata == NULL || ch->pcdata->debt == NULL )
handler.c:    debt = ch->pcdata->debt;
handler.c:    time = debt->due - ch->played + ch->logon - current_time;
handler.c:	if ( ch->fighting != NULL )
handler.c:	if ( ch->fighting != NULL )
handler.c:	if ( ch->fighting != NULL )
handler.c:	if ( ch->fighting != NULL )
handler.c:	in_room = get_room_index( ch->pcdata->debt->vnum );
handler.c:	strncpy( pnote->to_list, ch->name, 80 );
handler.c:	capitalize(ch->name),
handler.c:	if (IS_SET(ch->res_flags, RES_WEAPON) && IS_SET(ch->vuln_flags, VULN_WEAPON) && !IS_SET(ch->imm_flags, IMM_WEAPON))
handler.c:	else if (IS_SET(ch->imm_flags,IMM_WEAPON))
handler.c:	else if (IS_SET(ch->res_flags,RES_WEAPON))
handler.c:	else if (IS_SET(ch->vuln_flags,VULN_WEAPON))
handler.c:	if (IS_SET(ch->res_flags, RES_MAGIC) && IS_SET(ch->vuln_flags, VULN_MAGIC) && !IS_SET(ch->imm_flags, IMM_MAGIC))
handler.c:	else if (IS_SET(ch->imm_flags,IMM_MAGIC))
handler.c:	else if (IS_SET(ch->res_flags,RES_MAGIC))
handler.c:	else if (IS_SET(ch->vuln_flags,VULN_MAGIC))
handler.c:    if (IS_SET(ch->res_flags, bit_res) && IS_SET(ch->vuln_flags, bit_vuln) && !IS_SET(ch->imm_flags, bit_imm))
handler.c:    else if (IS_SET(ch->imm_flags,bit_imm))
handler.c:    else if (IS_SET(ch->res_flags,bit_res))
handler.c:    else if (IS_SET(ch->vuln_flags,bit_vuln))
handler.c:	pRoomIndex = get_room_index(ch->in_room->vnum);
handler.c:    	for ( vch = ch->in_room->people; vch != NULL; vch = ch_next )
handler.c:            ch_next = vch->next_in_room;
handler.c:    if ( IS_NPC(ch) && ch->guilds <= 1 )
handler.c:	cost *= race_table[ ch->race ][ ch->sex ].skill_level[ sn ];
handler.c:    if ( ch->guilds == 1 && !IS_NPC(ch) )
handler.c:	cost *= race_table[ ch->race ][ ch->sex ].skill_level[ sn ];
handler.c:	if ( !IS_SET( ch->guilds, guild_table[ guild ].flag) || ch->guilds <= 1 )
handler.c:    cost *= race_table[ ch->race ][ ch->sex ].skill_level[ sn ];
handler.c:    for ( skills = ch->innate_skills ; skills != NULL ; skills = skills->next )
handler.c:    if ( ch->guilds <= 1 )
handler.c:	if ( !IS_SET( ch->guilds, guild_table[ guild ].flag) || ch->guilds <= 1 )
handler.c:    if ( ch->guilds <= 1 )
handler.c:	cost *= race_table[ ch->race ][ ch->sex ].rating[ sn ];
handler.c:	if ( !IS_SET( ch->guilds, guild_table[ guild ].flag ) || ch->guilds <= 1 )
handler.c:    cost *= race_table[ ch->race ][ ch->sex ].rating[ sn ];
handler.c:	if ( !IS_SET( ch->guilds, guild_table[ guild ].flag ) )
handler.c:    if ( ch->level < 10)
handler.c:	cost = 10 * ch->level;
handler.c:    if ( ch->guilds < 1 )
handler.c:	if ( !IS_SET( ch->guilds, guild_table[ guild ].flag ) || ch->guilds < 1 )
handler.c:    if ( ch->level > 40 )
handler.c:	cost *= get_skill_cost( ch, sn) * 1000 / 10 * ch->level; 
handler.c:    else if ( ch->level > 20 )
handler.c:	cost *= get_skill_cost( ch, sn) * 350  / 10 * ch->level; 
handler.c:    else if ( ch->level >= 10 )
handler.c:    	cost *= get_skill_cost( ch, sn) * 75 / 10 * ch->level; 
handler.c:	if ( !IS_SET( ch->guilds, guild_table[ guild ].flag ) || ch->guilds <= 1 )
handler.c:	skill = ch->level * 5 / 2;
handler.c:		if (  ch->pcdata->learned[ sn ] < 1 )
handler.c:	    		skill = ch->pcdata->learned[sn] + ch->pcdata->skill_mod[sn];
handler.c:	for ( skills = ch->innate_skills ; skills != NULL ; skills = skills->next )
handler.c:	    for ( skills = ch->skills ; skills != NULL ; skills = skills->next )
handler.c: 	if (sn == gsn_trip && IS_SET(ch->off_flags,OFF_TRIP))
handler.c:	    skill = 10 + 3 * ch->level;
handler.c: 	else if (sn == gsn_bash && IS_SET(ch->off_flags,OFF_BASH))
handler.c:	    skill = 10 + 3 * ch->level;
handler.c: 	else if (sn == gsn_breathfire && IS_SET(ch->off_flags,OFF_BREATHFIRE) )
handler.c:	    skill = 10 + 3 * ch->level;
handler.c:	else if (sn == gsn_disarm && IS_SET(ch->off_flags,OFF_DISARM) )
handler.c:	    skill = 20 + 3 * ch->level;
handler.c:	else if (sn == gsn_berserk && IS_SET(ch->off_flags,OFF_BERSERK))
handler.c:	    skill = 3 * ch->level;
handler.c:	    skill = race_table[ ch->race ][ ch->sex ].adept[ sn ];
handler.c:           skill = URANGE( 40, 40 + ( ch->level * 3 / 2 ), 100 );
handler.c:	else if ( get_skill_level(ch, sn) <= ch->level )
handler.c:   	   skill = URANGE(40, 40 + ( ch->level * 3 / 2 ), 100 );
handler.c:	    skill = UMIN( 100, 40 + ch->level * 8 );
handler.c:	    skill += URANGE( 0, ( ch->level - 12 ) * 8, 100 );
handler.c:	    skill = UMIN( 100, 40 + ch->level * 8 );
handler.c:	    skill += URANGE( 0, ( ch->level - 12 ) * 8, 100 );
handler.c:	return ( ch->hands_free == 2 ? skill : ( ch->hands_free == 1 ? UMIN( 150, skill ) : UMIN( 50, skill ) ) );
handler.c:	return ( ch->hands_free == 2 ? skill : ( ch->hands_free == 1 ? UMIN( 150, skill ) : UMIN( 50, skill ) ) );
handler.c:    ch->desc->pString = NULL;
handler.c:    if (ch->pcdata->perm_hit == 0 
handler.c:    ||	ch->pcdata->perm_mana[0] == 0
handler.c:    ||	ch->pcdata->perm_mana[1] == 0
handler.c:    ||	ch->pcdata->perm_mana[2] == 0
handler.c:    ||	ch->pcdata->perm_mana[3] == 0
handler.c:    ||	ch->pcdata->perm_mana[4] == 0
handler.c:    ||  ch->pcdata->perm_move == 0
handler.c:    ||	ch->pcdata->last_level == 0)
handler.c:                    case APPLY_SEX:     ch->sex         -= mod;         break;
handler.c:		        ch->max_mana[i]    -= mod;
handler.c:    case APPLY_MANA_FIRE:	ch->max_mana[ ELEMENT_FIRE ]	-= mod; break;
handler.c:    case APPLY_MANA_WATER:	ch->max_mana[ ELEMENT_WATER ]	-= mod; break;
handler.c:    case APPLY_MANA_EARTH:	ch->max_mana[ ELEMENT_EARTH ]	-= mod; break;
handler.c:    case APPLY_MANA_WIND:	ch->max_mana[ ELEMENT_WIND ]	-= mod; break;
handler.c:    case APPLY_MANA_SPIRIT:	ch->max_mana[ ELEMENT_SPIRIT ]	-= mod; break;
handler.c:                    case APPLY_HIT:     ch->max_hit     -= mod;         break;
handler.c:                    case APPLY_MOVE:    ch->max_move    -= mod;         break;
handler.c:	ch->pcdata->perm_hit 	= ch->max_hit;
handler.c:	    ch->pcdata->perm_mana[i] 	= ch->max_mana[i];
handler.c:	ch->pcdata->perm_move	= ch->max_move;
handler.c:	ch->pcdata->last_level	= ch->played/3600;
handler.c:	if (ch->pcdata->true_sex < 1 || ch->pcdata->true_sex > 3)
handler.c:	    if (ch->sex > 1 && ch->sex < 4)
handler.c:	        ch->pcdata->true_sex	= ch->sex;
handler.c:	    	ch->pcdata->true_sex 	= 1;
handler.c:    if ( ch->birth_day == 0 || ch->birth_month == 0 )
handler.c:	ch->birth_day = number_range( 1, time_table[ race_table[ ch->race ][ ch->sex ].world ].days_month );
handler.c:	ch->birth_month = number_range( 1, time_table[ race_table[ ch->race ][ ch->sex ].world ].months_year );
handler.c:	ch->mod_stat[stat] = 0;
handler.c:    ch->hands_free = 2;
handler.c:    if (ch->pcdata->true_sex < 1 || ch->pcdata->true_sex > 3)
handler.c:	ch->pcdata->true_sex = 1; 
handler.c:    ch->sex		= ch->pcdata->true_sex;
handler.c:    ch->max_hit 	= ch->pcdata->perm_hit;
handler.c:        ch->max_mana[i] = ch->pcdata->perm_mana[i];
handler.c:    ch->max_move	= ch->pcdata->perm_move;
handler.c:    ch->armor	= 100;
handler.c:    ch->hitroll		= 0;
handler.c:    ch->damroll		= 0;
handler.c:    ch->saving_throw	= 0;
handler.c:    ch->pcdata->dreams	= 0;
handler.c:    ch->pcdata->nightmares	= 0;
handler.c:	    ch->hands_free--;
handler.c:	    ch->hands_free--;
handler.c:	    ch->hands_free=0;
handler.c:	    ch->hands_free--;
handler.c:	    ch->hands_free--;
handler.c:	ch->armor -= obj->wear_data->ac;
handler.c:                case APPLY_STR:         ch->mod_stat[STAT_STR]  += mod; break;
handler.c:                case APPLY_DEX:         ch->mod_stat[STAT_DEX]  += mod; break;
handler.c:                case APPLY_INT:         ch->mod_stat[STAT_INT]  += mod; break;
handler.c:                case APPLY_WIS:         ch->mod_stat[STAT_WIS]  += mod; break;
handler.c:                case APPLY_CON:         ch->mod_stat[STAT_CON]  += mod; break;
handler.c:                case APPLY_CHR:         ch->mod_stat[STAT_CHR]  += mod; break;
handler.c:                case APPLY_SEX:         ch->sex                 += mod; break;
handler.c:	            ch->max_mana[i]         += mod; 
handler.c:    		case APPLY_MANA_FIRE:	ch->max_mana[ ELEMENT_FIRE ]	+= mod; break;
handler.c:    		case APPLY_MANA_WATER:	ch->max_mana[ ELEMENT_WATER ]	+= mod; break;
handler.c:    		case APPLY_MANA_EARTH:	ch->max_mana[ ELEMENT_EARTH ]	+= mod; break;
handler.c:    		case APPLY_MANA_WIND:	ch->max_mana[ ELEMENT_WIND ]	+= mod; break;
handler.c:    		case APPLY_MANA_SPIRIT:	ch->max_mana[ ELEMENT_SPIRIT ]	+= mod; break;
handler.c:    		case APPLY_HIT:         	ch->max_hit             += mod; break;
handler.c:    		case APPLY_MOVE:        	ch->max_move            += mod; break;
handler.c:    		case APPLY_DREAMS:		ch->pcdata->dreams	+= mod; break; 
handler.c:    		case APPLY_NIGHTMARES:	ch->pcdata->nightmares  += mod; break;
handler.c:    		case APPLY_AC:		ch->armor 		+= mod; break;
handler.c:    		case APPLY_HITROLL:     	ch->hitroll             += mod; break;
handler.c:    		case APPLY_DAMROLL:     	ch->damroll             += mod; break;
handler.c:    		case APPLY_SAVING_SPELL:    ch->saving_throw 	+= mod; break;
handler.c:    for (af = ch->affected; af != NULL; af = af->next)
handler.c:                case APPLY_STR:         ch->mod_stat[STAT_STR]  += mod; break;
handler.c:                case APPLY_DEX:         ch->mod_stat[STAT_DEX]  += mod; break;
handler.c:                case APPLY_INT:         ch->mod_stat[STAT_INT]  += mod; break;
handler.c:                case APPLY_WIS:         ch->mod_stat[STAT_WIS]  += mod; break;
handler.c:                case APPLY_CON:         ch->mod_stat[STAT_CON]  += mod; break;
handler.c:                case APPLY_CHR:         ch->mod_stat[STAT_CHR]  += mod; break;
handler.c:                case APPLY_SEX:         ch->sex                 += mod; break;
handler.c:	            ch->max_mana[i]         += mod; 
handler.c:    		case APPLY_MANA_FIRE:	ch->max_mana[ ELEMENT_FIRE ]	+= mod; break;
handler.c:    		case APPLY_MANA_WATER:	ch->max_mana[ ELEMENT_WATER ]	+= mod; break;
handler.c:    		case APPLY_MANA_EARTH:	ch->max_mana[ ELEMENT_EARTH ]	+= mod; break;
handler.c:    		case APPLY_MANA_WIND:	ch->max_mana[ ELEMENT_WIND ]	+= mod; break;
handler.c:    		case APPLY_MANA_SPIRIT:	ch->max_mana[ ELEMENT_SPIRIT ]	+= mod; break;
handler.c:                case APPLY_HIT:         ch->max_hit             += mod; break;
handler.c:                case APPLY_MOVE:        ch->max_move            += mod; break;
handler.c: 		case APPLY_DREAMS:	ch->pcdata->dreams	+= mod; break; 
handler.c:		case APPLY_NIGHTMARES:	ch->pcdata->nightmares  += mod; break;
handler.c:                case APPLY_AC:		ch->armor		+= mod; break;
handler.c:                case APPLY_HITROLL:     ch->hitroll             += mod; break;
handler.c:                case APPLY_DAMROLL:     ch->damroll             += mod; break;
handler.c:                case APPLY_SAVING_SPELL:        ch->saving_throw += mod; break;
handler.c:    if (ch->sex < 1 || ch->sex > 3)
handler.c:	ch->sex = ch->pcdata->true_sex;
handler.c:    starting = race_table[ ch->race ][ ch->sex ].start_age;
handler.c:    rate = UMAX( 1 , race_table[ ch->race ][ ch->sex ].year_per_hour * 18000 );
handler.c:    current = current_time - ch->logon + ch->played;
handler.c:    return URANGE(3,ch->perm_stat[stat] + ch->mod_stat[stat], 25 );
handler.c:    max = race_table[ch->race][ch->sex].max_stats[stat];
handler.c:    if ( IS_NPC(ch) && IS_SET(ch->act, ACT_PET) )
handler.c:    if ( IS_NPC(ch) && IS_SET(ch->act, ACT_PET) )
handler.c:    for ( char_quests = ch->char_quests ; char_quests != NULL; char_quests = char_quests->next )
handler.c:        for ( char_quests_pre = ch->char_quests ; char_quests_pre != NULL; char_quests_pre = char_quests_pre->next )
handler.c:	&& ( ch->pIndexData->vnum == trig->mob_vnum || trig->mob_vnum == 0 ) )
handler.c:		SET_BIT( ch->spell_flags, SPELL_PROTECTION );
handler.c:		REMOVE_BIT( ch->spell_flags, SPELL_PROTECTION );
handler.c:		SET_BIT( ch->spell_flags, SPELL_SHIELD );
handler.c:		REMOVE_BIT( ch->spell_flags, SPELL_SHIELD );
handler.c:    	    	if (IS_SET(ch->pcdata->perm_aff, paf->bitvector ) )
handler.c:		SET_BIT( ch->affected_by, paf->bitvector );
handler.c:		REMOVE_BIT( ch->affected_by, paf->bitvector );
handler.c:    	    	if (IS_SET(ch->pcdata->perm_aff_2, paf->bitvector ) )
handler.c:		SET_BIT( ch->affected_by_2, paf->bitvector );
handler.c:		REMOVE_BIT( ch->affected_by_2, paf->bitvector );
handler.c:		SET_BIT( ch->imm_flags, paf->bitvector );
handler.c:		REMOVE_BIT( ch->imm_flags, paf->bitvector );
handler.c:		ch->imm_flags |= ch->perm_imm;
handler.c:		SET_BIT( ch->res_flags, paf->bitvector );
handler.c:		REMOVE_BIT( ch->res_flags, paf->bitvector );
handler.c:		ch->res_flags |= ch->perm_res;
handler.c:		SET_BIT( ch->vuln_flags, paf->bitvector );
handler.c:		REMOVE_BIT( ch->vuln_flags, paf->bitvector );
handler.c:		ch->vuln_flags |= ch->perm_vuln;
handler.c:    case APPLY_STR:           ch->mod_stat[STAT_STR]	+= mod;	break;
handler.c:    case APPLY_DEX:           ch->mod_stat[STAT_DEX]	+= mod;	break;
handler.c:    case APPLY_INT:           ch->mod_stat[STAT_INT]	+= mod;	break;
handler.c:    case APPLY_WIS:           ch->mod_stat[STAT_WIS]	+= mod;	break;
handler.c:    case APPLY_CON:           ch->mod_stat[STAT_CON]	+= mod;	break;
handler.c:    case APPLY_CHR:           ch->mod_stat[STAT_CHR]	+= mod;	break;
handler.c:    case APPLY_SEX:           ch->sex			+= mod;	break;
handler.c:          ch->max_mana[i]		+= mod;	
handler.c:    case APPLY_MANA_FIRE:	ch->max_mana[ ELEMENT_FIRE ]	+= mod; break;
handler.c:    case APPLY_MANA_WATER:	ch->max_mana[ ELEMENT_WATER ]	+= mod; break;
handler.c:    case APPLY_MANA_EARTH:	ch->max_mana[ ELEMENT_EARTH ]	+= mod; break;
handler.c:    case APPLY_MANA_WIND:	ch->max_mana[ ELEMENT_WIND ]	+= mod; break;
handler.c:    case APPLY_MANA_SPIRIT:	ch->max_mana[ ELEMENT_SPIRIT ]	+= mod; break;
handler.c:    case APPLY_HIT:           ch->max_hit		+= mod; break;
handler.c:    case APPLY_MOVE:          ch->max_move		+= mod;	break;
handler.c:    case APPLY_AC:	      ch->armor			+= mod; break;
handler.c:    case APPLY_HITROLL:       ch->hitroll		+= mod;	break;
handler.c:    case APPLY_DAMROLL:       ch->damroll		+= mod;	break;
handler.c:    case APPLY_SAVING_SPELL:  ch->saving_throw		+= mod;	break;
handler.c:	ch->pcdata->dreams	+= mod; break;
handler.c:	ch->pcdata->nightmares    += mod; break;
handler.c:    if (ch->in_room != NULL) /* Char could be Quiting at this point */
handler.c:    if ( fAdd && IS_SET( paf->bitvector, AFF_BREATHE_UNDERWATER ) && IS_SET( ch->affected_by, AFF_HOLD_BREATH ) )
handler.c:    if ( ch->in_room )
handler.c:    if ( !IS_UNDERWATER( ch ) && IS_SET( ch->affected_by, AFF_HOLD_BREATH ) )
handler.c:	    obj_to_room( wield, ch->in_room );
handler.c:    paf_new->next	= ch->affected;
handler.c:    ch->affected	= paf_new;
handler.c:    if ( ch->affected == NULL )
handler.c:    if ( paf == ch->affected )
handler.c:	ch->affected	= paf->next;
handler.c:	for ( prev = ch->affected; prev != NULL; prev = prev->next )
handler.c:    for ( paf = ch->affected; paf != NULL; paf = paf_next )
handler.c:    for ( paf = ch->affected; paf != NULL; paf = paf->next )
handler.c:    if ( IS_SET( ch->affected_by, spell_affect_bit( sn ) ) )
handler.c:    for ( paf = ch->affected; paf != NULL; paf = paf->next )
handler.c:    if ( IS_SET( ch->affected_by_2, spell_affect_bit_2( sn ) ) )
handler.c:    for ( paf = ch->affected; paf != NULL; paf = paf->next )
handler.c:    for ( paf_old = ch->affected; paf_old != NULL; paf_old = paf_old->next )
handler.c:  for (obj=ch->carrying; obj!=NULL;obj=next_obj)
handler.c:  for (obj=ch->carrying; obj!=NULL;obj=next_obj)
handler.c:    if ( ch->in_room == NULL )
handler.c:    if (ch->in_room != NULL) ch->from_room = ch->in_room->vnum;
handler.c:    if ( !IS_NPC(ch) && !IS_SET( ch->plr, PLR_WIZINVIS ) )
handler.c:	--ch->in_room->area->nplayer;
handler.c:    ch->in_room->light_adjustment = get_light_adjustment ( ch, ch->in_room );
handler.c:    if ( ch == ch->in_room->people )
handler.c:	ch->in_room->people = ch->next_in_room;
handler.c:	for ( prev = ch->in_room->people; prev; prev = prev->next_in_room )
handler.c:		prev->next_in_room = ch->next_in_room;
handler.c:    ch->in_room      = NULL;
handler.c:    ch->next_in_room = NULL;
handler.c:        for ( ch = char_list ; ch != NULL && ch != (CHAR_DATA *) gate->leads_to ; ch = ch->next );
handler.c:	    for ( ch = char_list ; ch != NULL && (!IS_NPC( ch ) || ch->pIndexData->vnum != gate->vnum ) ; ch = ch->next );
handler.c:	        return ch->in_room;
handler.c:	    return ch->in_room;
handler.c:    ch->in_room		= pRoomIndex;
handler.c:    ch->next_in_room	= pRoomIndex->people;
handler.c:    if ( !IS_NPC(ch) && !IS_SET( ch->plr, PLR_WIZINVIS ) )
handler.c:	if ( ch->in_room->area->age < 0 )
handler.c:            ch->in_room->area->age = 0;
handler.c:	++ch->in_room->area->nplayer;
handler.c:	if ( ch->in_room->area->age == 0 && ch->in_room->area->nplayer == 1 && ch->in_room->area->dungeon_data->level > 0 )
handler.c:	    ch->in_room->area->age = 1;
handler.c:	    do_generate_mobs( ch, ch->in_room->area );
handler.c:	    do_generate_objs( NULL, ch->in_room->area->dungeon_data->level, ch->in_room->area, TRUE );
handler.c:    ch->in_room->light_adjustment = get_light_adjustment ( ch, pRoomIndex );
handler.c:        for ( af = ch->affected; af != NULL; af = af->next )
handler.c:            REMOVE_BIT(ch->affected_by,AFF_PLAGUE);
handler.c:        for ( vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
handler.c:    for ( obj2 = ch->carrying ; obj2 != NULL ; obj2 = obj2->next_content )
handler.c:	    ch->carry_number++;
handler.c:	    ch->carry_weight	+= get_obj_weight( obj );
handler.c:    obj->next_content	 = ch->carrying;
handler.c:    ch->carrying	 = obj;
handler.c:    ch->carry_number++;
handler.c:    ch->carry_weight	+= get_obj_weight( obj );
handler.c:    if ( ch->carrying == obj )
handler.c:	ch->carrying = obj->next_content;
handler.c:	for ( prev = ch->carrying; prev != NULL; prev = prev->next_content )
handler.c:    ch->carry_number--;
handler.c:    ch->carry_weight	-= get_obj_weight( obj );
handler.c:    for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
handler.c:	    sprintf( buf, "Equip_char: (%s) already equipped (%d).", ch->name, iWear );
handler.c:    if ( ( IS_SET( obj->extra_flags, ITEM_BARDING ) && !IS_SET( ch->act, ACT_MOUNT ) )
handler.c:      || ( !IS_SET( obj->extra_flags, ITEM_BARDING ) &&  IS_SET( ch->act, ACT_MOUNT ) ) )
handler.c:    ||   ( IS_OBJ_STAT(obj, ITEM_ANTI_NENKEMEN)  && race_table[ ch->race ][ ch->sex ].world == 0 )
handler.c:    ||   ( IS_OBJ_STAT(obj, ITEM_ANTI_MAEGMENEL)  && race_table[ ch->race ][ ch->sex ].world == 1 )
handler.c:    ||   ( IS_OBJ_STAT(obj, ITEM_ANTI_LITHDOR)  && race_table[ ch->race ][ ch->sex ].world == 2 ) )
handler.c:	obj_to_room( obj, ch->in_room );
handler.c:	ch->hands_free--;
handler.c:	ch->hands_free -= 2;
handler.c:    ch->armor      	-= obj->wear_data->ac;
handler.c:	if ( obj->light_data != NULL && ch->in_room != NULL )
handler.c:	    if ( ( IS_SET( obj->light_data->flags, LIGHT_LIT ) && !IS_SET( ch->in_room->room_flags, ROOM_DARK ) )
handler.c:		ch->in_room->light_adjustment += obj->light_data->brightness;
handler.c:	trig = do_trigger( ch->in_room, ch, obj, NULL, TRIG_WEAR, TRIG_TYPE_ROOM);
handler.c:	    ch->hands_free = UMIN( 2, ch->hands_free + 1 );
handler.c:	ch->hands_free = UMIN( 2, ch->hands_free + 2 );
handler.c:    ch->armor	+= obj->wear_data->ac;
handler.c:	if ( obj->light_data != NULL && ch->in_room != NULL )
handler.c:	    if ( ( IS_SET( obj->light_data->flags, LIGHT_LIT ) && !IS_SET( ch->in_room->room_flags, ROOM_DARK ) )
handler.c:		ch->in_room->light_adjustment -= obj->light_data->brightness;
handler.c:    for ( obj = ch->carrying ; obj != NULL ; obj = obj->next_content )
handler.c:    for ( rch = ch->in_room->people; rch != NULL; rch = rch->next_in_room )
handler.c:	if ( !can_see( ch, rch ) || !is_name( arg, rch->name ) )
handler.c:    for ( wch = char_list; wch != NULL ; wch = wch->next )
handler.c:	if ( wch->in_room == NULL || !can_see( ch, wch ) 
handler.c:	||   !is_name( arg, wch->name ) )
handler.c:    for ( wch = char_list; wch != NULL ; wch = wch->next )
handler.c:	if ( wch->in_room == NULL || !can_see( ch, wch ) 
handler.c:	||   !is_name( arg, wch->short_descr ) )
handler.c:  for (obj = ch->carrying; obj != NULL; obj = obj->next_content )
handler.c:    for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
handler.c:    for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
handler.c:    obj = get_obj_list( ch, argument, ch->in_room->contents );
handler.c:    pRoomIndex->light_adjustment = get_light_adjustment(ch, ch->in_room);
handler.c:    if ( ch->size > pRoomIndex->size )
handler.c:    for ( rch = pRoomIndex->people; rch != NULL; rch = rch->next_in_room )
handler.c:    &&  ch->level > 5 && !IS_IMMORTAL(ch))
handler.c:    	if (pRoomIndex->area->visible > ch->level )
handler.c:	&& !IS_SET( ch->act, ACT_MOUNT ) && !IS_SET( ch->affected_by, AFF_CONTROL_MIND ) 
handler.c:	&& !IS_SET(ch->act2, ACT2_WALKTO) && !IS_SET( ch->act, ACT_PET ) && !IS_SET(ch->act2, ACT2_GUIDE))
handler.c:    	if ( ( ( IS_SET(victim->act2, ACT2_DREAMSTATE) && !IS_SET(ch->plr2, PLR_DREAMSTATE) ) 
handler.c:	|| ( !IS_SET(victim->act2, ACT2_DREAMSTATE) && IS_SET(ch->plr2, PLR_DREAMSTATE) ) )
handler.c:       	if ( ( IS_SET(victim->act2, ACT2_DREAMSTATE) && !IS_SET(ch->act2, ACT2_DREAMSTATE) )
handler.c:  	|| ( !IS_SET(victim->act2, ACT2_DREAMSTATE) && IS_SET(ch->act2, ACT2_DREAMSTATE) ) )
handler.c:       	if ( ( IS_SET(victim->plr2, PLR_DREAMSTATE) && !IS_SET(ch->act2, ACT2_DREAMSTATE) )
handler.c:	|| ( !IS_SET(victim->plr2, PLR_DREAMSTATE) && IS_SET(ch->act2, ACT2_DREAMSTATE) ) )
handler.c:       	if ( ( ( IS_SET(victim->plr2, PLR_DREAMSTATE) && !IS_SET(ch->plr2, PLR_DREAMSTATE) ) 
handler.c:	|| ( !IS_SET(victim->plr2, PLR_DREAMSTATE) && IS_SET(ch->plr2, PLR_DREAMSTATE) ) )
handler.c:    pRoomIndex = ch->in_room;
handler.c:    &&   ch->level < victim->invis_level )
handler.c:    if ( (!IS_NPC(ch) && IS_SET(ch->plr, PLR_HOLYLIGHT)) 
handler.c:    if ( IS_AFFECTED(ch, AFF_BLIND) || IS_SET(ch->affected_by_2,AFF_LIGHT_SENSITIVE ) )
handler.c:   if ( IS_AFFECTED_2( victim, AFF_FADE ) && ch->fighting == NULL )
handler.c:        if ( number_percent() < chance || IS_SET( ch->affected_by_2, AFF_SENSES ) )
handler.c:	&& !IS_SET(ch->affected_by, AFF_INFRARED) 
handler.c:	&& !IS_SET(ch->affected_by, AFF_DARK_VISION) )
handler.c:    if ( !IS_NPC(ch) && IS_SET(ch->plr, PLR_HOLYLIGHT) )
handler.c:    if ( ( IS_AFFECTED( ch, AFF_BLIND ) || IS_SET(ch->affected_by_2,AFF_LIGHT_SENSITIVE) )  &&
handler.c:    else if ( IS_AFFECTED( ch, AFF_BLIND ) || IS_SET(ch->affected_by_2, AFF_LIGHT_SENSITIVE) )
handler.c:    if ( ch->level > 5 )
handler.c:    if ( room_is_dark( ch->in_room, ch )
handler.c:    	pRoomIndex = get_room_index( ch->in_room->vnum );
handler.c:    if (ch->position != POS_SLEEPING)
handler.c:    if (IS_SET(ch->dream_flags, IS_DREAMING) )
handler.c:   chance = ch->level / 2 + 2 + ch->pcdata->dreams;
handler.c:		( ch->level < 10 ? number_range(0,10) : 0 ) -
handler.c:		( ch->pcdata->nightmares / 10 ) /*change as more
handler.c:	SET_BIT(ch->dream_flags, DREAM_IS_NIGHTMARE );
handler.c:	SET_BIT(ch->dream_flags, DREAM_IS_NORMAL );
handler.c:	SET_BIT(ch->dream_flags, DREAM_IS_NORMAL );
handler.c:	SET_BIT(ch->dream_flags, DREAM_IS_NORMAL );
handler.c:	SET_BIT(ch->dream_flags, DREAM_IS_NORMAL );
handler.c:	SET_BIT(ch->dream_flags, DREAM_IS_NORMAL );
handler.c:	SET_BIT(ch->dream_flags, DREAM_IS_NORMAL );
handler.c:	SET_BIT(ch->dream_flags, DREAM_IS_NORMAL );
handler.c:	SET_BIT(ch->dream_flags, DREAM_IS_NORMAL );
handler.c:	SET_BIT(ch->dream_flags, DREAM_IS_GOOD );
handler.c:	SET_BIT(ch->dream_flags, DREAM_IS_GOOD_2 );
handler.c:	    ch->dream_flags = 0;
handler.c:	SET_BIT(ch->dream_flags, IS_DREAMING );
handler.c:            act_trigger( victim, pTrig->name, argument, IS_NPC(ch) ? ch->short_descr : ch->name, NULL );
handler.c:		  && (obj->owner == '\0' || !str_cmp(obj->owner,ch->name) )
handler.c:    	        act_trigger_obj(obj, pTrig->name, argument, IS_NPC(ch) ? ch->short_descr : ch->name, NULL );
handler.c:		act_trigger_room(room, pTrig->name, argument, IS_NPC(ch) ? ch->short_descr : ch->name, NULL );
handler.c:    if ( IS_SET(ch->act, ACT_SENTINEL) )
handler.c:    if ( ch->master != NULL && ch->master != ch )
handler.c:    if ( number_bits(ch->in_room->area->wander_time) != 0 )
handler.c:    if ( ch->valid_sector[pexit->u1.to_room->sector_type] == FALSE )
handler.c:	if ( !IS_SET( ch->pIndexData->form , FORM_SENTIENT ) )
handler.c:	if ( IS_SET(pexit->exit_info, EX_HIDDEN) && !IS_SET(ch->pIndexData->act2, ACT2_SEE_HIDDEN ) )
handler.c:	if ( IS_SET(pexit->exit_info, EX_SECRET) && !IS_SET(ch->pIndexData->act2, ACT2_SEE_SECRET ) )
handler.c:    if ( IS_SET(ch->act, ACT_STAY_AREA) && pexit->u1.to_room->area != ch->in_room->area ) 
handler.c:    if ( IS_SET( ch->act2, ACT2_STAY_GUILD ) && !IS_SET( ch->guilds, pexit->u1.to_room->guilds ) )
handler.c:    if ( IS_SET(ch->act, ACT_IN_DOORS ) && !IS_SET( pexit->u1.to_room->room_flags, ROOM_INDOORS ) )
handler.c:    if ( IS_SET(ch->act, ACT_OUT_DOORS ) && IS_SET( pexit->u1.to_room->room_flags, ROOM_INDOORS ) ) 
healer.c:    for ( mob = ch->in_room->people; mob; mob = mob->next_in_room )
healer.c:	if ( ch->level < MAX_LEVEL || IS_IMMORTAL( ch ) )
healer.c:	      ( ch->level < 5 ? 0 : ch->level * ch->level * ch->level * 2 ) );
healer.c:		if ( ch->level  >= MAX_LEVEL )
healer.c:		if (ch->pcdata->corpse == NULL )
healer.c:			    sprintf(buf, "corpse of %s",ch->name);
healer.c:				ch->pcdata->corpse = obj;
healer.c:		if (ch->pcdata->corpse == NULL )
healer.c:		if ( ch->level > 5 )
healer.c:		    cost = ch->level * ch->level * ch->level * 2;
healer.c:		if ( number_percent() > ch->level )
healer.c:    		    if ( ch->pcdata->corpse->carried_by != NULL )
healer.c:		  	obj_from_char( ch->pcdata->corpse, "T" );
healer.c:			act( "$p disappears.", ch->pcdata->corpse->carried_by, ch->pcdata->corpse, ch->pcdata->corpse, TO_CHAR );
healer.c:    		    else if ( ch->pcdata->corpse->in_obj != NULL )
healer.c:			obj_from_obj( ch->pcdata->corpse );
healer.c:    		    else if ( ch->pcdata->corpse->in_room != NULL )
healer.c:		 	obj_from_room( ch->pcdata->corpse );
healer.c:		obj_to_room( ch->pcdata->corpse, ch->in_room );
healer.c:		act("$p appears in the room.\n\r", mob, ch->pcdata->corpse, NULL, TO_ROOM );
healer.c:	    ch->mana[ type ] += dice(2,8) + mob->level / 4;
healer.c:	    ch->mana[ type ] = UMIN(ch->mana[ type ],ch->max_mana[ type ]);
interp.c:    if (IS_SET(cmd_table[cmd].groups, PL ) && IS_SET(ch->cmd_groups, PL ) )
interp.c:    if (IS_SET(cmd_table[cmd].groups, AD ) && IS_SET(ch->cmd_groups, AD ) )
interp.c:    if (IS_SET(cmd_table[cmd].groups, BB ) && IS_SET(ch->cmd_groups, BB ) )
interp.c:    if (IS_SET(cmd_table[cmd].groups, AB ) && IS_SET(ch->cmd_groups, AB ) )
interp.c:    if (IS_SET(cmd_table[cmd].groups, GI ) && IS_SET(ch->cmd_groups, GI ) )
interp.c:    if (IS_SET(cmd_table[cmd].groups, GD ) && IS_SET(ch->cmd_groups, GD ) )
interp.c:    if (IS_SET(cmd_table[cmd].groups, GC ) && IS_SET(ch->cmd_groups, GC ) )
interp.c:    if (IS_SET(cmd_table[cmd].groups, AP ) && IS_SET(ch->cmd_groups, AP ) )
interp.c:    if (IS_SET(cmd_table[cmd].groups, BP ) && IS_SET(ch->cmd_groups, BP ) )
interp.c:    if (IS_SET(cmd_table[cmd].groups, GM ) && IS_SET(ch->cmd_groups, GM ) )
interp.c:    if ( !IS_NPC(ch) && IS_SET(ch->plr, PLR_FREEZE) )
interp.c:    if ( !IS_NPC(ch)  &&  IS_SET(ch->forge_flags, IS_FORGING ) )
interp.c:	ch->forge_count = 0;
interp.c:	REMOVE_BIT(ch->forge_flags, IS_FORGING );
interp.c:    if ( !IS_NPC(ch) && (ch->prompt_num > 0) &&
interp.c:	(ch->prompt_fun != NULL) )
interp.c:	(*ch->prompt_fun)(ch, argument);
interp.c:        for (s = ch->in_room->spro; s != NULL; s = s->next)
interp.c:		    ch->happy_hour = 0;
interp.c:    if ( ch->in_room != NULL && !IS_NPC(ch) && !found )
interp.c:        for ( mob = ch->in_room->people;  mob != NULL;
interp.c:    if ( ch->in_room != NULL && !found )
interp.c:        found = do_trigger( ch->in_room, ch, NULL, command, TRIG_COMMAND, TRIG_TYPE_ROOM);
interp.c:    if ( ch->in_room != NULL && !found )
interp.c:	for ( obj = ch->in_room->contents ; obj != NULL; obj = obj->next_content )
interp.c:        /*for ( victim = ch->in_room->people; victim != NULL; victim = victim->next_in_room)*/
interp.c:        for ( obj = ch->carrying; obj != NULL; obj = obj->next_content )
interp.c:        &&  (cmd_table[cmd].room_vnum ? (ch->in_room->vnum == cmd_table[cmd].room_vnum) : 1)) /* check if command is Room specific */	
interp.c:    if (!IS_SET(ch->plr, PLR_HOLYLIGHT ) )
interp.c:    if (!IS_SET( cmd_table[cmd].log , STARTING ) && IS_SET( ch->in_room->room_flags_2, ROOM_STARTING ) )
interp.c:    	if (!IS_SET(ch->plr, PLR_HOLYLIGHT ) )
interp.c:    	if (IS_SET( ch->in_room->room_flags_2, ROOM_STARTING ) )
interp.c:    if ( ( !IS_NPC(ch) && IS_SET(ch->plr, PLR_LOG) )
interp.c:	sprintf( log_buf, "Log %s: %s", ch->name, logline );
interp.c:    sprintf( log_buf, "Log %s: %s", ch->name, logline );
interp.c:    if ( ch->desc != NULL )
interp.c:	for ( snoop_list = ch->desc->snoop_by ; snoop_list != NULL ; snoop_list = snoop_list->next )
interp.c:	ch->happy_hour = 0;
interp.c:    if (!IS_SET(ch->plr, PLR_HOLYLIGHT ) )
interp.c:    if (IS_SET( ch->in_room->room_flags_2, ROOM_STARTING ) )
interp.c:    if ( !IS_IMMORTAL( ch ) && ch->position < cmd_table[cmd].position )
interp.c:	switch( ch->position )
interp.c:    if ( !IS_NPC(ch) && IS_SET(ch->comm, COMM_NOEMOTE) )
interp.c:    switch ( ch->position )
interp.c:		 if (ch->hit > 5)
interp.c:		 ch->hit--; 
interp.c:			    do_shadowstrike( victim, ch->name );
interp.c:  if (ch->in_room->spro == NULL)
interp.c:  for (s = ch->in_room->spro;s!=NULL;s = s->next)
interp.c:  if (ch->in_room->room_flags == 0 && ch->in_room->room_flags_2 == 0)
interp.c:  if (ch->in_room->room_flags_2 != 0)
interp.c:  sprintf (buf,"`G%s `w", room_bit_name_2( ch->in_room->room_flags_2 ) );
interp.c:  if (ch->in_room->room_flags != 0 )
interp.c:  sprintf (buf,"`G%s`w", room_bit_name( ch->in_room->room_flags ) );
interp.c:  if (ch->in_room->sector_type == 0)
interp.c:  sprintf (buf,"`G%s`w\n\r", sector_bit_name( ch->in_room->sector_type ) );
invoke.c:         if ((victim->level < ch->level) || (victim->level >= LEVEL_IMMORTAL))
invoke.c:          ch->hit -= ch->level*6; 
magic.c:    REMOVE_BIT( ch->affected_by, AFF_HIDE );
magic.c:    REMOVE_BIT( ch->affected_by_2, AFF_FADE );
magic.c:    if ( ch->position < skill_table[sn].minimum_position || IS_AFFECTED( ch, AFF_BERSERK ) )
magic.c:    if ( IS_SET( ch->in_room->room_flags, ROOM_SILENCE ) &&
magic.c:        if ( ch->mana[ i ] < get_mana_cost( ch, sn, i ) )
magic.c:        if ( ch->mana[ i ] < get_mana_cost( ch, sn, i ) )
magic.c:        level = ch->level / 10 + 1;
magic.c:        level = ch->level;
magic.c:            if  ( ( victim = ch->fighting ) == NULL && IS_SET( skill_table[sn].target, TAR_CHAR_OFFENSIVE|TAR_CHAR_DAMAGING ) )
magic.c:                if (victim == NULL) /* If victim = ch->fighting from previous, we donot want to reassign the victim */
magic.c:        if ( IS_AFFECTED(ch, AFF_CONTROL_MIND) && ch->master == victim )
magic.c:        if ( target_name != NULL && !is_name( target_name, ch->name ) )
magic.c:                for ( obj = ch->carrying ; obj != NULL && !found ; obj = obj->next_content )
magic.c:            for ( obj = ch->carrying ; obj != NULL && !found ; obj = obj->next_content )
magic.c:    bug( "Character = : %d.", ch->pIndexData->vnum );
magic.c:                ch->mana[ i ] -= number_range( 0, get_mana_cost( ch, sn, i ) );
magic.c:    bug( "Character = : %d.", ch->pIndexData->vnum );
magic.c:                ch->mana[ i ] -= number_range( 0, get_mana_cost( ch, sn, i ) );
magic.c:                ch->mana[ i ] -= get_mana_cost( ch, sn, i);
magic.c:        for ( vch = ch->in_room->people; vch; vch = vch_next )
magic.c:            vch_next = vch->next_in_room;
magic.c:	        victim = ch->fighting;
magic.c:	    for ( vch = ch->in_room->people; vch; vch = vch_next )
magic.c:	        vch_next = vch->next_in_room;
magic.c:    for ( victim = ch->in_room->people ; victim != NULL ; victim = victim->next_in_room )
magic.c:    for ( victim = ch->in_room->people ; victim != NULL ; victim = victim->next_in_room )
magic.c:	ROOM_INDEX_DATA * room = ch->in_room;
magic.c:    for ( vch=victim->in_room->people ; vch != NULL ; vch=vch->next_in_room)
magic.c:    af.modifier  = -10 * ch->level / 8;
magic.c:	vch_next	= vch->next;
magic.c:	if ( vch->in_room == NULL )
magic.c:	if ( vch->in_room == ch->in_room )
magic.c:	if ( vch->in_room->area == ch->in_room->area
magic.c:    for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
magic.c:	if (vch->position == POS_FIGHTING)
magic.c:	      mlevel += vch->level;
magic.c:	      mlevel += vch->level/2;
magic.c:	    high_level = UMAX(high_level,vch->level);
magic.c:	for (vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
magic.c:	    if (IS_NPC(vch) && (IS_SET(vch->imm_flags,IMM_MAGIC) ) )
magic.c:	    if (vch->fighting || vch->position == POS_FIGHTING)
magic.c:	 !(IS_AFFECTED(ch, AFF_CONTROL_MIND) && ch->master == victim) ) ||
magic.c:	    damage( ch, (CHAR_DATA *) vo, ch->hit / 8, sn, DAM_SPIRIT );
magic.c:	    damage( ch, (CHAR_DATA *) vo, ch->hit / 6, sn, DAM_SPIRIT );
magic.c:	ch->hit -= ch->hit / 12;
magic.c:	ch->hit = UMAX(ch->hit,1);
magic.c:	    damage( ch, (CHAR_DATA *) vo, ch->hit / 14, sn, DAM_SPIRIT );
magic.c:	    damage( ch, (CHAR_DATA *) vo, ch->hit / 12, sn, DAM_SPIRIT );
magic.c:	ch->hit -= ch->hit / 12;
magic.c:	ch->hit = UMAX(ch->hit,1);
magic.c:	    damage( ch, (CHAR_DATA *) vo, ch->hit / 5, sn, DAM_SPIRIT );
magic.c:	    damage( ch, (CHAR_DATA *) vo, ch->hit / 3, sn, DAM_SPIRIT );
magic.c:	ch->hit -= ch->hit / 6;
magic.c:	ch->hit = UMAX(ch->hit,1);
magic.c:	    damage( ch, (CHAR_DATA *) vo, ch->hit / 8, sn, DAM_SPIRIT );
magic.c:	    damage( ch, (CHAR_DATA *) vo, ch->hit / 6, sn, DAM_SPIRIT );
magic.c:	ch->hit -= ch->hit / 6;
magic.c:	ch->hit = UMAX(ch->hit,1);
magic.c:	    damage( ch, (CHAR_DATA *) vo, ch->hit / 4, sn, DAM_SPIRIT );
magic.c:	    damage( ch, (CHAR_DATA *) vo, ch->hit / 2, sn, DAM_SPIRIT );
magic.c:	ch->hit -= ch->hit / 3;
magic.c:	ch->hit = UMAX(ch->hit,1);
magic.c:	if (!ch->in_room)
magic.c:	for (tmp_vict = ch->in_room->people; 
magic.c:    ||   victim->in_room->area->visible > ch->level 
magic.c:    obj->timer = ch->level/2;
magic.c:    if ( ch->in_room->area->world != victim->in_room->area->world )
magic.c:    if ( IS_IMMORTAL( ch ) && IS_SET( ch->plr, PLR_HOLYLIGHT ) )
magic.c:	obj->gate_data->ave_timer = ch->level / 2;	
magic.c:	obj->timer = ch->level * 3 / 2;
magic.c:	obj->gate_data->ave_timer = ch->level * 3 / 2;
magic.c:	obj->timer = ch->level * 2;
magic.c:	obj->gate_data->ave_timer = ch->level *2;
magic.c:    obj_to_room( obj, ch->in_room );
magic.c:    ||   victim->in_room->area->visible > ch->level 
magic.c:    obj->timer = ch->level/2;
magic.c:    if ( ch->in_room->area->world != victim->in_room->area->world )
magic.c:	obj->timer = ch->level * 3 / 2;
magic.c:	obj->gate_data->ave_timer = ch->level * 3 / 2;
magic.c:	obj->timer = ch->level * 2;
magic.c:	obj->gate_data->ave_timer = ch->level *2;
magic.c:    obj_to_room( obj, ch->in_room );
magic.c:    obj_to_room( light, ch->in_room );
magic.c:    obj_to_room( mushroom, ch->in_room );
magic.c:    obj_to_room( spring, ch->in_room );
magic.c:		level * (weather_info[ ch->in_room->area->world ].sky >= SKY_RAINING ? 4 : 2),
magic.c:    boulders = number_range( 1, ch->level / 10 );
magic.c:	vch_next = vch->next;
magic.c:	if ( vch->in_room == NULL )
magic.c:	if ( vch->in_room == ch->in_room && vch != caster && !is_same_group( ch, vch ) && !IS_IMMORTAL( vch ) )
magic.c:	if ( vch->in_room->area == ch->in_room->area )
magic.c:	vch_next	= vch->next;
magic.c:	if ( vch->in_room == NULL )
magic.c:	if ( vch->in_room == ch->in_room && vch != caster )
magic.c:	if ( vch->in_room->area == ch->in_room->area )
magic.c:	added = number_range( 1, UMAX(1, ch->level/10) );
magic.c:	added2 = number_range( 1, UMAX(1, ch->level/10) );
magic.c:	added = number_range( 2, UMAX(2, ch->level/8) );
magic.c:	added2 = number_range( 2, UMAX(2, ch->level/8) );
magic.c:	dam		 = ch->hit + 1;
magic.c:	ch->hit		+= dam;
magic.c:	ch->exp		+= mod_exp/3;
magic.c:    for ( ich = ch->in_room->people; ich != NULL; ich = ich->next_in_room )
magic.c:	if ( !IS_NPC(ich) && IS_SET(ich->plr, PLR_WIZINVIS) )
magic.c:	REMOVE_BIT   ( ich->affected_by, AFF_HIDE	);
magic.c:	REMOVE_BIT   ( ich->affected_by_2, AFF_FADE	);
magic.c:	REMOVE_BIT   ( ich->affected_by, AFF_SHADOWFORM	);
magic.c:	REMOVE_BIT   ( ich->affected_by, AFF_SNEAK	);
magic.c:    ||   victim->in_room->area->visible > ch->level 
magic.c:    ||	 victim->in_room->area->world != ch->in_room->area->world
magic.c:    ||   IS_SET(ch->in_room->room_flags, ROOM_NO_RECALL)
magic.c:    if (ch->pet != NULL && ch->in_room == ch->pet->in_room)
magic.c:    if (ch->inside_area != NULL ) /* Don't carry the moveable area data */
magic.c:	free_inside_area_data(ch->inside_area);
magic.c:	ch->inside_area = NULL;
magic.c:    if ( ch->mount != NULL && IS_SET( ch->mount->affected_by,AFF_MOUNTED) )
magic.c:        char_from_room( ch->mount );
magic.c:        char_to_room( ch->mount, victim->in_room );
magic.c:	act("$n `wdissapears into another plane, swirling colors swarm in the area where they had once stood.",ch->pet,NULL,NULL,TO_ROOM);
magic.c:	send_to_char("You dissapear into a plane of swirling colors.\n\r",ch->pet);
magic.c:	char_from_room(ch->pet);
magic.c:	char_to_room(ch->pet,victim->in_room);
magic.c:	act("$n `whas arrived from planar travel.",ch->pet,NULL,NULL,TO_ROOM);
magic.c:	do_look(ch->pet,"auto");
magic.c:    	ch->move /= 2;
magic.c:	ch->hit /= 2;
magic.c:    for ( vch = ch->in_room->people; vch != NULL; vch = vch_next )
magic.c:        vch_next = vch->next_in_room;
magic.c:    gain_exp( ch, -1 * ch->level * 1000);
magic.c:    else if (ch->lines)
magic.c:    hits	= number_range( 1, ch->level / 6 );
magic.c:    hits	= number_range( 1, ch->level / 6 );
magic.c:    hits	= number_range( 1, ch->level / 6 );
magic.c:    for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
magic.c:    for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
magic.c:    for ( gch = ch->in_room->people; gch != NULL; gch = gch->next_in_room )
magic.c:        paf->duration  = UMIN( ch->level * 4, paf->duration + ch->level );
magic.c:        af.duration  = ch->level;
magic.c:    victim->move = UMIN( victim->move + (3 * ch->level), victim->max_move );
magic.c:    ROOM_INDEX_DATA * room = ch->in_room;
magic.c:    for ( victim = ch->in_room->people ; victim != NULL ; victim = victim->next_in_room )
magic.c:    ROOM_INDEX_DATA * room = ch->in_room;
magic.c:    ROOM_INDEX_DATA * room = ch->in_room;
magic.c:    victim->mana[ELEMENT_SPIRIT] += ch->level * 10 + 150;
magic.c:    	level	= ch->level;
magic.c:    ||   victim->in_room->area->visible > ch->level
magic.c:    ||   victim->in_room->area->world != ch->in_room->area->world
magic.c:    char_to_room( victim, ch->in_room );
magic.c:        char_to_room( victim->mount, ch->in_room );
magic.c:	&&   pRoomIndex->area->visible <= ch->level
magic.c:	&&   ch->in_room->area->world == pRoomIndex->area->world
magic.c:    if ( IS_SET(ch->in_room->room_flags, ROOM_NO_RECALL)
magic.c:    if ( ( fighting = ch->fighting ) != NULL )
magic.c:	skill = 40 + ch->level;
magic.c:	for ( obj_lose = ch->carrying; obj_lose != NULL; obj_lose = obj_next )
magic.c:    hpch = UMAX( 10, ch->hit );
magic.c:                    if (number_bits(2) == 0 || ch->in_room == NULL)
magic.c:                    	obj_to_room(t_obj,ch->in_room);
magic.c:    hpch = UMAX( 10, ch->hit );
magic.c:    for ( vch = ch->in_room->people; vch != NULL; vch = vch_next )
magic.c:	vch_next = vch->next_in_room;
magic.c:	    hpch = UMAX( 10, ch->hit );
magic.c:    hpch = UMAX( 10, ch->hit );
medit.c:    pMob2 = (MOB_INDEX_DATA *)ch->desc->pEdit; 
medit.c:        ch->desc->pEdit = NULL;
medit.c:        ch->desc->connected = CON_PLAYING;
medit.c:	ch->edit_menu = 0;
medit.c:	ch->edit_buffer[0] = '\0';
medit.c:		ch->edit_menu = MEDIT_MENU ;
medit.c:		ch->edit_buffer[0] = '\0';
medit.c:		ch->edit_menu = MEDIT_MENU ;
medit.c:		ch->edit_buffer[0] = '\0';
medit.c:		ch->edit_menu = MEDIT_MENU ;
medit.c:		ch->edit_buffer[0] = '\0';
medit.c:		ch->edit_menu = MEDIT_MENU ;
medit.c:		ch->edit_buffer[0] = '\0';
medit.c:		ch->edit_menu = MEDIT_MENU ;
medit.c:		ch->edit_buffer[0] = '\0';
medit.c:		ch->edit_menu = MEDIT_FORM ;
medit.c:		strncpy( ch->edit_buffer, "Form->", 80 );
medit.c:		ch->edit_menu = MEDIT_FORM ;
medit.c:		strncpy( ch->edit_buffer, "Form->", 80 );
medit.c:		ch->edit_menu = MEDIT_FORM ;
medit.c:		strncpy( ch->edit_buffer, "Form->", 80 );
medit.c:		ch->edit_menu = MEDIT_FORM ;
medit.c:		strncpy( ch->edit_buffer, "Form->", 80 );
medit.c:	if (ch->edit_menu > 2 )
medit.c:	ch->edit_menu = MEDIT_FORM ;
medit.c:	strncpy( ch->edit_buffer, "Form->", 80 );
medit.c:	ch->edit_menu = MEDIT_EVENTS ;
medit.c:	strncpy( ch->edit_buffer, "Events->", 80 );
medit.c:	ch->edit_menu = MEDIT_SKILLS ;
medit.c:	strncpy( ch->edit_buffer, "Skills->", 80 );
medit.c:	ch->edit_menu = MEDIT_SPECIALS ;
medit.c:	strncpy( ch->edit_buffer, "Specials->", 80 );
medit.c:	ch->edit_menu = MEDIT_ADVANCED ;
medit.c:	strncpy( ch->edit_buffer, "Advanced->", 80 );
medit.c:	ch->edit_menu = MEDIT_FORM_MOVE ;
medit.c:	strncpy( ch->edit_buffer, "Form->Movement->", 80 );
medit.c:	ch->edit_menu = MEDIT_FORM_COMBAT ;
medit.c:	strncpy( ch->edit_buffer, "Form->Combat->", 80 );
medit.c:	ch->edit_menu = MEDIT_FORM_AFFECTS ;
medit.c:	strncpy( ch->edit_buffer, "Form->Affects->", 80 );
medit.c:	ch->edit_menu = MEDIT_FORM_MAGIC ;
medit.c:	strncpy( ch->edit_buffer, "Form->Magic->", 80 );
medit.c:	    if ( pArea != ch->in_room->area )
medit.c:	    event->room_vnum = ch->in_room->vnum;
medit.c:	    event->area = ch->in_room->area;
medit.c:	    SET_BIT(ch->in_room->area->area_flags, AREA_CHANGED );
medit.c:	    if ( event->room_vnum == ch->in_room->vnum)
medit.c: 	pArea = ch->in_room->area;
medit.c:	    ch->desc->pEdit = (void *)pMobIndex;
medit.c:	    pMob2 = (MOB_INDEX_DATA *)ch->desc->pEdit;
medit.c:        ch->desc->pEdit = (void *)pMob2;
medit.c:        ch->desc->connected = CON_MEDITOR;
medit.c:	ch->edit_menu	= MEDIT_MENU;
medit.c:    	ch->edit_buffer[0] = '\0';
medit.c:		for ( vnum = ch->in_room->area->lvnum ; free_mob_list[ vnum ] ; vnum++ );
medit.c:		if ( vnum <= ch->in_room->area->uvnum )
medit.c:            pArea = ch->in_room->area;
medit.c:            ch->desc->pEdit = (void *)pMob2;
medit.c:	    if (ch->logon_data != NULL )
medit.c:	    ch->logon_data->mobiles++;
medit.c:            ch->desc->connected = CON_MEDITOR;
medit.c:    	    ch->edit_menu = MEDIT_MENU;
medit.c:    	    ch->edit_buffer[0] = '\0';
mob_commands.c:        bug( "Mpasound - No argument: vnum %d.", ch->pIndexData->vnum );
mob_commands.c:    was_in_room = ch->in_room;
mob_commands.c:	ch->in_room = pexit->u1.to_room;
mob_commands.c:  ch->in_room = was_in_room;
mob_commands.c:    ROOM_INDEX_DATA *in_room=ch->in_room;
mob_commands.c:    if ( ch->position != POS_STANDING || ch->fighting != NULL )
mob_commands.c:    if ( ch->master != NULL )
mob_commands.c:	for ( vch = ch->in_room->people ; vch != NULL ; vch = vch->next_in_room )
mob_commands.c:	    if ( ch->master == vch )
mob_commands.c:	    for ( vch = char_list ; vch != NULL && vch != tracks->ch ; vch = vch->next );
mob_commands.c:	      || ( !is_name( argument, vch->name ) && fPass )
mob_commands.c:	      || ( is_name( argument, vch->name ) && !fPass ) )
mob_commands.c:    if ( IS_SET( ch->act, ACT_WIMPY ) && ch->hit < ch->max_hit * 2 / 3 )
mob_commands.c:	if ( ch->in_room->exit[ rev_dir[ current ] ] != NULL )
mob_commands.c:		if ( ch->in_room->exit[ door ] != NULL )
mob_commands.c:    if ( ( pexit = ch->in_room->exit[ current ] ) == NULL )
mob_commands.c:	if ( !IS_SET( ch->form, FORM_SENTIENT ) || ( IS_AFFECTED( ch, AFF_DIMENSION_WALK ) && !IS_SET( pexit->exit_info, EX_PASSPROOF ) ) 
mob_commands.c:	    if ( is_locked_door( ch->in_room, current ) )
mob_commands.c:		if( is_locked_door( ch->in_room, current ) )
mob_commands.c:	    if ( ch->in_room != in_room && ( pexit = ch->in_room->exit[ rev_dir[ current ] ] ) != NULL
mob_commands.c:		ch->pIndexData->vnum );
mob_commands.c:	    ch->pIndexData->vnum );
mob_commands.c:	    ch->pIndexData->vnum );
mob_commands.c:    if ( IS_AFFECTED( ch, AFF_CONTROL_MIND ) && ch->master == victim )
mob_commands.c:	    ch->pIndexData->vnum );
mob_commands.c:    if ( ch->position == POS_FIGHTING )
mob_commands.c:	    ch->pIndexData->vnum );
mob_commands.c:        bug( "Mpjunk - No argument: vnum %d.", ch->pIndexData->vnum );
mob_commands.c:      for ( obj = ch->carrying; obj != NULL; obj = obj_next )
mob_commands.c:       bug( "Mpechoaround - No argument:  vnum %d.", ch->pIndexData->vnum );
mob_commands.c:	    ch->pIndexData->vnum );
mob_commands.c:    pArea = ch->in_room->area;
mob_commands.c:        for ( obj = ch->in_room->contents ; obj != NULL ; obj = obj->next_content )
mob_commands.c:	   ch->pIndexData->vnum );
mob_commands.c:	    ch->pIndexData->vnum );
mob_commands.c:	    ch->pIndexData->vnum );
mob_commands.c:	bug( "Mpmload - Bad vnum as arg: vnum %d.", ch->pIndexData->vnum );
mob_commands.c:	bug( "Mpmload - Bad mob vnum: vnum %d.", ch->pIndexData->vnum );
mob_commands.c:    char_to_room( victim, ch->in_room );
mob_commands.c:	    ch->pIndexData->vnum );
mob_commands.c:	level = ch->level;
mob_commands.c:	    bug( "Mpoload - Bad syntax: vnum %d.", ch->pIndexData->vnum );
mob_commands.c:	    bug( "Mpoload - Bad level: vnum %d.", ch->pIndexData->vnum );
mob_commands.c:	bug( "Mpoload - Bad vnum arg: vnum %d.", ch->pIndexData->vnum );
mob_commands.c:	obj_to_room( obj, ch->in_room );
mob_commands.c:	for ( victim = ch->in_room->people; victim != NULL; victim = vnext )
mob_commands.c:	for ( obj = ch->in_room->contents; obj != NULL; obj = obj_next )
mob_commands.c:		bug( "Mppurge - Purging a PC: vnum %d.", ch->pIndexData->vnum );
mob_commands.c:	ch->extract = TRUE;
mob_commands.c:	bug( "Mppurge - Purging a PC: vnum %d.", ch->pIndexData->vnum );
mob_commands.c:	bug( "Mpgoto - No argument: vnum %d.", ch->pIndexData->vnum );
mob_commands.c:	bug( "Mpgoto - No such location: vnum %d.", ch->pIndexData->vnum );
mob_commands.c:    if ( ch->fighting != NULL )
mob_commands.c:	bug( "Mpat - Bad argument: vnum %d.", ch->pIndexData->vnum );
mob_commands.c:	bug( "Mpat - No such location: vnum %d.", ch->pIndexData->vnum );
mob_commands.c:    original = ch->in_room;
mob_commands.c:    for ( wch = char_list; wch != NULL; wch = wch->next )
mob_commands.c:	bug( "Mptransfer - Bad syntax: vnum %d.", ch->pIndexData->vnum );
mob_commands.c:	location = ch->in_room;
mob_commands.c:	        ch->pIndexData->vnum );
mob_commands.c:		ch->pIndexData->vnum );
mob_commands.c:	    ch->pIndexData->vnum );
mob_commands.c:	    ch->pIndexData->vnum );
mob_commands.c:	bug( "Mpforce - Bad syntax: vnum %d.", ch->pIndexData->vnum );
mob_commands.c:	    vch_next = vch->next;
mob_commands.c:	    if ( vch->in_room == ch->in_room
mob_commands.c:	  	ch->pIndexData->vnum );
mob_commands.c:	    	ch->pIndexData->vnum );
mob_commands.c:    for ( spaces = 0 ; spaces < ( 6 + ch->level ) && tracks->dir == 6 ; spaces ++ )
mob_commands.c:        tracks->room = ch->in_room;
mob_commands.c:    if ( IS_SET( ch->act, ACT_WIMPY ) && ch->hit < ch->max_hit * 2 / 3 )
mob_commands.c:	if ( ( pexit = ch->in_room->exit[ rev_dir[ tracks->dir ] ] ) != NULL )
mob_commands.c:		if ( ( pexit = ch->in_room->exit[ spaces ] ) != NULL )
mob_commands.c:    if ( ( pexit = ch->in_room->exit[ tracks->dir ] ) == NULL )
mob_commands.c:    ch->wait++;
mob_commands.c:	if ( !IS_SET( ch->form, FORM_SENTIENT ) || ( IS_AFFECTED( ch, AFF_DIMENSION_WALK ) && !IS_SET( pexit->exit_info, EX_PASSPROOF ) ) 
mob_commands.c:	    if ( is_locked_door( ch->in_room, tracks->dir ) )
mob_commands.c:		if( is_locked_door( ch->in_room, tracks->dir ) )
mob_commands.c:	    in_room = ch->in_room;
mob_commands.c:	    if ( ch->in_room != in_room && ( pexit = ch->in_room->exit[ rev_dir[ tracks->dir ] ] ) != NULL
note.c:   if ( !str_cmp( ch->name, pnote->sender ) )
note.c:   if ( ch->pcdata == NULL )
note.c:    for ( note_list = ch->pcdata->read_notes ; note_list != NULL ; note_list = note_list->next )
note.c:    if ( !str_cmp( ch->name, pnote->sender ) )
note.c:    if ( ch->pcdata->pcclan != NULL )
note.c:	sprintf( buf,"'%s'",ch->pcdata->pcclan->clan->title);
note.c:    if ( is_name( ch->name, pnote->to_list ) )
note.c:    if ( ch->pnote != NULL )
note.c:    strncpy( pnote->sender, ch->name, 30 );
note.c:    ch->pnote		= pnote;
note.c:	if ( to_one[0] != '\0' && str_cmp( ch->name, to_one ) )
note.c:    if ( str_cmp( ch->name, pnote->sender ) && to_new[0] != '\0' )
note.c:	TOGGLE_BIT( ch->pnote->flags, flag );
note.c:	ch->desc->connected = CON_EDITING;
note.c:	if ( ch->pnote == NULL )
note.c:	string_append(ch, &ch->pnote->text);
note.c:		if (is_note_to(ch,pnote) && str_cmp(ch->name,pnote->sender)
note.c:		  && !is_name( ch->name, pnote->read_list ) )
note.c:		    sprintf( buf, "%s %s", pnote->read_list, ch->name );
note.c:		    if ( !str_cmp( pnote->sender, ch->name ) 
note.c:		    read_notes->next = ch->pcdata->read_notes;
note.c:		    ch->pcdata->read_notes = read_notes;
note.c:			  && !is_name( ch->name, pnote->read_list ) )
note.c:			    sprintf( buf, "%s %s", pnote->read_list, ch->name );
note.c:			    if ( !str_cmp( pnote->sender, ch->name ) 
note.c:			    read_notes->next = ch->pcdata->read_notes;
note.c:		    ch->pcdata->read_notes = read_notes;
note.c:		strncpy( ch->pnote->subject, buf, 30 );
note.c:		strcpy( buf , cut_name( ch->name, pnote->to_list ) );
note.c:		strncpy( ch->pnote->to_list, buf, 80 );
note.c:		if ( str_cmp( ch->name, pnote->sender ) && !IS_OPTIVISION(ch) )
note.c:		strncpy( ch->pnote->subject, pnote->subject, 30 );
note.c:		strncpy( ch->pnote->to_list, pnote->to_list, 80 );
note.c:		strncpy( ch->pnote->sender, pnote->sender, 30 );
note.c:		free_string( ch->pnote->text );
note.c:		ch->pnote->text = str_dup( pnote->text );
note.c:	strcpy( buf, ch->pnote->text );
note.c:	free_string( ch->pnote->text );
note.c:	ch->pnote->text = str_dup( buf );
note.c:	strcpy( buf, ch->pnote->text );
note.c:	free_string( ch->pnote->text );
note.c:	ch->pnote->text = str_dup( buf );
note.c:	strncpy( ch->pnote->subject, argument, 30 );
note.c:	if ( is_name( "clan", argument ) && ch->pcdata->pcclan != NULL )
note.c:	    strcat( buf, ch->pcdata->pcclan->clan->title);
note.c:	    strncpy( ch->pnote->to_list, buf, 80 );
note.c:	    strncpy( ch->pnote->to_list, argument, 80 );
note.c:	strncpy( ch->pnote->sender, argument, 30 );
note.c:	if ( ch->pnote != NULL )
note.c:	    ch->pnote->subject[0]	= '\0';
note.c:	    ch->pnote->to_list[0]	= '\0';
note.c:	    ch->pnote->date[0]		= '\0';
note.c:	    ch->pnote->sender[0]	= '\0';
note.c:	    ch->pnote->next	= note_free;
note.c:	    note_free		= ch->pnote;
note.c:	    ch->pnote		= NULL;
note.c:	if ( ch->pnote == NULL )
note.c:	    ch->pnote->sender,
note.c:	    ch->pnote->subject,
note.c:	    ch->pnote->to_list
note.c:	send_to_char( ch->pnote->text, ch );
note.c:	if ( ch->pnote == NULL )
note.c:	if (!str_cmp(ch->pnote->to_list,""))
note.c:	if (!str_cmp(ch->pnote->subject,""))
note.c:		  is_note_to( d->character, ch->pnote )
note.c:	        sprintf( buf, "A mailman comes up to and tells you you have a new note from %s.\n\r",ch->name);
note.c:	ch->pnote->next			= NULL;
note.c:	strncpy( ch->pnote->date, strtime, 30 );
note.c:	ch->pnote->date_stamp		= current_time;
note.c:	note_add( ch->pnote );
note.c:	ch->pnote	= NULL;
obj_commands.c:    for ( ch = pRoom->people ; ch != NULL ; ch = ch->next_in_room )
obj_commands.c:	if ( is_name( arg, ch->name ) )
obj_commands.c:    for ( ch = char_list ; ch != NULL ;  ch = ch->next )
obj_commands.c:	if ( is_name( arg, ch->name ) )
obj_commands.c:    for ( ch = pRoom->people ; ch != NULL ; ch = ch->next_in_room )
obj_commands.c:    for ( ch = pRoom->people ; ch != NULL ; ch = ch->next_in_room )
oedit.c:    strncpy( pObj->approve_data->modifier, ch->name, 30 );
oedit.c:    if ( ch->pcdata->security > security )
oedit.c:	SET_BIT(ch->edit_flags,SECURITY_CHECK);
oedit.c:    if ( menu == ch->edit_menu )
oedit.c:    pObj2 = (OBJ_INDEX_DATA *)ch->desc->pEdit;
oedit.c:        ch->desc->pEdit = NULL;
oedit.c:        ch->desc->connected = CON_PLAYING;
oedit.c:	ch->edit_menu = 0;
oedit.c:	ch->edit_buffer[0] = '\0';
oedit.c:	if (ch->edit_menu > 2 )
oedit.c:	if (ch->edit_menu == OEDIT_EDIBLE_MENU )
oedit.c:	if (ch->edit_menu == OEDIT_EXTRA_MENU )
oedit.c:	if (ch->edit_menu == OEDIT_CONTAINER_LOCK_MENU )
oedit.c:	if (ch->edit_menu == OEDIT_CONTAINER_TRAP_MENU )
oedit.c:	if (ch->edit_menu == OEDIT_GATE_MENU )
oedit.c:	if (ch->edit_menu == OEDIT_LIGHT_MENU )
oedit.c:	if (ch->edit_menu == OEDIT_WEAR_MENU )
oedit.c:	if (ch->edit_menu == OEDIT_WEAR_WEAPON_MENU )
oedit.c:	if (ch->edit_menu == OEDIT_WEAR_MAGIC_MENU )
oedit.c:	if (ch->edit_menu == OEDIT_WEAR_AFFECT_MENU )
oedit.c:	if (ch->edit_menu == OEDIT_CONTAINER_MENU )
oedit.c:	if (ch->edit_menu == OEDIT_MENU )
oedit.c:	ch->edit_menu = OEDIT_EXTRA_MENU ;
oedit.c:	strncpy( ch->edit_buffer, "Extra->", 80 );
oedit.c:	ch->edit_menu = OEDIT_INSIDE_MENU ;
oedit.c:	strncpy( ch->edit_buffer, "Inside->", 80 );
oedit.c:	ch->edit_menu = OEDIT_LIGHT_MENU ;
oedit.c:	strncpy( ch->edit_buffer, "Lights->", 80 );
oedit.c:	ch->edit_menu = OEDIT_WEAR_MENU ;
oedit.c:	strncpy(ch->edit_buffer, "Wear->", 80 );
oedit.c:	ch->edit_menu = OEDIT_CONTAINER_TRAP_MENU ;
oedit.c:	strncpy( ch->edit_buffer, "Container->Traps", 80 );
oedit.c:	ch->edit_menu = OEDIT_CONTAINER_LOCK_MENU ;
oedit.c:	strncpy( ch->edit_buffer, "Container->Locks", 80 );
oedit.c:	ch->edit_menu = OEDIT_CONTAINER_MENU ;
oedit.c:	strncpy( ch->edit_buffer, "Container->", 80 );
oedit.c:	ch->edit_menu = OEDIT_EDIBLE_MENU ;
oedit.c:	strncpy( ch->edit_buffer, "Edible->", 80 );
oedit.c:	ch->edit_menu = OEDIT_GATE_MENU ;
oedit.c:	strncpy( ch->edit_buffer ,"Gates->", 80 );
oedit.c:	    ch->edit_menu = OEDIT_WEAR_WEAPON_MENU ;
oedit.c:	    strncpy( ch->edit_buffer, "Wear->Weapon->", 80 );
oedit.c:	    ch->edit_menu = OEDIT_WEAR_MAGIC_MENU ;
oedit.c:	    strncpy( ch->edit_buffer, "Wear->Magic->", 80 );
oedit.c:	    ch->edit_menu = OEDIT_WEAR_AFFECT_MENU ;
oedit.c:	    strncpy( ch->edit_buffer, "Wear->Affects->", 80 );
oedit.c:		ch->edit_menu = OEDIT_MENU ;
oedit.c:		ch->edit_buffer[0] = '\0';
oedit.c:		ch->edit_menu = OEDIT_CONTAINER_MENU ;
oedit.c:		strncpy( ch->edit_buffer, "Container->", 80 );
oedit.c:		ch->edit_menu = OEDIT_CONTAINER_MENU ;
oedit.c:		strncpy( ch->edit_buffer ,"Container->", 80 );
oedit.c:		ch->edit_menu = OEDIT_MENU ;
oedit.c:		ch->edit_buffer[0] = '\0';
oedit.c:		ch->edit_menu = OEDIT_MENU ;
oedit.c:		ch->edit_buffer[0] = '\0';
oedit.c:		ch->edit_menu = OEDIT_MENU ;
oedit.c:		ch->edit_buffer[0] = '\0';
oedit.c:		ch->edit_menu = OEDIT_WEAR_MENU ;
oedit.c:		strncpy( ch->edit_buffer, "Wear->", 80 );
oedit.c:		ch->edit_menu = OEDIT_MENU ;
oedit.c:		ch->edit_buffer[0] = '\0';
oedit.c:		ch->edit_menu = OEDIT_MENU ;
oedit.c:	        ch->edit_buffer[0] = '\0';
oedit.c:		ch->edit_menu = OEDIT_WEAR_MENU ;
oedit.c:		strncpy( ch->edit_buffer, "Wear->", 80 );
oedit.c:		ch->edit_menu = OEDIT_WEAR_MENU ;
oedit.c:		strncpy( ch->edit_buffer, "Wear->", 80 );
oedit.c:	    ch->edit_menu = OEDIT_MENU;
oedit.c:	    ch->edit_buffer[0] = '\0';
oedit.c:	    ch->edit_menu = OEDIT_MENU;
oedit.c:	    ch->edit_buffer[0] = '\0';
oedit.c:	if (ch->edit_menu == OEDIT_WEAR_AFFECT_MENU )
oedit.c:	if (ch->edit_menu == OEDIT_MENU )
oedit.c: 	pArea = ch->in_room->area;
oedit.c:	    ch->desc->pEdit = (void *)pObj;
oedit.c:	    pObj2 = (OBJ_INDEX_DATA *)ch->desc->pEdit;
oedit.c: 	pArea = ch->in_room->area;
oedit.c:	    ch->desc->pEdit = (void *)pObj;
oedit.c:	    pObj2 = (OBJ_INDEX_DATA *)ch->desc->pEdit;
oedit.c:	strncpy( pObj->approve_data->creater, ch->name, 30 );
oedit.c:    if ( !strncmp( arg1, "approve", 4 ) && ( IS_IMP( ch ) || !str_cmp( ch->name, "Ron" ) ) )
oedit.c:	strncpy( pObj2->approve_data->approver, ch->name, 30 );
oedit.c:        pArea = ch->in_room->area;
oedit.c:	ch->edit_menu = 1;
oedit.c:        ch->desc->pEdit = (void *)pObj2;
oedit.c:	if (ch->logon_data != NULL )
oedit.c:	ch->logon_data->objects++;
oedit.c:        strncpy( pObj2->approve_data->creater, ch->name, 30 ); 
oedit.c:    if ( IS_SET(ch->edit_flags, SECURITY_CHECK) )
oedit.c:	REMOVE_BIT(ch->edit_flags, SECURITY_CHECK);
oedit.c:        ch->desc->pEdit = (void *)pObj2;
oedit.c:        ch->desc->connected = CON_OEDITOR;
oedit.c:	ch->edit_menu = OEDIT_MENU;
oedit.c:	ch->edit_buffer[0] = '\0';
oedit.c:	    pArea = ch->in_room->area;
oedit.c:            if ( !IS_BUILDER( ch, ch->in_room->area ) )
oedit.c:            ch->desc->pEdit = (void *)pObj2;
oedit.c:	    if (ch->logon_data != NULL )
oedit.c:	    ch->logon_data->objects++;
oedit.c:	    strncpy( pObj2->approve_data->creater, ch->name, 30 );
oedit.c:            ch->desc->connected = CON_OEDITOR;
oedit.c:	    ch->edit_menu = OEDIT_MENU;
oedit.c:	    ch->edit_buffer[0] = '\0';
olc.c:    pArea = ch->in_room->area;
olc.c:        ch->desc->pEdit = NULL;
olc.c:        ch->desc->connected = CON_PLAYING;
olc.c:    pHelp = (HELP_DATA *)ch->desc->pEdit;
olc.c:    pArea = ch->in_room->area;
olc.c:        ch->desc->pEdit = NULL;
olc.c:        ch->desc->connected = CON_PLAYING;
olc.c:        ch->desc->pEdit     =   (void *)pHelp;
olc.c:	    if ( ch->pnote == NULL || strlen( ch->pnote->text ) == 0 )
olc.c:	    pHelp->text = str_dup( ch->pnote->text );
olc.c:    pArea = (AREA_DATA *)ch->desc->pEdit;
olc.c:        ch->desc->pEdit = NULL;
olc.c:        ch->desc->connected = CON_PLAYING;
olc.c:        ch->desc->pEdit     =   (void *)pArea;
olc.c:        ch->desc->pEdit         = (void *)pRoom;
olc.c:	if (ch->logon_data != NULL )
olc.c:	ch->logon_data->rooms++;
olc.c:	if (ch->inside_area != NULL )
olc.c:	free_inside_area_data(ch->inside_area);
olc.c:	ch->inside_area = NULL;
olc.c:    pMob2 = (MOB_INDEX_DATA *)ch->desc->pEdit; 
olc.c:        ch->desc->pEdit = NULL;
olc.c:        ch->desc->connected = CON_PLAYING;
olc.c:    pArea = ch->in_room->area;
olc.c:    ch->desc->pEdit = (void *)pHelp;
olc.c:    ch->desc->connected = CON_HEDITOR;
olc.c:       if(str_cmp(sedit_in_use,ch->name))
olc.c:	  strcpy( sedit_in_use, ch->name);
olc.c:    ch->desc->pEdit = (void *) (ch->in_room->area);
olc.c:    ch->desc->connected = CON_SEDITOR;
olc.c:    pArea = ch->in_room->area;
olc.c:    ch->desc->pEdit = (void *)pArea;
olc.c:    ch->desc->connected = CON_AEDITOR;
olc.c:        ch->desc->pEdit = (void *)pMob2;
olc.c:        ch->desc->connected = CON_MAEDITOR;
olc.c:          if(!str_cmp(sedit_in_use,ch->name))
olc.c:        pArea = ch->in_room->area;
olc.c:      pArea = ch->in_room->area;
olc.c:    location = ( arg[0] == '\0' ) ? ch->in_room : find_location( ch, arg );
olc.c:    if ( ch->in_room != location && room_is_private( location ) )
olc.c:    for ( rch = location->people; rch; rch = rch->next_in_room )
olc.c:	one_argument( rch->name, buf );
olc.c:	   if ((pReset->arg1) == (ch->in_room->vnum) || fAll)
olc.c:    AREA_DATA  *pArea = ch->in_room->area;
olc.c:	   if ( (pRoomIndex->vnum) == (ch->in_room->vnum) || fAll ||  ( fMob && is_name(arg1, pMob2->player_name) ))
olc.c:		mob_load_room = ch->in_room->vnum;
olc.c:	   if ( (pReset->arg3) == (ch->in_room->vnum) || fAll || ( fObj && is_name(arg1,pObj2->short_descr ) ) )
olc.c:		obj_load_room = ch->in_room->vnum;
olc.c:	   if ( (obj_load_room) == (ch->in_room->vnum) || fAll || ( fObj && is_name(arg1,pObj2->short_descr ) ) )
olc.c:	    if ( ( mob_load_room ) == (ch->in_room->vnum) || fAll ||  (fObj && is_name(arg1, pObj2->short_descr ) ))
olc.c:	   obj_load_room = ch->in_room->vnum;
olc.c:	    if ( ( mob_load_room ) == (ch->in_room->vnum) || fAll || (fObj && is_name(arg1, pObj2->short_descr ) ))
olc.c:	   obj_load_room = ch->in_room->vnum;
olc.c:	    if ( ( pReset->arg1 ) == (ch->in_room->vnum) || fAll || ( fDoor && is_name(arg1, dir_name[pReset->arg2] ) ))
olc.c:	if (( pReset->arg1 ) == ( ch->in_room->vnum) )
olc.c:        if ( ch->in_room->area->reset_first != NULL )
olc.c:    if ( !IS_BUILDER( ch, ch->in_room->area ) )
olc.c:        AREA_DATA *pArea = ch->in_room->area;
olc.c:            if ( ch->in_room->area->reset_first == NULL )
olc.c:                    pReset->arg1    = ch->in_room->vnum;
olc.c:                    pReset->arg1    = ch->in_room->vnum;
olc.c:/* check for mob == to ch->In_area */
olc.c:		        if ( ch->in_room->area != pMobIndex->load_with_area && !IS_OPTIVISION(ch) )
olc.c:             pReset->arg3    = ch->in_room->vnum;
olc.c:		else if ( ch->in_room->area != pObjIndex->in_area && !IS_OPTIVISION(ch) )
olc.c:		if ( ch->in_room->area != pObjIndex->in_area && !IS_OPTIVISION(ch) )
olc.c:           pReset->arg3     = ch->in_room->vnum;
olc.c:            add_reset( ch->in_room->area, pReset, atoi( arg1 ) );
olc.c:pArea = ch->in_room->area;
olc.c:    save_resets(ch->in_room->area, argument );
olc.c:    pArea = ch->in_room->area;
olc.c:    pArea = ch->in_room->area;
olc.c:      if ( IS_SET(ch->in_room->area->area_flags, AREA_VIRTUAL ) )
olc.c:      save_area( ch->in_room->area, ch, arg2 );
olc.c:      REMOVE_BIT( ch->in_room->area->area_flags, AREA_CHANGED );
olc.c:      save_area( ch->in_room->area, ch, "rooms" );
olc.c:      if ( IS_SET(ch->in_room->area->area_flags, AREA_VIRTUAL ) )
olc.c:      save_area( ch->in_room->area, ch, "objs" );
olc.c:      if ( IS_SET(ch->in_room->area->area_flags, AREA_VIRTUAL ) )
olc.c:      save_area( ch->in_room->area, ch, "mobs" );
olc.c:      if ( IS_SET(ch->in_room->area->area_flags, AREA_VIRTUAL ) )
olc.c:      save_area( ch->in_room->area, ch, "shops" );
olc.c:      if ( IS_SET(ch->in_room->area->area_flags, AREA_VIRTUAL ) )
olc.c:      save_area( ch->in_room->area, ch, "events" );
olc.c:      if ( IS_SET(ch->in_room->area->area_flags, AREA_VIRTUAL ) )
olc.c:      save_area( ch->in_room->area, ch, "all" );
olc.c:      REMOVE_BIT( ch->in_room->area->area_flags, AREA_CHANGED );
olc.c:    if ( !ch->pcdata )
olc.c:        return ch->desc->original;
olc.c:  pArea = ch->in_room->area;
olc.c:	    if ( ( pRoomtemp = get_room_index( ch->room_template ) ) == NULL )
olc.c:		   proom->area		= ch->in_room->area;
olc.c:   		   if (ch->logon_data != NULL)
olc.c:		   ch->logon_data->rooms++;
olc.c:     SET_BIT(ch->in_room->area->area_flags, AREA_CHANGED );
raedit.c:	    race_list[ race ].security = UMAX(1, ch->pcdata->security );
raedit.c:	    strncpy( race_list[ race ].builders, ch->name, 30 );
raedit.c:	    if ( ch->desc->editing == NULL )
raedit.c:		ch->desc->editing = editing_data_alloc();
raedit.c:	    ch->desc->editing->vnum = race ;
raedit.c:	    ch->desc->connected = CON_RAEDITOR;
raedit.c:    if ( ch->desc->editing == NULL )
raedit.c:	ch->desc->editing = editing_data_alloc();
raedit.c:    ch->desc->editing->vnum = race ;
raedit.c:    ch->desc->connected = CON_RAEDITOR;
raedit.c:    race = ch->desc->editing->vnum;
raedit.c:	ch->desc->connected = CON_PLAYING;
raedit.c:    if ( ch->pcdata->security > race_list[ race ].security &&
raedit.c:	!is_name( ch->name, race_list[ race ].builders ) ) 
recycle.c:    if ( ch->in_room == NULL )
recycle.c:    if (ch->logon_data != NULL )
recycle.c:    if (!str_cmp(ch->logon_data->exit, "Logged-IN") )
recycle.c:	strncpy( ch->logon_data->exit, "Unknown", 30 );
recycle.c:    if ( IS_NPC( ch ) && ch->leader != NULL && IS_SET( ch->act, ACT_PET ) )
recycle.c:	ch->leader->pet = NULL;
recycle.c:    ch->mount = NULL;
recycle.c:    ch->pet = NULL; /* just in case */
recycle.c:    if ( ch == mob_list_update[ch->mob_update_number] )
recycle.c:       mob_list_update[ch->mob_update_number] = ch->mob_next_update;
recycle.c:	for ( prev = mob_list_update[ch->mob_update_number]; prev != NULL; prev = prev->mob_next_update )
recycle.c:		prev->mob_next_update = ch->mob_next_update;
recycle.c:        if ( ch->pcdata->pcclan != NULL )
recycle.c:            free_pcclan_data(ch->pcdata->pcclan);
recycle.c:    ch->event = NULL;
recycle.c:    if ( ch->group )
recycle.c:    	if ( ch->group->leader == ch )
recycle.c:   if ( ch->master )
recycle.c:   if ( ch->follower )
recycle.c:    if (ch->inside_area != NULL )
recycle.c:	free_inside_area_data(ch->inside_area);
recycle.c:	ch->inside_area = NULL;
recycle.c:	if ( ch->pcdata->pcclan == NULL || get_room_index( ch->pcdata->pcclan->clan->recall_room ) == NULL )
recycle.c:	    char_to_room( ch, get_room_index( race_table[ ch->race ][ ch->sex ].die ) );
recycle.c:	    char_to_room( ch, get_room_index( ch->pcdata->pcclan->clan->recall_room ) );
recycle.c:    for ( obj = ch->carrying; obj != NULL; obj = obj_next )
recycle.c:	--ch->pIndexData->count;
recycle.c:    else if ( ch->pcdata->corpse != NULL )
recycle.c:	extract_obj( ch->pcdata->corpse );
recycle.c:    if ( ch->desc != NULL && ch->desc->original != NULL )
recycle.c:	wch_next = wch->next;
recycle.c:	if ( wch->reply == ch )
recycle.c:	    wch->reply = NULL;
recycle.c:	if ( wch->mount == ch )
recycle.c:	    wch->mount = NULL;
recycle.c:	if ( is_name(wch->dislikes, ch->name) )
recycle.c:	    wch->dislikes[0] = '\0'; 
recycle.c:	if ( is_name(wch->hunting, ch->name) )
recycle.c:	    wch->hunting[0] = '\0'; 
recycle.c:	    if ( wch->pIndexData != NULL 
recycle.c:	      && ( wch->spec_fun == spec_thug || wch->spec_fun ==spec_nightmare ) )
recycle.c:       char_list = ch->next;
recycle.c:		prev->next = ch->next;
recycle.c:    if ( ch->desc != NULL)
recycle.c:	    if ( !str_cmp( finger->name, ch->name ) && !IS_SET( ch->plr, PLR_WIZINVIS ) )
recycle.c:	ch->desc->character = NULL;
redit.c:    pRoom = ch->in_room;
redit.c:        ch->desc->pEdit = NULL;
redit.c:        ch->desc->connected = CON_PLAYING;
redit.c:	ch->edit_menu = 0;
redit.c:	ch->edit_buffer[0] = '\0';
redit.c:	if (ch->edit_menu == REDIT_EVENT_MENU )
redit.c:	if (ch->edit_menu == REDIT_DOOR_MENU )
redit.c:	if (ch->edit_menu == REDIT_MENU )
redit.c:	if (ch->edit_menu > 2 )
redit.c:	if (ch->edit_menu == REDIT_EXTRA_MENU )
redit.c:	if (ch->edit_menu == REDIT_SPEC_MENU )
redit.c:	if (ch->edit_menu == REDIT_EVENT_MENU )
redit.c:	if (ch->edit_menu == REDIT_DOOR_MENU )
redit.c:	if (ch->edit_menu == REDIT_MENU )
redit.c:	ch->edit_menu = REDIT_EXTRA_MENU ;
redit.c:	strncpy( ch->edit_buffer, "Extra->", 80 );
redit.c:	ch->edit_menu = REDIT_EVENT_MENU ;
redit.c:	strncpy( ch->edit_buffer, "Events->", 80 );
redit.c:		ch->edit_menu = REDIT_MENU ;
redit.c:		ch->edit_buffer[0] = '\0';
redit.c:		ch->edit_menu = REDIT_MENU ;
redit.c:		ch->edit_buffer[0] = '\0';
redit.c:	ch->edit_menu = REDIT_DOOR_MENU ;
redit.c:	strncpy( ch->edit_buffer, "Doors->", 80 );
redit.c:		ch->edit_menu = REDIT_MENU ;
redit.c:		ch->edit_buffer[0] = '\0';
redit.c:	ch->edit_menu = REDIT_SPEC_MENU ;
redit.c:	strncpy( ch->edit_buffer, "Special->", 80 );
redit.c:		ch->edit_menu = REDIT_MENU ;
redit.c:		ch->edit_buffer[0] = '\0';
redit.c:	    if ( ( pRoomtemp = get_room_index( ch->room_template ) ) == NULL )
redit.c:	    if ( ( pRoomtemp = get_room_index( ch->room_template ) ) == NULL )
redit.c: 	pArea = ch->in_room->area;
redit.c:	    ch->desc->pEdit = (void *)pRoomIndex;
redit.c:	    pRoom = (ROOM_INDEX_DATA *)ch->desc->pEdit;
redit.c:	if (ch->pnote == NULL) 
redit.c:	ch->in_room->description = str_dup(ch->pnote->text);
redit.c:	SET_BIT(ch->in_room->area->area_flags, AREA_CHANGED );
redit.c:	ch->pnote->text = str_dup( ch->in_room->description);
redit.c:	SET_BIT(ch->in_room->area->area_flags, AREA_CHANGED );
redit.c:    pRoom = ch->in_room;
redit.c: 	    if (ch->inside_area != NULL )
redit.c:	    free_inside_area_data(ch->inside_area);
redit.c:	    ch->inside_area = NULL;
redit.c:    ch->desc->connected = CON_REDITOR;
redit.c:    ch->edit_menu = REDIT_MENU;
redit.c:    ch->edit_buffer[0] = '\0';
redit.c:    if (ch->logon_data != NULL)
redit.c:	ch->logon_data->rooms++;
redit.c:    SET_BIT(ch->in_room->area->area_flags, AREA_CHANGED );
room_commands.c:    room_interpret( ch->in_room, argument );
room_commands.c:    for ( ch = pRoom->people ; ch != NULL && !is_name( arg, ch->name ) ; ch = ch->next_in_room );
room_commands.c:	ch->perm_stat[ stat ]  += value;
room_commands.c:	ch->perm_stat[ stat2 ] -= value;
room_commands.c:    for ( ch = pRoom->people ; ch != NULL && !is_name( arg, ch->name ) ; ch = ch->next_in_room );
room_commands.c:	ch->max_mana[ ELEMENT_FIRE ] = UMAX( 0 , ch->max_mana[ ELEMENT_FIRE ] + value );
room_commands.c:	ch->pcdata->perm_mana[ ELEMENT_FIRE ] = ch->max_mana[ ELEMENT_FIRE ];
room_commands.c:	ch->mana[ ELEMENT_FIRE ] = ch->max_mana[ ELEMENT_FIRE ];
room_commands.c:	ch->max_mana[ ELEMENT_WATER ] = UMAX( 0 , ch->max_mana[ ELEMENT_WATER ] + value );
room_commands.c:	ch->mana[ ELEMENT_WATER ] = ch->max_mana[ ELEMENT_WATER ];
room_commands.c:	ch->pcdata->perm_mana[ ELEMENT_WATER ] = ch->max_mana[ ELEMENT_WATER ];
room_commands.c:	ch->max_mana[ ELEMENT_EARTH ] = UMAX( 0 , ch->max_mana[ ELEMENT_EARTH ] + value );
room_commands.c:	ch->mana[ ELEMENT_EARTH ] = ch->max_mana[ ELEMENT_EARTH ];
room_commands.c:	ch->pcdata->perm_mana[ ELEMENT_EARTH ] = ch->max_mana[ ELEMENT_EARTH ];
room_commands.c:	ch->max_mana[ ELEMENT_WIND ] = UMAX( 0 , ch->max_mana[ ELEMENT_WIND ] + value );
room_commands.c:	ch->mana[ ELEMENT_WIND ] = ch->max_mana[ ELEMENT_WIND ];
room_commands.c:	ch->pcdata->perm_mana[ ELEMENT_WIND ] = ch->max_mana[ ELEMENT_WIND ];
room_commands.c:	ch->max_mana[ ELEMENT_SPIRIT ] = UMAX( 0 , ch->max_mana[ ELEMENT_SPIRIT ] + value );
room_commands.c:	ch->mana[ ELEMENT_SPIRIT ] = ch->max_mana[ ELEMENT_SPIRIT ];
room_commands.c:	ch->pcdata->perm_mana[ ELEMENT_SPIRIT ] = ch->max_mana[ ELEMENT_SPIRIT];
room_commands.c:	ch->max_hit = UMAX( 1, ch->max_hit + value );
room_commands.c:	ch->hit = ch->max_hit;
room_commands.c:	ch->pcdata->perm_hit = ch->max_hit;
room_commands.c:	ch->max_move = UMAX( 1, ch->max_move + value );
room_commands.c:	ch->move = ch->max_move;
room_commands.c:	ch->pcdata->perm_move = ch->max_move;
room_commands.c:	ch->gold[ coin_type ] = UMAX( 0, ch->gold[ coin_type ] + value );
room_commands.c:	ch->gold[ race_table[ ch->race ][ ch->sex ].world ] += value;
room_commands.c:	ch->practice = UMAX( 0, ch->practice + value );
room_commands.c:	    REMOVE_BIT( ch->perm_vuln, flag );
room_commands.c:	    SET_BIT( ch->perm_vuln, flag );
room_commands.c:	    TOGGLE_BIT( ch->perm_vuln, flag );
room_commands.c:	    REMOVE_BIT( ch->perm_res, flag );
room_commands.c:	    SET_BIT( ch->perm_res, flag );
room_commands.c:	    TOGGLE_BIT( ch->perm_res, flag );
room_commands.c:	    REMOVE_BIT( ch->perm_imm, flag );
room_commands.c:	    SET_BIT( ch->perm_imm, flag );
room_commands.c:	    TOGGLE_BIT( ch->perm_imm, flag );
room_commands.c:		    REMOVE_BIT( ch->affected_by, flag );
room_commands.c:		    REMOVE_BIT( ch->pcdata->perm_aff, flag );
room_commands.c:		    SET_BIT( ch->affected_by, flag );
room_commands.c:		    SET_BIT( ch->pcdata->perm_aff, flag );
room_commands.c:		    TOGGLE_BIT( ch->affected_by, flag );
room_commands.c:		    TOGGLE_BIT( ch->pcdata->perm_aff, flag );
room_commands.c:		    REMOVE_BIT( ch->affected_by_2, flag );
room_commands.c:		    REMOVE_BIT( ch->pcdata->perm_aff_2, flag );
room_commands.c:		    SET_BIT( ch->affected_by_2, flag );
room_commands.c:		    SET_BIT( ch->pcdata->perm_aff_2, flag );
room_commands.c:		    TOGGLE_BIT( ch->affected_by_2, flag );
room_commands.c:		    TOGGLE_BIT( ch->pcdata->perm_aff_2, flag );
room_commands.c:	    ch->pcdata->learned[sn] = value;
room_commands.c:    ch->perm_stat[ stat ] += value;
room_commands.c:    for ( ch = pRoom->people ; ch != NULL && !is_name( arg, ch->name ) ; ch = ch->next_in_room ) ;
room_commands.c:	for ( race = number_range( 0, top_race - 1 ) ; !race_table[ race ][ ch->sex ].pc_race ; race = number_range( 0, top_race - 1 ) );
room_commands.c:        ch->race = race;
room_commands.c:	    ch->perm_stat[i] = race_table[race][ch->sex].stats[i];
room_commands.c:	    ch->mod_stat[i]=0;
room_commands.c:	ch->affected_by = race_table[race][ch->sex].aff;
room_commands.c:	ch->pcdata->perm_aff = race_table[race][ch->sex].aff;
room_commands.c:	ch->imm_flags	= race_table[race][ch->sex].imm;
room_commands.c:	ch->res_flags	= race_table[race][ch->sex].res;
room_commands.c:	ch->vuln_flags	= race_table[race][ch->sex].vuln;
room_commands.c:	ch->form	= race_table[race][ch->sex].form;
room_commands.c:	ch->size = race_table[race][ch->sex].size;
room_commands.c:	ch->height = get_height_size( ch->size );
room_commands.c:	ch->weight = get_weight_size( ch->size );
room_commands.c:        strncpy( ch->pcdata->prompt, "`yHp %c`y/`w%H `yMv %d`y/`w%V`y-> ", 160 );
room_commands.c:	        ch->max_mana[i] = race_table[ ch->race ][ ch->sex ].mana_die[ i ] * race_table[ ch->race ][ ch->sex ].mana_dice[ i ] + race_table[ ch->race ][ ch->sex ].mana_bonus[ i ];
room_commands.c:		ch->max_mana[i] *= 20;
room_commands.c:	        ch->mana[i] = ch->max_mana[ i ];
room_commands.c:	        ch->pcdata->perm_mana[i] = ch->max_mana[ i ];
room_commands.c:		    if ( race_table[ ch->race ][ ch->sex ].gained[sn] == TRUE )
room_commands.c:			ch->pcdata->learned[sn] = race_table[ ch->race ][ ch->sex ].starting[sn];
room_commands.c:			ch->pcdata->learned[sn] = 0;
room_commands.c:	    obj_to_char(create_object(get_obj_index(race_table[ch->race][ch->sex].map)),ch); 
room_commands.c:		    if ( race_table[a][b].world == race_table[ ch->race ][ ch->sex ].world )
room_commands.c:			ch->pcdata->learned[ race_table[a][b].language ] = 50;
room_commands.c:	    ch->pcdata->learned[ gsn_common ] = 100;
room_commands.c:            if ( race_table[ ch->race ][ ch->sex ].world == 0 )
room_commands.c:                ch->pcdata->learned[ gsn_swim ] = 100;
room_commands.c:	    if ( ch->race == 8 )
room_commands.c:		ch->pcdata->learned[ gsn_sneak ] = 100;
room_commands.c:	    ch->pcdata->learned[ race_table[ ch->race ][ ch->sex ].language ] = 100;
room_commands.c:	    ch->comm = COMM_PROMPT|COMM_COMBINE;
room_commands.c:    for ( ch = pRoom->people; ch != NULL && !is_name( arg, ch->name ) ; ch = ch->next_in_room );
room_commands.c:    for ( ch = pRoom->people ; ch != NULL ; ch = ch->next_in_room )
room_commands.c:	if ( is_name( arg, ch->name ) )
room_commands.c:    for ( ch = char_list ; ch != NULL ;  ch = ch->next )
room_commands.c:	if ( is_name( arg, ch->name ) )
room_commands.c:    for ( ch = pRoom->people ; ch != NULL ; ch = ch->next_in_room )
room_commands.c:    for ( ch = pRoom->people ; ch != NULL ; ch = ch->next_in_room )
room_commands.c:        for ( ch = pRoom->people ; ch != NULL && !is_name( arg, ch->name ) ; ch = ch->next_in_room );
room_commands.c:	    next = ch->next_in_room;
room_commands.c:            SET_BIT( ch->plr2, PLR_SPECIAL_PASS );
room_commands.c:            REMOVE_BIT( ch->plr2, PLR_SPECIAL_PASS );
room_commands.c:        SET_BIT( ch->plr2, PLR_SPECIAL_PASS );
room_commands.c:        REMOVE_BIT( ch->plr2, PLR_SPECIAL_PASS );
room_commands.c:        for ( ch = pRoom->people ; ch != NULL && !is_name( arg, ch->name ) ; ch = ch->next_in_room );
room_commands.c:	    next = ch->next_in_room;
room_commands.c:            SET_BIT( ch->plr2, PLR_SPECIAL_PASS );
room_commands.c:            REMOVE_BIT( ch->plr2, PLR_SPECIAL_PASS );
room_commands.c:        SET_BIT( ch->plr2, PLR_SPECIAL_PASS );
room_commands.c:        REMOVE_BIT( ch->plr2, PLR_SPECIAL_PASS );
save.c:    if ( ch->level < 2 )
save.c:    if ( ch->desc != NULL && ch->desc->original != NULL )
save.c:	ch = ch->desc->original;
save.c:	  if (!str_cmp( ch->name, wizlist->name ) )
save.c:		strncpy( wizlist->title, ch->pcdata->imm_title, 30 );
save.c:		strncpy( wizlist->name, capitalize(ch->name), 30 );
save.c:		strncpy( wizlist->title, ch->pcdata->imm_title, 30 );
save.c:    sprintf( strsave, "%s%s%s%s", PLAYER_DIR, initial(ch->name), "/", 
save.c:	capitalize( ch->name ) );
save.c:	if ( ch->carrying != NULL )
save.c:	    fwrite_obj( ch, ch->carrying, fp, 0 );
save.c:	if ( ch->pcdata->corpse != NULL )
save.c:	    fwrite_corpse( ch, ch->pcdata->corpse, fp, 0 );
save.c:	if (ch->pet != NULL && ch->pet->in_room == ch->in_room)
save.c:	    fwrite_pet(ch->pet,fp,"#PET\n");
save.c:	if (ch->mount != NULL && ch->mount->in_room == ch->in_room)
save.c:	    fwrite_pet(ch->mount,fp,"#MOUNT\n");
save.c:    fprintf( fp, "Name %s~\n",	ch->name		);
save.c:    if (ch->mate[0] != '\0')
save.c:      	fprintf( fp, "Mate  %s~\n",	ch->mate	);
save.c:    if (ch->short_descr[0] != '\0')
save.c:      	fprintf( fp, "ShD  %s~\n",	ch->short_descr	);
save.c:    if( ch->long_descr[0] != '\0' )
save.c:	fprintf( fp, "LnD  %s~\n",	ch->long_descr	);
save.c:    if (ch->description != NULL )
save.c:    	fprintf( fp, "Desc %s~\n",	ch->description	);
save.c:    fprintf( fp, "Race %s~\n", race_list[ch->race].name );
save.c:    fprintf( fp, "Sex  %d\n",	ch->sex			);
save.c:    fprintf( fp, "Levl %d\n",	ch->level		);
save.c:    for ( char_quests = ch->char_quests; char_quests != NULL ; char_quests = char_quests->next )
save.c:    if ( ch->pnote != NULL )
save.c:	fprintf( fp, "No_sender %s~\n", ch->pnote->sender );
save.c:	fprintf( fp, "No_list %s~\n", ch->pnote->to_list );
save.c:	fprintf( fp, "No_subject %s~\n", ch->pnote->subject );
save.c:	fprintf( fp, "No_text %s~\n", ch->pnote->text );
save.c:    fprintf( fp, "Bday %d\n", ch->birth_day );
save.c:    fprintf( fp, "Bmonth %d\n", ch->birth_month );
save.c:    fprintf( fp, "Color %d\n",	ch->color		);
save.c:        ch->colors[0],
save.c:        ch->colors[1],
save.c:        ch->colors[2],
save.c:        ch->colors[3],
save.c:        ch->colors[4],
save.c:        ch->colors[5],
save.c:        ch->colors[6],
save.c:        ch->colors[7],
save.c:        ch->colors[8],
save.c:        ch->colors[9],
save.c:        ch->colors[10]);
save.c:	ch->played + (int) (current_time - ch->logon)	);
save.c:    for ( read_notes = ch->pcdata->read_notes ; read_notes != NULL ; read_notes = read_notes->next )
save.c:    fprintf( fp, "Scro %d\n", 	ch->lines		);
save.c:        (  ch->in_room == get_room_index( ROOM_VNUM_LIMBO )
save.c:        && ch->was_in_room != NULL )
save.c:            ? ch->was_in_room->vnum
save.c:            : ch->in_room == NULL ? 3001 : ch->in_room->vnum );
save.c:	ch->hit, ch->max_hit, ch->move, ch->max_move );
save.c:	ch->mana[ 0 ],	 ch->max_mana[ 0 ],
save.c:	ch->mana[ 1 ],	 ch->max_mana[ 1 ],
save.c:	ch->mana[ 2 ],	 ch->max_mana[ 2 ],
save.c:	ch->mana[ 3 ],	 ch->max_mana[ 3 ],
save.c:	ch->mana[ 4 ],	 ch->max_mana[ 4 ]);
save.c:    fprintf( fp, "Prompt %s~\n",	ch->pcdata->prompt );
save.c:    if (ch->pcdata->Oprompt[0] != '\0' )
save.c:    	fprintf( fp, "Oprompt %s~\n",	ch->pcdata->Oprompt );
save.c:    fprintf( fp, "Castle %d\n",		ch->castle_area );
save.c:    fprintf( fp, "InfoAct %ld\n",	ch->infoact );
save.c:    fprintf( fp, "Coins %ld %ld %ld %ld\n",	ch->gold[0], ch->gold[1], ch->gold[2], ch->gold[3] );
save.c:    fprintf( fp, "Exp  %ld\n",	ch->exp			);
save.c:    fprintf( fp, "Kills  %d\n",	ch->kills		);
save.c:    fprintf( fp, "Pkills  %d\n",	ch->pkills	);
save.c:    fprintf( fp, "Died  %d\n",	ch->died	);
save.c:    if (ch->imm_flags != 0)
save.c:	fprintf( fp, "Immune %ld\n", 	ch->imm_flags );
save.c:    if (ch->res_flags != 0)
save.c:	fprintf( fp, "Res %ld\n", 	ch->res_flags );
save.c:    if (ch->vuln_flags != 0)
save.c:	fprintf( fp, "Vuln %ld\n", 	ch->vuln_flags );
save.c:    if (ch->perm_imm != 0)
save.c:	fprintf( fp, "Perm_imm %ld\n",	ch->perm_imm );
save.c:    if (ch->perm_res != 0)
save.c:	fprintf( fp, "Perm_res %ld\n",	ch->perm_res );
save.c:    if (ch->perm_vuln != 0)
save.c:	fprintf( fp, "Perm_vuln %ld\n",	ch->perm_vuln );
save.c:    if (ch->plr != 0)
save.c:	fprintf( fp, "Plr  %ld\n",   ch->plr		);
save.c:    if (ch->cmd_groups != 0)
save.c:	fprintf( fp, "CMD_Groups  %ld\n",   ch->cmd_groups	);
save.c:    if (ch->guilds != 0)
save.c:	fprintf( fp, "Guilds  %ld\n",   ch->guilds	);
save.c:    if (ch->quest_points != 0)
save.c:	fprintf( fp, "Quests_points  %d\n",   ch->quest_points	);
save.c:    if (ch->room_template != 0)
save.c:	fprintf( fp, "Room_template  %ld\n",   ch->room_template	);
save.c:    if (ch->plr2 != 0)
save.c:	fprintf( fp, "Plr2  %ld\n",   ch->plr2		);
save.c:    if (ch->act != 0)
save.c:	fprintf( fp, "Act  %ld\n",   ch->act		);
save.c:    if (ch->act2 != 0)
save.c:	fprintf( fp, "Act2  %ld\n",   ch->act2		);
save.c:    if (ch->affected_by != 0)
save.c:	fprintf( fp, "AfBy %ld\n",	ch->affected_by	);
save.c:    if (ch->affected_by != 0)
save.c:	fprintf( fp, "AfBy2 %ld\n",	ch->affected_by_2);
save.c:    if ( ch->pcdata->perm_aff != 0 )
save.c:	fprintf( fp, "Perm_aff %ld\n",	ch->pcdata->perm_aff );
save.c:    if ( ch->pcdata->perm_aff_2 != 0 )
save.c:	fprintf( fp, "Perm_aff_2 %ld\n",	ch->pcdata->perm_aff_2 );
save.c:    fprintf( fp, "Comm %ld\n",   ch->comm		);
save.c:	if ( ch->pcdata->debt != NULL )
save.c:		ch->pcdata->debt->amount,
save.c:		ch->pcdata->debt->type,
save.c:		ch->pcdata->debt->due,	
save.c:		ch->pcdata->debt->vnum,
save.c:		ch->pcdata->debt->timer);
save.c:	if ( !fNight && mob->pIndexData != NULL && mob->pIndexData->spec_fun == spec_nightmare && !str_cmp( ch->name, mob->hunting ) )
save.c:	if ( !fThug && mob->pIndexData != NULL && mob->pIndexData->spec_fun == spec_thug && !str_cmp( ch->name, mob->hunting ) )
save.c:    if (ch->invis_level != 0)
save.c:	fprintf( fp, "Invi %d\n", 	ch->invis_level	);
save.c:	ch->position == POS_FIGHTING ? POS_STANDING : ch->position );
save.c:    if (ch->practice != 0)
save.c:    	fprintf( fp, "Prac %d\n",	ch->practice	);
save.c:    if (ch->saving_throw != 0)
save.c:	fprintf( fp, "Save  %d\n",	ch->saving_throw);
save.c:    if (ch->hitroll != 0)
save.c:	fprintf( fp, "Hit   %d\n",	ch->hitroll	);
save.c:    if (ch->damroll != 0)
save.c:	fprintf( fp, "Dam   %d\n",	ch->damroll	);
save.c:    fprintf( fp, "AC %d\n", ch->armor );	
save.c:    fprintf( fp, "Height  %d\n",	ch->height	);
save.c:    fprintf( fp, "Weight  %d\n",	ch->weight	);
save.c:    if (ch->wimpy !=0 )
save.c:	fprintf( fp, "Wimp  %d\n",	ch->wimpy	);
save.c:	ch->perm_stat[STAT_STR],
save.c:	ch->perm_stat[STAT_INT],
save.c:	ch->perm_stat[STAT_WIS],
save.c:	ch->perm_stat[STAT_DEX],
save.c:	ch->perm_stat[STAT_CON],
save.c:	ch->perm_stat[STAT_CHR] );
save.c:	ch->mod_stat[STAT_STR],
save.c:	ch->mod_stat[STAT_INT],
save.c:	ch->mod_stat[STAT_WIS],
save.c:	ch->mod_stat[STAT_DEX],
save.c:	ch->mod_stat[STAT_CON],
save.c:	ch->mod_stat[STAT_CHR] );
save.c:	fprintf( fp, "Vnum %ld\n",	ch->pIndexData->vnum	);
save.c:	fprintf( fp, "Pass %s~\n",	ch->pcdata->pwd		);
save.c:	if (strlen(ch->pcdata->bamfin) != 0)
save.c:	    fprintf( fp, "Bin  %s~\n",	ch->pcdata->bamfin);
save.c:	if (strlen(ch->pcdata->bamfout) != 0)
save.c:		fprintf( fp, "Bout %s~\n",	ch->pcdata->bamfout);
save.c:	fprintf( fp, "Titl %s~\n",	ch->pcdata->title	);
save.c:	fprintf( fp, "TSex %d\n",	ch->pcdata->true_sex	);
save.c:	fprintf( fp, "Dreams %d\n",	ch->pcdata->dreams	);
save.c:	fprintf( fp, "Nmares %d\n",	ch->pcdata->nightmares	);
save.c:	fprintf( fp, "LLev %ld\n",	ch->pcdata->last_level	);
save.c:	fprintf( fp, "HVP %d %d\n", ch->pcdata->perm_hit, 
save.c:						   ch->pcdata->perm_move);
save.c:	fprintf( fp, "Manap %d %d %d %d %d\n", ch->pcdata->perm_mana[ 0 ],
save.c:	    ch->pcdata->perm_mana[ 1 ],
save.c:	    ch->pcdata->perm_mana[ 2 ],
save.c:	    ch->pcdata->perm_mana[ 3 ],
save.c:	    ch->pcdata->perm_mana[ 4 ]);
save.c:	    ch->pcdata->condition[0],
save.c:	    ch->pcdata->condition[1],
save.c:	    ch->pcdata->condition[2] );
save.c:	    fprintf( fp, "Minerals %d\n", ch->pcdata->minerals[i] );
save.c:	    fprintf( fp, "Forge %d\n", ch->pcdata->forge[i] );
save.c:	    if ( skill_table[sn].name != NULL && ch->pcdata->learned[sn] > 0 )
save.c:		    ch->pcdata->learned[sn], ( ch->pcdata->teaching[sn] ? 1 : 0 ) ,skill_table[sn].name );
save.c:	    if ( skill_table[sn].name != NULL && ch->pcdata->skill_mod[sn] != 0 )
save.c:		    ch->pcdata->skill_mod[sn], skill_table[sn].name );
save.c:    for ( paf = ch->affected; paf != NULL; paf = paf->next )
save.c:    fprintf( fp, "Bank %ld\n", ch->bank);
save.c:    fprintf( fp, "Home %ld\n", ch->home); 
save.c:    fprintf( fp, "Security %d\n", ch->pcdata->security);
save.c:    fprintf( fp, "Imm_title %s~\n", ch->pcdata->imm_title);
save.c:    if ( ch->pcdata->pcclan != NULL )
save.c:       fprintf( fp, "Clan %s~\n",   ch->pcdata->pcclan->clan->name  );
save.c:       fprintf( fp, "ClanRank %d\n",ch->pcdata->pcclan->clanrank );
save.c:    for ( ch = pRoomIndex->people; ch != NULL; ch = ch->next_in_room )
save.c:	if ( IS_NPC( ch ) && ch->spec_fun == spec_guard_dog )
save.c:	   fprintf( fp, "Guard %ld %ld\n", ch->pIndexData->vnum, pRoomIndex->vnum );
save.c:	fprintf( fp, "Room %ld\n",   race_table[ ch->race ][ ch->sex ].begin );
save.c:	sprintf( buf,"Bad room for corpse save: %s\n\r", ch->name );
save.c:	ch->pcdata			= alloc_perm( sizeof(*ch->pcdata) );
save.c:	ch->pcdata			= pcdata_free;
save.c:    *ch->pcdata				= pcdata_zero;
save.c:    ch->desc				= d;
save.c:    ch->mob_next_update			= NULL;
save.c:    ch->pcdata->deck			= NULL;
save.c:    ch->pcdata->hand			= NULL;
save.c:    ch->pcdata->played			= NULL;
save.c:    ch->pcdata->discarded		= NULL;
save.c:    strncpy( ch->name, name, 30 );
save.c:    ch->description = &str_empty[0];
save.c:    strncpy( ch->pcdata->prompt, "<%h/%Hhp %v/%Vmv> ", 160 );
save.c:    ch->pcdata->Oprompt[0]		= '\0';
save.c:    ch->mate[0]	 			= '\0';
save.c:    ch->short_descr[0] 			= '\0';
save.c:    ch->long_descr[0] 			= '\0';
save.c:    ch->in_room 			= NULL;
save.c:    ch->was_in_room 			= NULL;
save.c:    ch->version				= 10;
save.c:    ch->hunting[0]			= '\0';
save.c:    ch->dislikes[0]			= '\0';
save.c:    ch->race				= 1;
save.c:    ch->died				= 0;
save.c:    ch->infoact				= 0;
save.c:    ch->pkills				= 0;
save.c:    ch->kills				= 0;
save.c:    ch->pet				= 0;
save.c:    ch->mount				= NULL;
save.c:    ch->played				= 0;
save.c:    ch->logon				= current_time;
save.c:    ch->affected_by			= 0;
save.c:    ch->affected_by_2			= 0;
save.c:    ch->armor				= 0;
save.c:    ch->castle_area			= 0;
save.c:    ch->imm_flags			= 0;
save.c:    ch->vuln_flags			= 0;
save.c:    ch->res_flags			= 0;
save.c:    ch->perm_imm			= 0;
save.c:    ch->perm_vuln			= 0;
save.c:    ch->perm_res			= 0;
save.c:    ch->hands_free			= 2;
save.c:    ch->act				= 0;
save.c:    ch->plr				= PLR_NOSUMMON;
save.c:    ch->cmd_groups			= CMD_GROUP_PLAYER;
save.c:    ch->guilds				= DEFAULT;
save.c:    ch->quest_points			= 0;
save.c:    ch->char_quests			= NULL;
save.c:    ch->room_template			= 0;
save.c:    ch->plr2				= 0;
save.c:    ch->act2				= 0;
save.c:    ch->comm				= COMM_COMBINE 
save.c:    ch->invis_level			= 0;
save.c:    ch->practice			= 0;
save.c:    ch->regen_timer			= current_time;
save.c:    ch->position			= POS_STANDING;
save.c:    ch->lines				= 40;
save.c:    ch->hitroll				= 0;
save.c:    ch->damroll				= 0;
save.c:    ch->move				= 0;
save.c:    ch->hit				= 0;
save.c:        ch->mana[i] 			= 0;
save.c:	ch->max_mana[i]			= 0;
save.c:        ch->pcdata->perm_mana[i]	= 0;
save.c:    ch->wimpy			 	= 0;
save.c:    ch->color			        = 0;
save.c:    ch->timer			        = 0;
save.c:    ch->gos_timer		        = 0;
save.c:    ch->outfit_timer		        = 0;
save.c:    ch->gold[0]			        = 0;
save.c:    ch->gold[1]			        = 0;
save.c:    ch->gold[2]			        = 0;
save.c:    ch->gold[3]			        = 0;
save.c:    ch->saving_throw			= 0;
save.c:    ch->edit_flags			= 0;
save.c:    ch->edit_menu			= 0;
save.c:    ch->birth_day			= 0;
save.c:    ch->birth_month			= 0;
save.c:	ch->pcdata->learned[ sn  ] = 0;
save.c:	ch->pcdata->teaching[ sn ] = FALSE;
save.c:	ch->pcdata->skill_mod[ sn ] = 0;
save.c:	ch->pcdata->minerals[ i ] = 0;
save.c:	ch->pcdata->forge[ i ] = 0;
save.c:    ch->pcdata->home_timer		= 0;
save.c:    ch->pcdata->confirm_delete		= FALSE;
save.c:    ch->pcdata->pwd[0]			= '\0';
save.c:    ch->pcdata->bamfin[0]		= '\0';
save.c:    ch->pcdata->bamfout[0]		= '\0';
save.c:    ch->pcdata->title[0]		= '\0';
save.c:    ch->pcdata->imm_title[0]		= '\0';
save.c:	ch->perm_stat[stat]		= 13;
save.c:    ch->pcdata->corpse			= NULL;
save.c:    ch->pcdata->debt			= NULL;
save.c:    ch->pcdata->read_notes		= NULL;
save.c:    ch->pcdata->perm_hit		= 0;
save.c:    ch->pcdata->perm_move		= 0;
save.c:    ch->pcdata->perm_aff		= race_table[ch->race][ch->sex].aff;
save.c:    ch->pcdata->perm_aff_2		= race_table[ch->race][ch->sex].aff2;
save.c:    ch->pcdata->true_sex		= 0;
save.c:    ch->pcdata->dreams			= 0;
save.c:    ch->pcdata->nightmares		= 0;
save.c:    ch->pcdata->pcclan         		= NULL;
save.c:    ch->pcdata->last_level		= 0;
save.c:    ch->pcdata->condition[COND_THIRST]	= 48; 
save.c:    ch->pcdata->condition[COND_FULL]	= 48;
save.c:    ch->pcdata->security		= 9;
save.c:    ch->bank				= 0;
save.c:    ch->home				= 0;   
save.c:    ch->inside_area			= NULL;   
save.c:    ch->exp				= 0;   
save.c:    ch->size				= 2;
save.c:    ch->height				= 0;
save.c:    ch->weight				= 0;
save.c:	    if ( !str_cmp( ch->name, finger->name ) )
save.c:	    strncpy( finger->name, ch->name, 30 );
save.c:	    finger->race = ch->race;
save.c:	    finger->sex = ch->sex;
save.c:	    finger->level = ( IS_IMMORTAL( ch ) ? 61 : ch->level );
save.c:	    strncpy( finger->title, IS_IMMORTAL( ch ) ? ch->pcdata->imm_title : ch->pcdata->title, 80 );
save.c:	ch->size = race_table[ch->race][ch->sex].size;
save.c:	if ( ch->height	== 0 )
save.c:	    ch->height = get_height_size( ch->size );
save.c:	if ( ch->weight	== 0 )
save.c:	    ch->weight = get_weight_size( ch->size );
save.c:	ch->dam_type = race_table[ch->race][ch->sex].dam_type; /*punch */
save.c:	ch->affected_by = ch->affected_by|ch->pcdata->perm_aff;
save.c:	ch->affected_by_2 = ch->affected_by_2|ch->pcdata->perm_aff_2;
save.c:	ch->perm_imm	|= race_table[ ch->race ][ ch->sex ].imm;
save.c:	ch->perm_res	|= race_table[ ch->race ][ ch->sex ].res;
save.c:	ch->perm_vuln	|= race_table[ ch->race ][ ch->sex ].vuln;
save.c:	ch->imm_flags	= ch->imm_flags | ch->perm_imm;
save.c:	ch->res_flags	= ch->res_flags | ch->perm_res;
save.c:	ch->vuln_flags	= ch->vuln_flags | ch->perm_vuln;
save.c:	ch->form	= race_table[ch->race][ch->sex].form;
save.c:	    KEY( "Act2",	ch->act2,		fread_number( fp ) );
save.c:	    KEY( "AffectedBy",	ch->affected_by,	fread_number( fp ) );
save.c:	    KEY( "AfBy",	ch->affected_by,	fread_number( fp ) );
save.c:	    KEY( "AfBy2",	ch->affected_by_2,	fread_number( fp ) );
save.c:		ch->armor = fread_number(fp);
save.c:		ch->armor = t/4;
save.c:		if (ch->version == 0)
save.c:		  paf->level = ch->level;
save.c:		if ( ch->version > 7 )
save.c:		   ch->mod_stat[stat] = fread_number(fp);
save.c:		    ch->perm_stat[stat] = fread_number(fp);
save.c:	    KEY( "Bank",	ch->bank,		fread_number( fp ) );
save.c:	    	strncpy( ch->pcdata->bamfin,	fread_string( fp ), 160 );
save.c:	    	strncpy( ch->pcdata->bamfout,	fread_string( fp ), 160 );
save.c:	    KEY( "Bday",	ch->birth_day,		fread_number( fp ) );
save.c:	    KEY( "Bmonth",	ch->birth_month,	fread_number( fp ) );
save.c:		ch->castle_area = fread_number( fp );
save.c:		ch->pcdata->pcclan = pcclan_data_alloc();
save.c:		ch->pcdata->pcclan->clan = clan_lookup(fread_string( fp ) );
save.c:		if ( ch->pcdata->pcclan->clan != NULL && is_name( ch->name, ch->pcdata->pcclan->clan->leader_name ) )
save.c:		    ch->pcdata->pcclan->clan->leader = ch;
save.c:		if ( ch->pcdata->pcclan->clan != NULL && is_name( ch->name, ch->pcdata->pcclan->clan->sponser_name ) )
save.c:		    ch->pcdata->pcclan->clan->sponser = ch;
save.c:		char_quests->next = ch->char_quests;
save.c:		ch->char_quests = char_quests;
save.c:	    KEY( "Color",	ch->color,		fread_number( fp ) );
save.c:            ch->colors[0] = fread_number( fp );
save.c:            ch->colors[1] = fread_number( fp );
save.c:            ch->colors[2] = fread_number( fp );
save.c:            ch->colors[3] = fread_number( fp );
save.c:            ch->colors[4] = fread_number( fp );
save.c:            ch->colors[5] = fread_number( fp );
save.c:            ch->colors[6] = fread_number( fp );
save.c:            ch->colors[7] = fread_number( fp );
save.c:            ch->colors[8] = fread_number( fp );
save.c:            ch->colors[9] = fread_number( fp );
save.c:            ch->colors[0] = fread_number( fp );
save.c:            ch->colors[1] = fread_number( fp );
save.c:            ch->colors[2] = fread_number( fp );
save.c:            ch->colors[3] = fread_number( fp );
save.c:            ch->colors[4] = fread_number( fp );
save.c:            ch->colors[5] = fread_number( fp );
save.c:            ch->colors[6] = fread_number( fp );
save.c:            ch->colors[7] = fread_number( fp );
save.c:            ch->colors[8] = fread_number( fp );
save.c:            ch->colors[9] = fread_number( fp );
save.c:            ch->colors[10] = fread_number( fp );
save.c:            if ( ch->pcdata->pcclan != NULL )
save.c:                KEY( "ClanRank",      ch->pcdata->pcclan->clanrank,   fread_number( fp ) );
save.c:	        ch->gold[0]=fread_number( fp );
save.c:	        ch->gold[1]=fread_number( fp );
save.c:	        ch->gold[2]=fread_number( fp );
save.c:	        ch->gold[0]=fread_number( fp );
save.c:	        ch->gold[1]=fread_number( fp );
save.c:	        ch->gold[2]=fread_number( fp );
save.c:	        ch->gold[3]=fread_number( fp );
save.c:		ch->pcdata->condition[0] = fread_number( fp );
save.c:		ch->pcdata->condition[1] = fread_number( fp );
save.c:		ch->pcdata->condition[2] = fread_number( fp );
save.c:	    KEY("Comm",		ch->comm,		fread_number( fp ) ); 
save.c:	    KEY( "CMD_Groups",	ch->cmd_groups,		fread_number( fp ) );
save.c:	    KEY( "Damroll",	ch->damroll,		fread_number( fp ) );
save.c:	    KEY( "Dam",		ch->damroll,		fread_number( fp ) );
save.c:	    KEY( "Description",	ch->description,	fread_string( fp ) );
save.c:	    KEY( "Dreams",	ch->pcdata->dreams,     fread_number( fp ) );
save.c:	    KEY( "Desc",	ch->description,	fread_string( fp ) );
save.c:		ch->pcdata->debt = debt_data_alloc();
save.c:		ch->pcdata->debt->amount = fread_number(fp);
save.c:		ch->pcdata->debt->type = fread_number(fp);
save.c:		ch->pcdata->debt->due = fread_number(fp);
save.c:		ch->pcdata->debt->vnum = fread_number(fp);
save.c:		ch->pcdata->debt->timer = fread_number(fp);
save.c:	    KEY( "Died",	ch->died,		fread_number( fp ) );
save.c:		ch->exp = fread_number(fp);
save.c:		if ( ch->version < 9 )
save.c:		    old_to_level = exp_table_old[ch->level +1].exp_at_level - ch->exp;
save.c:		    ch->exp = exp_table[ch->level+1].exp_at_level - old_to_level;
save.c:		ch->pcdata->forge[forge] = fread_number( fp );
save.c:	    KEY( "Gold",	ch->gold[ race_table[ ch->race ][ ch->sex ].world ],		fread_number( fp ) );
save.c:	    KEY( "Guilds",	ch->guilds, 	fread_number( fp ) );
save.c:	    KEY( "Hands_free",	ch->hands_free,		fread_number( fp ) );
save.c:	    KEY( "Hitroll",	ch->hitroll,		fread_number( fp ) );
save.c:	    KEY( "Height",	ch->height,		fread_number( fp ) );
save.c:	    KEY( "Hit",		ch->hitroll,		fread_number( fp ) );
save.c:            KEY( "Home",	ch->home,		fread_number( fp ) ); 
save.c:		ch->hit		= fread_number( fp );
save.c:		ch->max_hit	= fread_number( fp );
save.c:		if ( ch->version > 6 )
save.c:		    ch->mana[i] = mana;
save.c:		    ch->max_mana[i] = max_mana;
save.c:		    ch->mana[i] = mana + ch->level * 30;
save.c:		    ch->max_mana[i] = max_mana + ch->level * 30;
save.c:		ch->move	= fread_number( fp );
save.c:		ch->max_move	= fread_number( fp );
save.c:		ch->hit		= fread_number( fp );
save.c:		ch->max_hit	= fread_number( fp );
save.c:		ch->move	= fread_number( fp );
save.c:		ch->max_move	= fread_number( fp );
save.c:                ch->pcdata->perm_hit	= fread_number( fp );
save.c:		if ( ch->version > 6 )
save.c:                    ch->pcdata->perm_mana[i] = mana;
save.c:                    ch->pcdata->perm_mana[i] = mana + ch->level * 30;
save.c:                ch->pcdata->perm_move   = fread_number( fp );
save.c:                ch->pcdata->perm_hit	= fread_number( fp );
save.c:                ch->pcdata->perm_move   = fread_number( fp );
save.c:	    KEY( "InfoAct",	ch->infoact,		fread_number( fp ) );
save.c:	    KEY( "InvisLevel",	ch->invis_level,	fread_number( fp ) );
save.c:	    KEY( "Invi",	ch->invis_level,	fread_number( fp ) );
save.c:	    	strncpy( ch->pcdata->imm_title,	fread_string( fp ), 30 );
save.c:	    KEY( "Immune",	ch->imm_flags,		fread_number( fp ) );
save.c:	    KEY( "Kills",		ch->kills,	fread_number( fp ) );
save.c:	    KEY( "LastLevel",	ch->pcdata->last_level, fread_number( fp ) );
save.c:	    KEY( "LLev",	ch->pcdata->last_level, fread_number( fp ) );
save.c:	    KEY( "Level",	ch->level,		fread_number( fp ) );
save.c:	    KEY( "Lev",		ch->level,		fread_number( fp ) );
save.c:	    KEY( "Levl",	ch->level,		fread_number( fp ) );
save.c:	    strncpy( ch->long_descr,		fread_string( fp ), 80 );
save.c:	    	strncpy( ch->mate,		fread_string( fp ), 12 );
save.c:		ch->pcdata->minerals[mineral] = fread_number( fp );
save.c:		if ( ch->version > 6 )
save.c:		    ch->mana[i] = fread_number( fp );
save.c:		    ch->max_mana[i] = fread_number( fp );
save.c:		    ch->mana[i] = fread_number( fp );
save.c:		    ch->max_mana[i] = fread_number( fp );
save.c:		    ch->max_mana[i] = ch->max_mana[i] + ch->level * 30 ;
save.c:		if (ch->version > 6 )
save.c:		    ch->pcdata->perm_mana[i] = fread_number( fp );
save.c:		    ch->pcdata->perm_mana[i] = fread_number( fp );
save.c:		    ch->pcdata->perm_mana[i] = ch->pcdata->perm_mana[i] + ch->level * 30;
save.c:		strncpy( ch->name, fread_string( fp ), 30 );
save.c:	    KEY( "Nmares",	ch->pcdata->nightmares,   fread_number( fp ) );
save.c:		     read_notes->next = ch->pcdata->read_notes;
save.c:		     ch->pcdata->read_notes = read_notes;
save.c:		strncpy( ch->pnote->sender, fread_string( fp ), 30 );
save.c:		strncpy( ch->pnote->to_list, fread_string( fp ), 80 );
save.c:		strncpy( ch->pnote->subject, fread_string( fp ), 30 );
save.c:		ch->pnote->text		= fread_string( fp );
save.c:		strncpy( ch->pcdata->Oprompt, fread_string( fp ), 160 );
save.c:		strncpy( ch->pcdata->prompt, fread_string( fp ), 160 );
save.c:	    	strncpy( ch->pcdata->pwd,	fread_string( fp ), 30 );
save.c:	    KEY( "Perm_aff",	ch->pcdata->perm_aff,	fread_number( fp ) );
save.c:	    KEY( "Perm_aff_2",	ch->pcdata->perm_aff_2,	fread_number( fp ) );
save.c:	    KEY( "Perm_imm", 	ch->perm_imm,		fread_number( fp ) );
save.c:	    KEY( "Perm_res", 	ch->perm_res,		fread_number( fp ) );
save.c:	    KEY( "Perm_vuln", 	ch->perm_vuln,		fread_number( fp ) );
save.c:	    KEY( "Pkills",	ch->pkills,		fread_number( fp ) );
save.c:	    KEY( "Played",	ch->played,		fread_number( fp ) );
save.c:	    KEY( "Plyd",	ch->played,		fread_number( fp ) );
save.c:	    KEY( "Plr",		ch->plr,		fread_number( fp ) );
save.c:	    KEY( "Plr2",	ch->plr2,		fread_number( fp ) );
save.c:	   /* KEY( "Position",	ch->position,		fread_number( fp ) ); */
save.c:		ch->position = fread_number (fp );
save.c:		if ( ch->position > POS_STANDING )
save.c:		ch->position = POS_STANDING;
save.c:	   /* KEY( "Pos",		ch->position,		fread_number( fp ) );*/
save.c:	    KEY( "Practice",	ch->practice,		fread_number( fp ) );
save.c:	    KEY( "Prac",	ch->practice,		fread_number( fp ) );
save.c:	    KEY( "Quests_points",	ch->quest_points, 	fread_number( fp ) );
save.c:	    KEY( "Res",		ch->res_flags,		fread_number( fp ) );
save.c:		if ( ( ch->race = race_lookup(fread_string( fp ) ) ) == -1 )
save.c:		    ch->race = 4;
save.c:		    read_notes->next = ch->pcdata->read_notes;
save.c:		    ch->pcdata->read_notes = read_notes;
save.c:		ch->in_room = get_room_index( fread_number( fp ) );
save.c:		if ( ch->in_room == NULL )
save.c:		    ch->in_room = get_room_index( ROOM_VNUM_LIMBO );
save.c:	    KEY( "Room_template",	ch->room_template, 	fread_number( fp ) );
save.c:	    KEY( "SavingThrow",	ch->saving_throw,	fread_number( fp ) );
save.c:	    KEY( "Save",	ch->saving_throw,	fread_number( fp ) );
save.c:	    KEY( "Scro",	ch->lines,		fread_number( fp ) );
save.c:	    KEY( "Sex",		ch->sex,		fread_number( fp ) );
save.c:	    	strncpy( ch->short_descr,	fread_string( fp ), 80 );
save.c:	    	strncpy( ch->short_descr,	fread_string( fp ), 80 );
save.c:		ch->pcdata->security = fread_number (fp );
save.c:		if ( ch->version < 9 ) /* Need to reset everyone */
save.c:		ch->pcdata->security = 9;
save.c:		    ch->pcdata->learned[sn] = value;
save.c:		    ch->pcdata->teaching[sn] = ( teach == 1 );
save.c:		    ch->pcdata->learned[sn] = value;
save.c:		    ch->pcdata->learned[sn] = value;
save.c:		    ch->pcdata->skill_mod[sn] = value;
save.c:            KEY( "TrueSex",     ch->pcdata->true_sex,  	fread_number( fp ) );
save.c:	    KEY( "TSex",	ch->pcdata->true_sex,   fread_number( fp ) );
save.c:		ch->practice +=- fread_number( fp ) * 3 / 2;
save.c:		strncpy( ch->pcdata->title, fread_string( fp ), 80 );
save.c:    		if (ch->pcdata->title[0] != '.' && ch->pcdata->title[0] != ',' 
save.c:		&&  ch->pcdata->title[0] != '!' && ch->pcdata->title[0] != '?')
save.c:		    sprintf( buf, " %s", ch->pcdata->title );
save.c:		    strncpy( ch->pcdata->title, buf, 80 );
save.c:	    KEY( "Version",     ch->version,		fread_number ( fp ) );
save.c:	    KEY( "Vers",	ch->version,		fread_number ( fp ) );
save.c:	    KEY( "Vuln",	ch->vuln_flags,		fread_number( fp ) );
save.c:		ch->pIndexData = get_mob_index( fread_number( fp ) );
save.c:	    KEY( "Wimpy",	ch->wimpy,		fread_number( fp ) );
save.c:	    KEY( "Weight",	ch->weight,		fread_number( fp ) );
save.c:	    KEY( "Wimp",	ch->wimpy,		fread_number( fp ) );
save.c:		if ( ch->version > 7 )
save.c:		    ch->pet = pet;
save.c:		    ch->mount = pet;
save.c:	  && ( in_room = get_room_index( race_table[ ch->race ][ ch->sex ].begin ) ) == NULL )
save.c:		if (ch->version == 0)
save.c:		if ( ch->version > 7 ) 
save.c:			strncpy(obj->owner , ch->name,30 );
save.c:			ch->pcdata->corpse = obj;
save.c:			strncpy(obj->owner , ch->name,30 );
save.c:		if (ch->version == 0)
save.c:		if ( ch->version > 7 ) 
save.c:			    strncpy(obj->owner , ch->name,30 );
save.c:			    strncpy(obj->owner , ch->name,30 );
scr.c:    room = ch->in_room;
scr.c:        SET_BIT( ch->act2, ACT2_HALT );
scr.c:         for ( Trig = ch->triggers; Trig != NULL; Trig = Trig->next )
scr.c:    	world = ch->in_room->area->world;
scr.c:	for (rch = room->people; rch != NULL; rch = rch->next_in_room)
scr.c:	    if (!is_name(arg1, rch->name) )
scr.c:    if (ch->pcdata->learned[sn])
scr.c:    int world=ch->in_room->area->world;    
scr.c:	room = ch->in_room;
scr.c:	for (rch = room->people; rch != NULL; rch = rch->next_in_room)
scr.c:	    if (!is_name(arg3, rch->name) )
scr.c:    strncpy( ch->task, argument, 80 );
scr.c:        if ( IS_SET(ch->act2, ACT2_TRACKSCR) )
scr.c:   ch->walkto = atoi(buf);
scr.c:   SET_BIT(ch->act2, ACT2_WALKTO );
scr.c:   ch->walkto = atoi(buf);
scr.c:   SET_BIT(ch->act2, ACT2_WALKTO_MOB );
scr.c:   ch->walkto = atoi(arg2);
scr.c:   ch->walkfrom = atoi(arg1);
scr.c:   SET_BIT(ch->act2, ACT2_STEERING );
scr.c:        if ( ch->in_room->exit[door] == NULL 
scr.c:          || !IS_SET(ch->in_room->exit[door]->exit_info, EX_ISDOOR) ) 
scr.c:    	    for ( lock_list = ch->in_room->exit[door]->lock ; lock_list != NULL ; lock_list = lock_next)
scr.c:        if ( ch->in_room->exit[door]->to_room != NULL
scr.c:          && ch->in_room->exit[door]->to_room->exit[rev_dir[door]] != NULL
scr.c:          && IS_SET( ch->in_room->exit[door]->to_room->exit[rev_dir[door]]->exit_info, EX_ISDOOR ) )
scr.c:    	    for ( lock_list = ch->in_room->exit[door]->to_room->exit[rev_dir[door]]->lock ; lock_list != NULL ; lock_list = lock_next)
scr.c:        if ( ch->in_room->exit[door] == NULL 
scr.c:          || !IS_SET(ch->in_room->exit[door]->exit_info, EX_ISDOOR) ) 
scr.c:    	    for ( lock_list = ch->in_room->exit[door]->lock ; lock_list != NULL ; lock_list = lock_next)
scr.c:        if ( ch->in_room->exit[door]->to_room != NULL
scr.c:          && ch->in_room->exit[door]->to_room->exit[rev_dir[door]] != NULL
scr.c:          && IS_SET( ch->in_room->exit[door]->to_room->exit[rev_dir[door]]->exit_info, EX_ISDOOR ) )
scr.c:    	    for ( lock_list = ch->in_room->exit[door]->to_room->exit[rev_dir[door]]->lock ; lock_list != NULL ; lock_list = lock_next)
scr.c:        if ( ch->in_room->exit[door] == NULL )
scr.c:            TOGGLE_BIT(ch->in_room->exit[door]->exit_info, get_exit_flag_number( arg3 ));
scr.c:        if ( ch->in_room->exit[door] == NULL 
scr.c:          || !IS_SET(ch->in_room->exit[door]->exit_info, EX_ISDOOR) ) 
scr.c:        REMOVE_BIT( ch->in_room->exit[door]->exit_info, EX_CLOSED );
scr.c:        if ( ch->in_room->exit[door]->to_room != NULL
scr.c:          && ch->in_room->exit[door]->to_room->exit[rev_dir[door]] != NULL
scr.c:          && IS_SET( ch->in_room->exit[door]->to_room->exit[rev_dir[door]]->exit_info, EX_ISDOOR ) )
scr.c:        REMOVE_BIT( ch->in_room->exit[door]->to_room->exit[rev_dir[door]]->exit_info, EX_CLOSED );
scr.c:        if ( ch->in_room->exit[door] == NULL 
scr.c:          || !IS_SET(ch->in_room->exit[door]->exit_info, EX_ISDOOR) ) 
scr.c:        SET_BIT( ch->in_room->exit[door]->exit_info, EX_CLOSED );
scr.c:        if ( ch->in_room->exit[door]->to_room != NULL
scr.c:          && ch->in_room->exit[door]->to_room->exit[rev_dir[door]] != NULL
scr.c:          && IS_SET( ch->in_room->exit[door]->to_room->exit[rev_dir[door]]->exit_info, EX_ISDOOR ) )
scr.c:        SET_BIT( ch->in_room->exit[door]->to_room->exit[rev_dir[door]]->exit_info, EX_CLOSED );
scr.c:       do_follow( victim ,ch->name);
scr.c:       ch->leader = victim;
scr.c:       SET_BIT(ch->act, ACT_PET);
scr.c:    for ( trig = ch->triggers; trig != NULL; trig = trig->next )
scr.c:        if ( IS_SET(ch->act2, ACT2_HALT) 
scr.c:	if ( ch->task[0] != '\0' && strlen(ch->task) > 0 )
skills.c:	if ( IS_SET( ch->guilds, guild_table[ x ].flag ) )
skills.c:    if ( guilds >= 3 && ch->guilds != 1)
skills.c:    else if ( ch->level < 25 && guilds >= 1 && ch->guilds != 1 )
skills.c:    else if ( ch->level < 35 && guilds >= 2 && ch->guilds != 1)
skills.c:    if ( ch->guilds <= 1)
skills.c:    	cost = 1000 * ch->level + 10000 * guilds * guilds;
skills.c:    sprintf( buf, "It will cost you %ld %s to join this guild.\n\r", cost, coin_names[ ch->in_room->area->world ] );
skills.c:	if ( IS_SET( ch->guilds, guild_table[ x ].flag ) )
skills.c:    if ( guilds >= 1 && ch->guilds != 1 )
skills.c:    if ( guilds >= 3 && ch->guilds != 1)
skills.c:    else if ( ch->level < 25 && guilds >= 1 && ch->guilds != 1)
skills.c:    else if ( ch->level < 35 && guilds >= 2 && ch->guilds != 1)
skills.c:	if ( ( pexit = ch->in_room->exit[ door ] ) != NULL
skills.c:    if ( IS_SET( ch->guilds, guild ) )
skills.c:    if ( ch->guilds <= 1 )
skills.c:	cost = 1000 * ch->level + 10000 * guilds * guilds;
skills.c:    if ( get_money_total( ch, ch->in_room->area->world ) < cost )
skills.c:        sprintf( buf, "It will cost you %ld %s to join this guild.\n\r", cost, coin_names[ ch->in_room->area->world ] );
skills.c:    get_char_money( ch, cost, ch->in_room->area->world );
skills.c:    sprintf( buf, "%s has joined %s!\n\r", capitalize( ch->name),guild_table[ i ].title );
skills.c:    if ( ch->guilds == 1 )
skills.c:	REMOVE_BIT ( ch->guilds, DEFAULT );
skills.c:    SET_BIT( ch->guilds, guild );
skills.c:    for ( trainer = ch->in_room->people; 
skills.c:	    sprintf( buf, "Cost in %s\n\r", coin_names[ ch->in_room->area->world ] );
skills.c:		if ( skill_table[ sn ].prerequisite[ i ].pgsn != NULL && ch->pcdata->learned[ *skill_table[ sn ].prerequisite[ i ].pgsn ] < skill_table[ sn ].prerequisite[ i ].percent )
skills.c:		      && ch->pcdata->learned[ gsn_element_power[ i ][ skill_table[ sn ].element[ i ].level ] ] < 1 )
skills.c:            if ( ch->pcdata->learned[sn]
skills.c:		&& get_skill_level( ch, sn) > ch->level )
skills.c:	    if ( skill_table[ sn ].prerequisite[ i ].pgsn != NULL && ch->pcdata->learned[ *skill_table[ sn ].prerequisite[ i ].pgsn ] < skill_table[ sn ].prerequisite[ i ].percent )
skills.c:	          && ch->pcdata->learned[ gsn_element_power[ i ][ skill_table[ sn ].element[ i ].level ] ] < 1 )
skills.c:        if (ch->pcdata->learned[sn])
skills.c:        if (ch->practice < get_skill_cost( ch, sn ) 
skills.c:	       && get_skill_level( ch, sn ) > ch->level ) )
skills.c:	if ( IS_NPC( trainer ) && get_money_total( ch, ch->in_room->area->world ) < ( cost ) )
skills.c:	    get_char_money( ch, cost, ch->in_room->area->world ); 
skills.c:	     ch->practice -= get_skill_cost( ch, sn );
skills.c:	    ch->pcdata->learned[sn] = UMAX( 40, race_table[ ch->race ][ ch->sex ].starting[ sn ] );
skills.c:	    ch->pcdata->learned[sn] = UMAX( 25, race_table[ ch->race ][ ch->sex ].starting[ sn ] );
skills.c:        ch->practice -= get_skill_cost( ch, sn );
skills.c:	if ( ch->skills == NULL )
skills.c:	for ( skills = ch->skills ; skills != NULL ; skills = skills->next )
skills.c:        if (ch->pcdata->learned[sn] > 0 || ch->pcdata->skill_mod[sn] > 0 )
skills.c:              sprintf(buf,"`R%-20s`w  %3d%%  ",skill_table[sn].name, ch->pcdata->learned[sn]);
skills.c:              sprintf(buf,"`B%-20s`w  %3d%%  ",skill_table[sn].name, ch->pcdata->learned[sn]);
skills.c:              sprintf(buf,"`y%-20s`w  %3d%%  ",skill_table[sn].name, ch->pcdata->learned[sn]);
skills.c:              sprintf(buf,"`C%-20s`w  %3d%%  ",skill_table[sn].name, ch->pcdata->learned[sn]);
skills.c:              sprintf(buf,"`W%-20s`w  %3d%%  ",skill_table[sn].name, ch->pcdata->learned[sn]);
skills.c:              sprintf(buf,"`K%-20s`w  %3d%%  ",skill_table[sn].name, ch->pcdata->learned[sn]);
skills.c:              sprintf(buf,"%-20s  %3d%%  ",skill_table[sn].name, ch->pcdata->learned[sn]);
skills.c:	if ( ch->pcdata->skill_mod[sn] != 0 )
skills.c:	    sprintf(buf, "%2d%%   ",ch->pcdata->skill_mod[sn]);
skills.c:	if ( ch->skills == NULL )
skills.c:	for ( skills = ch->skills ; skills != NULL ; skills = skills->next )
skills.c:        if (ch->pcdata->learned[sn] >= 0)
skills.c:	if ( ch->skills == NULL )
skills.c:	for ( skills = ch->skills ; skills != NULL ; skills = skills->next )
skills.c:        if (ch->pcdata->learned[sn] > 0 || ch->pcdata->skill_mod[sn] > 0 )
skills.c:              sprintf(buf,"%2d  `R%-20s`w  %3d%%  ",lev,skill_table[sn].name, ch->pcdata->learned[sn]);
skills.c:              sprintf(buf,"%2d  `B%-20s`w  %3d%%  ",lev,skill_table[sn].name, ch->pcdata->learned[sn]);
skills.c:              sprintf(buf,"%2d  `y%-20s`w  %3d%%  ",lev,skill_table[sn].name, ch->pcdata->learned[sn]);
skills.c:              sprintf(buf,"%2d  `C%-20s`w  %3d%%  ",lev,skill_table[sn].name, ch->pcdata->learned[sn]);
skills.c:              sprintf(buf,"%2d  `W%-20s`w  %3d%%  ",lev,skill_table[sn].name, ch->pcdata->learned[sn]);
skills.c:              sprintf(buf,"%2d  `K%-20s`w  %3d%%  ",lev,skill_table[sn].name, ch->pcdata->learned[sn]);
skills.c:              sprintf(buf,"%2d  %-20s  %3d%%  ",lev,skill_table[sn].name, ch->pcdata->learned[sn]);
skills.c:	if ( ch->pcdata->skill_mod[sn] != 0 )
skills.c:	  sprintf(buf, "%2d%%   ",ch->pcdata->skill_mod[sn]);
skills.c:        if ( ch->pcdata->learned[ gsn_hand_to_hand[ 0 ] ] > 0 
skills.c:	&& ch->pcdata->learned[ gsn_hand_to_hand[ 0 ] ] < 100 )
skills.c:	if ( ch->pcdata->learned[ gsn_hand_to_hand[ 1 ] ] > 0 
skills.c:	&& ch->pcdata->learned[ gsn_hand_to_hand[ 1 ] ] < 100 )
skills.c:        if ( ch->pcdata->learned[ gsn_hand_to_hand[ 2 ] ] > 0 
skills.c:	&& ch->pcdata->learned[ gsn_hand_to_hand[ 2 ] ] < 100 )
skills.c:        if ( ch->pcdata->learned[ gsn_hand_to_hand[ 0 ] ] > 0 
skills.c:	&& ch->pcdata->learned[ gsn_hand_to_hand[ 0 ] ] < 100 )
skills.c:        if ( ch->pcdata->learned[ gsn_hand_to_hand[ 1 ] ] > 0 
skills.c:	&& ch->pcdata->learned[ gsn_hand_to_hand[ 1 ] ] < 100 )
skills.c:        if ( ch->pcdata->learned[ gsn_hand_to_hand[ 2 ] ] > 0 
skills.c:	&& ch->pcdata->learned[ gsn_hand_to_hand[ 2 ] ] < 100 )
skills.c:    if ( ch->pcdata->learned[ gsn_weapon_power[ type ][ 0 ] ] > 0 
skills.c:    && ch->pcdata->learned[ gsn_weapon_power[ type ][ 0 ] ] < 100 )
skills.c:    if ( ch->pcdata->learned[ gsn_weapon_power[ type ][ 1 ] ] > 0 
skills.c:    && ch->pcdata->learned[ gsn_weapon_power[ type ][ 1 ] ] < 100 )
skills.c:    if ( ch->pcdata->learned[ gsn_weapon_power[ type ][ 2 ] ] > 0 
skills.c:    && ch->pcdata->learned[ gsn_weapon_power[ type ][ 2 ] ] < 100 )
skills.c:    for ( af = ch->affected ; af != NULL ; af = af_next )
skills.c:		if ( ch->max_mana[ i ] >= 5000 )
skills.c:            	ch->max_mana[ i ] += num;
skills.c:            	ch->pcdata->perm_mana[i] += num;
skills.c:    for ( af = ch->affected ; af != NULL ; af = af_next )
skills.c:    if ( ( IS_SET( ch->guilds, CLANNGUARD ) || IS_SET( ch->guilds, TATH ) || IS_SET( ch->guilds, MAR_TUUR ) ) 
skills.c:	&& ch->pcdata->perm_move < 1000 && ch->move > 5
skills.c:        ch->pcdata->perm_move++;
skills.c:        ch->move++;
skills.c:        ch->max_move++;
skills.c:      && ch->level < get_skill_level ( ch, sn ) )
skills.c:    ||  ch->pcdata->learned[sn] == 0
skills.c:    ||  ch->pcdata->learned[sn] == 100)
skills.c:    if ( ch->pcdata->learned[sn] < 50 )
skills.c:    	chance += ch->level;
skills.c:    if ( ch->pcdata->learned[sn] < 75 && ch->pcdata->learned[sn] >= 50 )
skills.c:    	chance += ch->level;
skills.c:    if ( ch->pcdata->learned[sn] < 100 && ch->pcdata->learned[sn] >= 75 )
skills.c:    	chance += ch->level;
skills.c:	chance = URANGE(5,ch->pcdata->learned[sn], 95);
skills.c:	    ch->pcdata->learned[sn]++;
skills.c:	chance = URANGE(5,ch->pcdata->learned[sn]/2,30);
skills.c:	    ch->pcdata->learned[sn] += number_range(1,3);
skills.c:	    ch->pcdata->learned[sn] = UMIN(ch->pcdata->learned[sn],100);
special.c:    if ( ch->position != POS_FIGHTING )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim );
special.c:    if ( ch->position != POS_FIGHTING )
special.c:    if ( ch->position != POS_FIGHTING )
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, NULL );
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	spell_armor( skill_lookup( "armor" ), ch->level, ch, victim );
special.c:	spell_courage( skill_lookup( "courage" ), ch->level, ch, victim );
special.c:	    ch->level, ch, victim );
special.c:	    ch->level, ch, victim );
special.c:	    ch->level, ch, victim );
special.c:	spell_refresh( skill_lookup( "refresh" ), ch->level, ch, victim );
special.c:    if ( ch->position != POS_FIGHTING )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	if ( ch->level >= min_level )
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim );
special.c:    if ( ch->position != POS_FIGHTING )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	if ( ch->level >= min_level )
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim );
special.c:    if ( ch->position != POS_FIGHTING )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	if ( ch->level >= min_level )
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim );
special.c:    if ( ch->position != POS_FIGHTING )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	if ( ch->level >= min_level )
special.c:    (*skill_table[sn].spell_fun) ( sn, ch->level, ch, victim );
special.c:    obj_to_room( create_object( get_obj_index( OBJ_VNUM_DUNG ) ) , ch->in_room ); 
special.c:    obj_to_room( obj , ch->in_room ); 
special.c:    if ( ch->position != POS_STANDING && ch->fighting != NULL  )
special.c:    if ( ch->hunting[0] == '\0' || ( victim = get_char_world( ch, ch->hunting ) ) == NULL 
special.c:  	|| ch->position != POS_STANDING || ch->fighting != NULL 
special.c:	|| ( ch->in_room->area == victim->in_room->area && ch->in_room != victim->in_room ) )
special.c:    if ( ch->in_room == victim->in_room )
special.c:    for ( rch = ch->in_room->people ; rch != NULL ; rch = rch->next_in_room )
special.c:	if ( !IS_NPC( rch ) && ch->in_room->vnum == rch->home )
special.c:    for ( rch = ch->in_room->people ; rch != NULL ; rch =rch->next_in_room )
special.c:    if ( ch->fighting != NULL )
special.c:    if ( ch->position != POS_STANDING )
special.c:    if ( ch->hunting[0] == '\0' || ( victim = get_char_world( ch, ch->hunting ) ) == NULL 
special.c:  	|| ch->position != POS_STANDING || ch->fighting != NULL 
special.c:	|| ( ch->in_room->area == victim->in_room->area && ch->in_room != victim->in_room ) )
special.c:    if ( ch->in_room == victim->in_room )
special.c:    if ( ch->fighting != NULL )
special.c:    if ( ch->position != POS_STANDING )
special.c:    if ( ch->hunting[0] == '\0' || ( victim = get_char_world( ch, ch->hunting ) ) == NULL 
special.c:  	|| ch->position != POS_STANDING || ch->fighting != NULL 
special.c:	|| ( ch->in_room->area == victim->in_room->area && ch->in_room != victim->in_room ) )
special.c:    if ( !IS_SET( ch->in_room->room_flags, ROOM_SAFE ) && ch->in_room == victim->in_room )
special.c:    if (ch->in_room->area == victim->in_room->area)
special.c:    for ( corpse = ch->in_room->contents; corpse != NULL; corpse = c_next )
special.c:	    obj_to_room( obj, ch->in_room );
special.c:    if ( !IS_AWAKE(ch) || ch->fighting != NULL )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:    for ( trash = ch->in_room->contents; trash != NULL; trash = trash_next )
special.c:	if ( time_info[ ch->in_room->area->world ].hour ==  time_table[ ch->in_room->area->world ].sunrise )
special.c:	if ( time_info[ ch->in_room->area->world ].hour == time_table[ ch->in_room->area->world ].sunset + 1 )
special.c:    if ( ch->fighting != NULL )
special.c:    if ( !move || ch->position < POS_SLEEPING )
special.c:    if ( ch->position != POS_FIGHTING
special.c:    || ( victim = ch->fighting ) == NULL
special.c:    ||   number_percent( ) > 2 * ch->level )
special.c:    spell_poison( gsn_poison, ch->level, ch, victim );
special.c:    if ( ch->position != POS_STANDING )
special.c:    for ( victim = ch->in_room->people; victim != NULL; victim = v_next )
special.c:	if ( IS_AWAKE(victim) && number_range( 0, ch->level ) == 0 )
special.c:	    	gold = victim->gold[ coin_type ] * UMIN(number_range( 1, 20 ),ch->level) / 100;
special.c:	    	gold = UMIN( gold, ch->level * ch->level * 20 );
special.c:		ch->gold[ coin_type ]     += gold;
special.c:	for ( rch = victim->in_room->people ; rch != NULL ; rch = rch->next_in_room )
string.c:    ch->desc->pString = pString;
string.c:    ch->desc->pString = pString;
string.c:    ch->desc->pString = pString;
string.c:            *ch->desc->pString = &str_empty[0];
string.c:            send_to_char( *ch->desc->pString, ch );
string.c:            strcpy(buf, *ch->desc->pString ); 
string.c:	    free_string(*ch->desc->pString );
string.c:	    *ch->desc->pString = str_dup( buf );
string.c:	   if (!check_string( *ch->desc->pString ) )
string.c:            *ch->desc->pString = string_replace( *ch->desc->pString, arg2, arg3 );
string.c:            *ch->desc->pString = format_string( *ch->desc->pString );
string.c:    strcpy( buf, *ch->desc->pString );
string.c:	if ( !check_string( *ch->desc->pString ) )
string.c:        ch->desc->pString = NULL;
string.c:	if (ch->desc->connected == CON_EDITING )
string.c:	ch->desc->connected = CON_PLAYING;
string.c:        free_string( *ch->desc->pString );
string.c:        *ch->desc->pString = str_dup( buf );
string.c:        ch->desc->pString = NULL;
string.c:    free_string( *ch->desc->pString );
string.c:    *ch->desc->pString = str_dup( buf );
tedit.c:    pTrigIndex = (TRIGGER_INDEX_DATA *)ch->desc->pEdit; 
tedit.c:        ch->desc->pEdit = NULL;
tedit.c:        ch->desc->connected = CON_PLAYING;
tedit.c:	strncpy( pTrigIndex->builders, ch->name, 30 );	
tedit.c:        ch->desc->pEdit = (void *)pTrigIndex;
tedit.c:        ch->desc->connected = CON_TEDITOR;
tedit.c:	strncpy( pTrigIndex->builders, ch->name, 30 );
tedit.c:        ch->desc->pEdit = (void *)pTrigIndex;
tedit.c:        ch->desc->connected = CON_TEDITOR;
update.c:	        obj_to_room( obj, ch->in_room );
update.c:    ROOM_INDEX_DATA * in_room = ch->in_room;
update.c:	if ( IS_SET( ch->res_flags, RES_WATER ) )
update.c:	else if ( IS_SET( ch->vuln_flags, VULN_WATER ) )
update.c:	for ( rch = ch->in_room->people ; rch != NULL ; rch = rch->next_in_room )
update.c:	  && !IS_SET( ch->imm_flags, IMM_WATER )
update.c:	for ( obj = ch->carrying ; obj != NULL ; obj = obj_next )
update.c:	for ( obj = ch->carrying ; obj != NULL ; obj = obj_next )
update.c:	if ( IS_SET( ch->res_flags, RES_WATER ) )
update.c:	else if ( IS_SET( ch->vuln_flags, VULN_WATER ) )
update.c:	for ( rch = ch->in_room->people ; rch != NULL ; rch = rch->next_in_room )
update.c:	  && !IS_SET( ch->imm_flags, IMM_WATER )
update.c:	ch->hit -= 2 * dice( 40, 10 ) + 100;
update.c:	if ( ch->position == POS_DEAD )
update.c:	if ( IS_SET( ch->res_flags, RES_WATER ) )
update.c:	else if ( IS_SET( ch->vuln_flags, VULN_WATER ) )
update.c:	for ( rch = ch->in_room->people ; rch != NULL ; rch = rch->next_in_room )
update.c:	  && !IS_SET( ch->imm_flags, IMM_WATER )
update.c:	if ( IS_SET( ch->res_flags, RES_WATER ) )
update.c:	else if ( IS_SET( ch->vuln_flags, VULN_WATER ) )
update.c:	for ( rch = ch->in_room->people ; rch != NULL ; rch = rch->next_in_room )
update.c:	  && !IS_SET( ch->imm_flags, IMM_WATER )
update.c:	if ( !IS_AFFECTED( ch, AFF_BLIND ) && !IS_SET(ch->affected_by_2,AFF_LIGHT_SENSITIVE) && number_range( 0, 200 ) == 0 
update.c:	if ( IS_SET( ch->res_flags, RES_WATER ) )
update.c:	else if ( IS_SET( ch->vuln_flags, VULN_WATER ) )
update.c:	for ( rch = ch->in_room->people ; rch != NULL ; rch = rch->next_in_room )
update.c:	  && !IS_SET( ch->imm_flags, IMM_WATER )
update.c:	for ( obj = ch->carrying ; obj != NULL ; obj = obj_next )
update.c:	if ( IS_SET( ch->res_flags, RES_WATER ) )
update.c:	else if ( IS_SET( ch->vuln_flags, VULN_WATER ) )
update.c:	for ( rch = ch->in_room->people ; rch != NULL ; rch = rch->next_in_room )
update.c:	  && !IS_SET( ch->imm_flags, IMM_WATER )
update.c:	for ( obj = ch->carrying ; obj != NULL ; obj = obj_next )
update.c:	for ( obj = ch->in_room->contents ; obj != NULL ; obj = obj_next )
update.c:		if ( ( pexit = ch->in_room->exit[ door ] ) != NULL
update.c:		  && to_room != ch->in_room )
update.c:	    while ( ( pexit = ch->in_room->exit[ ( door = number_range( 0, 5 ) ) ] ) == NULL
update.c:		  || to_room == ch->in_room );
update.c:	if ( IS_AFFECTED( ch, AFF_BLIND ) || IS_SET(ch->affected_by_2,AFF_LIGHT_SENSITIVE) || number_range( 0, 200 ) != 0 )
update.c:	if ( number_range( 0, 2000 ) == 0 && !IS_SET( ch->in_room->room_flags, ROOM_NO_RECALL ) )
update.c:	    if ( ch->fighting != NULL )
update.c:	for ( obj = ch->in_room->contents ; obj != NULL ; obj = obj_next )
update.c:		if ( ( pexit = ch->in_room->exit[ door ] ) != NULL
update.c:		  && to_room != ch->in_room )
update.c:	    while ( ( pexit = ch->in_room->exit[ ( door = number_range( 0, 5 ) ) ] ) == NULL
update.c:		  || to_room == ch->in_room );
update.c:	if ( IS_AFFECTED( ch, AFF_BLIND ) || IS_SET(ch->affected_by_2,AFF_LIGHT_SENSITIVE) || number_range( 0, 200 ) != 0 )
update.c:	if ( IS_AFFECTED( ch, AFF_BLIND ) || IS_SET(ch->affected_by_2,AFF_LIGHT_SENSITIVE) || number_range( 0, 75 ) != 0 )
update.c:        for ( vch = ch->in_room->people ; vch != NULL ; vch = vch->next_in_room )
update.c:   	    if ( IS_SET( ch->off_flags, ASSIST_ALL ) )
update.c:            if ( vch->race == ch->race && IS_SET( ch->off_flags, ASSIST_RACE ) )
update.c:            if ( !vch->pIndexData)
update.c:            if ( vch->pIndexData->vnum == ch->pIndexData->vnum && IS_SET( ch->off_flags, ASSIST_VNUM ) )
update.c:        for ( vch = ch->in_room->people ; vch != NULL ; vch = vch->next_in_room )
update.c:	    if ( vch == ch->fighting )
update.c:	    if ( vch->fighting == ch )
update.c:            if ( IS_SET( ch->act, ACT_AGGRESSIVE )  || 
update.c:	        ( !IS_SET( vch->guilds, MAJHERE ) && race_table[ ch->race ][ ch->sex ].world != race_table[ vch->race ][ vch->sex ].world && IS_SET( ch->act, ACT_ATTACK_WORLD ) ) 
update.c:	      || ( IS_SET( ch->act2, ACT2_ATTACK_GUILD ) && !IS_SET( ch->guilds, vch->guilds ) )
update.c:	      || is_name(ch->dislikes, vch->name ) 
update.c:	      || is_name(ch->hunting, vch->name ) )
update.c:    	     if ( vch->fighting == NULL || !IS_NPC( vch->fighting ) )
update.c:	    if ( is_same_group( vch->fighting, ch ) || is_same_group( vch, ch->fighting ) )
update.c:	    if ( IS_SET( ch->off_flags, ASSIST_ALL ) )
update.c:            if ( vch->fighting->race == ch->race && IS_SET( ch->off_flags, ASSIST_RACE ) )
update.c:            if ( vch->fighting->pIndexData->vnum == ch->pIndexData->vnum && IS_SET( ch->off_flags, ASSIST_VNUM ) )
update.c:	if ( get_mana_cost( ch, sn, type ) > ch->mana[ type ] )
update.c:    for ( skills = ch->innate_skills ; skills != NULL ; skills = skills->next )
update.c:		 || !IS_SET(ch->spell_flags, SPELL_PROTECTION) ) 
update.c:		 || !IS_SET(ch->spell_flags, SPELL_SHIELD) ) 
update.c:		level = ch->level;
update.c:    for ( skills = ch->skills ; skills != NULL ; skills = skills->next )
update.c:		 || !IS_SET(ch->spell_flags, SPELL_PROTECTION) ) 
update.c:		 || !IS_SET(ch->spell_flags, SPELL_SHIELD) ) 
update.c:		if ( number_range(0,2) == 1 && level <= ch->level )
update.c:	bug( "Get_skill_mob: no spell found", ch->pIndexData->vnum );
update.c:    if ( ch->position != POS_STANDING && ch->position != POS_FIGHTING )
update.c:    if ( ch->pIndexData == NULL || ch->pIndexData->pShop != NULL ||
update.c:	IS_SET( ch->act, ACT_GAIN ) || IS_SET( ch->act, ACT_TRAIN ) )
update.c:    if ( ch->skills == NULL && ch->innate_skills == NULL )
update.c:    race = ch->race;
update.c:    if ( ch->fighting != NULL && ch->hit < ch->max_hit / 3 && ch->hit < ch->fighting->hit )
update.c:    if ( spell == -1 && ch->fighting != NULL )
update.c:	victim = ch->fighting;
update.c:    if ( spell == -1 && ch->hit < ch->max_hit * 9 / 10 )
update.c:        for ( vch = ch->in_room->people ; vch != NULL && victim == NULL ; vch = vch_next )
update.c:		vch_next = vch->next_in_room;
update.c:		if ( !IS_NPC( vch ) || vch == ch || vch->hit >= vch->max_hit * 9 / 10 )
update.c:		if ( ch->leader != NULL && IS_NPC( ch->leader ) && !is_same_group( ch, vch ) )
update.c:	 	else if ( IS_SET( ch->off_flags, ASSIST_RACE ) && vch->race != ch->race )
update.c:	 	else if ( IS_SET( ch->off_flags, ASSIST_VNUM ) && vch->pIndexData->vnum != ch->pIndexData->vnum )
update.c:            for ( vch = ch->in_room->people ; vch != NULL && victim == NULL ; vch = vch_next )
update.c:		vch_next = vch->next_in_room;
update.c:		if ( ch->leader != NULL && IS_NPC( ch->leader ) && !is_same_group( ch, vch ) )
update.c:	 	else if ( IS_SET( ch->off_flags, ASSIST_RACE ) && vch->race != ch->race )
update.c:	 	else if ( IS_SET( ch->off_flags, ASSIST_VNUM ) && vch->pIndexData->vnum != ch->pIndexData->vnum )
update.c:    if ( ch->level >= 60 ) /* level 60 */
update.c:    ch->exp += gain;
update.c:    while ( ch->exp >= exp_table[ ch->level + 1 ].exp_at_level )
update.c:	ch->level += 1;
update.c:    	ch->practice += gain_prac;
update.c:	sprintf( log_buf, "%s has gained a level.", ch->name);
update.c:    sprintf( log_buf, "%s has gained $d levels.", ch->name );
update.c:    ch->position = position;
update.c:    ch->regen_timer = current_time;
update.c:    if ( ch->position >= POS_DEAD )
update.c:    ch->regen_timer = current_time;
update.c:	gain =  5 + ch->level;
update.c:        if (IS_SET(ch->in_room->room_flags,ROOM_HPGEN))
update.c:	switch(ch->position)
update.c:	gain = UMAX(3,get_curr_stat(ch,STAT_CON) - 3 + ch->level/2); 
update.c:	    if (ch->hit < ch->max_hit)
update.c:	    if (ch->hit < ch->max_hit)
update.c:        if (IS_SET(ch->in_room->room_flags,ROOM_HPGEN))
update.c:	switch ( ch->position )
update.c:	if (IS_AFFECTED(ch, AFF_REGENERATION) && ch->position == POS_FIGHTING)
update.c:	if ( ch->pcdata->condition[COND_DRUNK] != 0 )
update.c:    gain = gain * ( ( int ) ( current_time - ch->regen_timer ) ) / 30;
update.c:    ch->hit = UMIN( ch->hit + gain , ch->max_hit );
update.c:    if (IS_NPC(ch) && (ch->position != POS_FIGHTING ) )
update.c:            ch->mana[ type ] = UMIN( ch->max_mana[ type ], ch->mana[ type] + ( 3 * (ch->level) ) );
update.c:            if (ch->mana[ type ] < ch->max_mana[ type ])
update.c:	    if ( ch->mana[ type ] < ch->max_mana[ type ] )
update.c:        if ( IS_SET( ch->in_room->room_flags, ROOM_MANAGEN ) )
update.c:	else if ( IS_SET( ch->affected_by_2, AFF_MANA_GEN ) )
update.c:	switch ( ch->position )
update.c:        	gain = gain * ( ( int ) ( current_time - ch->regen_timer ) ) / 30;
update.c:		ch->mana[ type ] = UMIN( ch->max_mana[ type ] , ch->mana[ type ] + gain );
update.c:	if ( ch->pcdata->condition[COND_FULL]  <= 0 )
update.c:	if ( ch->pcdata->condition[COND_THIRST] <= 0 )
update.c:	if ( ch->pcdata->condition[COND_DRUNK] > 0 )
update.c:        gain = gain * ( ( int ) ( current_time - ch->regen_timer ) ) / 30;
update.c:	ch->mana[ type ] = UMIN( ch->max_mana[ type ] , ch->mana[ type ] + gain );
update.c:	gain = ch->level * 5;
update.c:        gain = UMAX(3,get_curr_stat(ch,STAT_CON) - 3 + ch->level/2);
update.c:	switch ( ch->position )
update.c:        if (IS_SET (ch->in_room->room_flags,ROOM_MVGEN))
update.c:	if ( ch->pcdata->condition[COND_FULL]   == 0 )
update.c:	if ( ch->pcdata->condition[COND_THIRST] == 0 )
update.c:        if (ch->move < ch->max_move)
update.c:    gain = gain * ( ( int ) ( current_time - ch->regen_timer ) ) / 30;
update.c:    ch->move = UMIN( ch->move + gain, ch->max_move );
update.c:    if ( value == 0 || IS_NPC(ch) || IS_IMMORTAL(ch) || ch->level <= 5 )
update.c:    if ( ch->pcdata->condition[iCond] < 0 )
update.c:	ch->pcdata->condition[iCond] = 0;
update.c:    condition				= ch->pcdata->condition[iCond];
update.c:    ch->pcdata->condition[iCond]	= URANGE( 0, condition + value, race_table[ ch->race ][ ch->sex ].max_condition[iCond] );
update.c:	ch->pcdata->condition[iCond]	= UMAX( 0, ch->pcdata->condition[iCond]);
update.c:    if ( ch->pcdata->condition[iCond] <= 0 )
update.c:	for ( obj = ch->carrying ; obj != NULL ; obj = obj->next_content )
update.c:            if (   ( IS_OBJ_STAT( obj, ITEM_ANTI_NENKEMEN  ) && race_table[ ch->race ][ ch->sex ].world == 0 )
update.c:		|| ( IS_OBJ_STAT( obj, ITEM_ANTI_MAEGMENEL    ) && race_table[ ch->race ][ ch->sex ].world == 1 )
update.c:		|| ( IS_OBJ_STAT( obj, ITEM_ANTI_LITHDOR      ) && race_table[ ch->race ][ ch->sex ].world == 2 ) )
update.c:    for ( obj = ch->carrying ; obj != NULL ; obj = obj->next_content )
update.c:		      || ( !is_affected_bit( ch->fighting, spell->spell ) 
update.c:			  && !check_is_dispelled( ch->fighting, spell->spell, TAR_CHAR_OFFENSIVE ) ) ) ) ) )
update.c:    for( ch = char_list ; ch != NULL ; ch = ch->next )
update.c:	  && !IS_SET( ch->plr, PLR_WIZINVIS )
update.c:	  && !IS_SET( ch->affected_by, AFF_SNEAK )
update.c:	  && !IS_SET( ch->affected_by, AFF_HIDE )
update.c:	  && !IS_SET( ch->affected_by_2, AFF_FADE )
update.c:	  && !IS_SET( ch->affected_by, AFF_SHADOWFORM ) )
update.c:	    fprintf( fp, "%s%s\n", ch->name, ch->pcdata->title );
update.c:	ch_next = ch->mob_next_update;
update.c:    	if ( !IS_NPC(ch) || ch->in_room == NULL )
update.c:	if ( ch->extract == TRUE )
update.c:	if (ch->in_room->area->nplayer == 0 && !IS_SET(ch->act,ACT_UPDATE_ALWAYS))
update.c:	if ( ch->fighting == NULL )
update.c: 	    ch->wait = UMAX( 0, ch->wait - PULSE_MOBILE  );
update.c:	if ( ch->wait > 0 )
update.c:        if ( ch->task[0] != '\0' && ch->fighting == NULL && strlen(ch->task) > 0 )
update.c:	if ( IS_SET( ch->act, ACT_HUNTER ) && ch->fighting == NULL 
update.c:	  && ( ch->dislikes[0] != '\0' || IS_SET( ch->act, ACT_AGGRESSIVE )
update.c:	  || ch->hunting[0] != '\0'
update.c:	  || IS_SET( ch->act, ACT_ATTACK_WORLD) 
update.c:	  || IS_SET( ch->act2, ACT2_ATTACK_GUILD )
update.c:	  || IS_SET( ch->off_flags, ASSIST_ALL|ASSIST_RACE|ASSIST_VNUM ) )
update.c:	  && !IS_SET( ch->act, ACT_SENTINEL ) ) 
update.c:	    if ( ch->hunting[0] == '\0' && ch->dislikes[0] != '\0' ) 
update.c:	        strncpy(ch->hunting, ch->dislikes,30);
update.c:	    for ( d = descriptor_list ; d != NULL && ch->hunting[0] == '\0' ; d = d->next )
update.c:		  && d->character->in_room->area == ch->in_room->area 
update.c:			&& race_table[ d->character->race ][ d->character->sex ].world != race_table[ ch->race ][ ch->sex ].world 
update.c:			&& IS_SET( ch->act, ACT_ATTACK_WORLD ) )
update.c:		  ||  ( IS_SET( ch->act2, ACT2_ATTACK_GUILD ) 
update.c:			&& !IS_SET( d->character->guilds, ch->guilds ) )
update.c:			&& ( IS_SET( ch->off_flags, ASSIST_ALL ) 
update.c:  	  	  ||  ( d->character->fighting->race == ch->race 
update.c:			&& IS_SET( ch->off_flags, ASSIST_RACE ) ) 
update.c:		  ||  ( d->character->fighting->pIndexData->vnum == ch->pIndexData->vnum 
update.c:			&& IS_SET( ch->off_flags, ASSIST_VNUM ) ) ) )
update.c:		  || IS_SET( ch->act, ACT_AGGRESSIVE ) ) )
update.c:		    strncpy(ch->hunting, d->character->name,30);
update.c:		    ch->task[0] = '\0';
update.c:		  && d->character->in_room->vnum == ch->in_room->vnum 
update.c:		  && IS_SET( ch->off_flags, ASSIST_PLAYERS )
update.c:		  && ( !IS_SET( ch->off_flags, ASSIST_RACE ) || ch->race == d->character->race )
update.c:		    strncpy(ch->hunting, d->character->fighting->name,30);
update.c:	if ( ch->spec_fun != 0 )
update.c:	    if ( (*ch->spec_fun) ( ch ) )
update.c:	if ( ch->hunting[0] != '\0' )
update.c: 	        if ( do_mphunt( ch, ch->hunting ) )
update.c:	if (IS_SET(ch->act2, ACT2_WEAPON_LOST ) 
update.c:	    && !IS_SET(ch->affected_by_2, AFF_LIGHT_SENSITIVE) 
update.c:	    REMOVE_BIT(ch->act2, ACT2_WEAPON_LOST );
update.c:	    for ( obj = ch->in_room->contents; obj; obj = obj_next )
update.c:	&&  ch->pIndexData->follower != 0  
update.c:	&&  ch->group == NULL 
update.c: 	&&  ch->master == NULL )
update.c:            for ( vch = ch->in_room->people; vch != NULL; vch = vch_next )
update.c:		vch_next = vch->next_in_room;
update.c:		if (ch->pIndexData->follower == vch->pIndexData->vnum  )
update.c:		    if (vch->group == NULL )
update.c:			sprintf(buf,"xyZzy %s",vch->name );
update.c:		    ch->task[0] = '\0';
update.c:	if (ch->position < POS_RESTING)
update.c:	if ( IS_SET( ch->act, ACT_SCAVENGER )
update.c:	    && !IS_SET(ch->affected_by_2, AFF_LIGHT_SENSITIVE) 
update.c:	    for ( obj = ch->in_room->contents; obj; obj = obj_next )
update.c:        if ( ch->hit < ( ch->max_hit / 2 ) && IS_SET( ch->pIndexData->form, FORM_SENTIENT )
update.c:	     &&  ( ch->pIndexData != NULL && ch->pIndexData->pShop == NULL )
update.c:		    sprintf( buf,"%s %s",obj->name,ch->name );
update.c:		   sprintf( buf, "%s %s", obj->name, ch->name );
update.c:	if ( IS_SET( ch->form, FORM_SENTIENT )
update.c:	     &&  ( ch->pIndexData != NULL && ch->pIndexData->pShop == NULL )
update.c:		    sprintf( buf,"%s %s",obj->name,ch->name );
update.c:		   sprintf( buf, "%s %s", obj->name, ch->name );
update.c:	if ( ch->fighting != NULL && IS_SET( ch->form, FORM_SENTIENT )
update.c:	     &&  ( ch->pIndexData != NULL && ch->pIndexData->pShop == NULL )
update.c:		    sprintf( buf,"%s %s",obj->name,ch->fighting->name );
update.c:		   sprintf( buf, "%s %s", obj->name, ch->fighting->name );
update.c:	if ( ch->position != POS_STANDING )
update.c:        if ( ch->task[0] != '\0' && strlen(ch->task) > 0 ) /* Got a task? don't wander */
update.c:	if (ch->walkto != 0 )
update.c:	   if ( (pRoom = get_room_index( ch->walkto )) == NULL )
update.c:		sprintf(buf,"Bad walkto room: %s Mob: %ld  Room %ld.\n\r",ch->short_descr,ch->pIndexData->vnum, ch->walkto);
update.c:		bug(buf,ch->pIndexData->vnum);
update.c:		REMOVE_BIT(ch->act2, ACT2_WALKTO);
update.c:		REMOVE_BIT(ch->act2, ACT2_STEERING);
update.c:		ch->walkto = 0;
update.c:		ch->walkfrom = 0;
update.c:	   if(IS_SET(ch->act2, ACT2_STEERING ) )
update.c:		if ( (pMob = get_mob_index( ch->walkfrom )) == NULL )
update.c:		    sprintf(buf,"Bad walkfrom room: %s Mob: %ld  Room %ld.\n\r",ch->short_descr,ch->pIndexData->vnum, ch->walkfrom);
update.c:		    bug(buf,ch->pIndexData->vnum);
update.c:		    REMOVE_BIT(ch->act2, ACT2_WALKTO);
update.c:		    REMOVE_BIT(ch->act2, ACT2_STEERING);
update.c:		    ch->walkto = 0;
update.c:		    ch->walkfrom = 0;
update.c:	   if(IS_SET(ch->act2, ACT2_STEERING ) )
update.c:		    sprintf(buf,"Bad walkto room: %s Mob: %ld  Room %ld.\n\r",ch->short_descr,ch->pIndexData->vnum, ch->walkfrom);
update.c:		    bug(buf,ch->pIndexData->vnum);
update.c:		    REMOVE_BIT(ch->act2, ACT2_WALKTO);
update.c:		    REMOVE_BIT(ch->act2, ACT2_STEERING);
update.c:		    ch->walkto = 0;
update.c:		    ch->walkfrom = 0;
update.c:	   if (!IS_SET(ch->act2, ACT2_STEERING ) )
update.c:	       location = ch->in_room;
update.c:		sprintf(buf, "arrive %ld",  ch->walkto  );
update.c:		REMOVE_BIT(ch->act2, ACT2_WALKTO);
update.c:		REMOVE_BIT(ch->act2, ACT2_STEERING);
update.c:		ch->walkto = 0;
update.c:		ch->walkfrom = 0;
update.c:		REMOVE_BIT(ch->act2, ACT2_WALKTO);
update.c:		REMOVE_BIT(ch->act2, ACT2_STEERING);
update.c:		ch->walkto = 0;
update.c:		ch->walkfrom = 0;
update.c:		if (IS_SET(ch->act2, ACT2_WALKTO) )
update.c:		if(IS_SET(ch->act2, ACT2_STEERING ) )
update.c:		if( ch->in_room == pRoom )
update.c:		    REMOVE_BIT(ch->act2, ACT2_WALKTO);
update.c:		    REMOVE_BIT(ch->act2, ACT2_STEERING);
update.c:	pexit = ch->in_room->exit[door];    
update.c:	    if ( !IS_SET( ch->pIndexData->form, FORM_SENTIENT ) || ( IS_AFFECTED( ch, AFF_DIMENSION_WALK ) && !IS_SET( pexit->exit_info, EX_PASSPROOF ) ) )
update.c:		in_room=ch->in_room;
update.c:		if ( is_locked_door( ch->in_room, door ) )
update.c:		    if ( is_locked_door( ch->in_room, door ) )
update.c:		/* ch->in_room cannot be NULL 
update.c:		if ( !ch->in_room )
update.c:		if ( ch->in_room != in_room && ch->in_room->exit[ rev_dir[ door ] ] != NULL 
update.c:		   && ch->in_room->exit[ rev_dir[ door ] ]->u1.to_room == in_room )
update.c:		    sprintf( buf, "%s %s",ch->in_room->exit[ rev_dir[ door ] ]->keyword, dir_name[ rev_dir[ door ] ] );
update.c:	else if ( !IS_SET(ch->act, ACT_SENTINEL) 
update.c:	&& ( ch->leader == NULL || ch->leader == ch )
update.c:	    for ( obj = ch->in_room->contents ; obj != NULL 
update.c:		&&   IS_SET( ch->act2, ACT2_ENTER_PORTAL )
update.c:	ch_next = ch->next;
update.c:	if ( ch->in_room == NULL )
update.c:	if (IS_SET(ch->forge_flags, IS_FORGING ) )
update.c:	    if ( ch->forge_count > 0 )
update.c:		switch (ch->forge_count )
update.c:		    SET_BIT(ch->forge_flags, FORGE_COMPLETE);
update.c:		    REMOVE_BIT(ch->forge_flags, IS_FORGING );
update.c:		    sprintf(buf, "%s",ch->forge_item );
update.c:		    if ( ch->forge_from == 1 )
update.c:		    if ( ch->forge_from == 2 )
update.c:		    if ( ch->forge_from == 3 )
update.c:		ch->forge_count--;
update.c:		REMOVE_BIT(ch->forge_flags, IS_FORGING );
update.c:	ch_next = ch->next;
update.c:	if ( ch->in_room == NULL )
update.c:	    ch->dream_count++;
update.c:	    if (IS_SET(ch->dream_flags, DREAM_IS_NIGHTMARE ) )
update.c:		switch(ch->dream_count)
update.c:		    ch->dream_flags = 0;
update.c:		    ch->dream_count = 0;
update.c:	    if (IS_SET(ch->dream_flags, DREAM_IS_NORMAL ) )
update.c:		switch(ch->dream_count)
update.c:		    	ch->dream_flags = 0;
update.c:		    	ch->dream_count = 0;
update.c:	    if (IS_SET(ch->dream_flags, DREAM_IS_GOOD_2 ) )
update.c:		switch(ch->dream_count)
update.c: 			ch->dream_flags = 0;
update.c:		   	ch->dream_count = 0;
update.c:    			af.level     = ch->level;
update.c:    			af.duration  = 6 + ( ch->level / 3 );
update.c:    			af.modifier  = ch->level / 6;
update.c:    			af.modifier  = 0 - ch->level / 6;
update.c:	    if (IS_SET(ch->dream_flags, DREAM_IS_GOOD ) )
update.c:		switch(ch->dream_count)
update.c:		    	ch->dream_flags = 0;
update.c:		    	ch->dream_count = 0;
update.c:    			ch->hit = UMIN( ch->hit + ( dice(3, 8) + ch->level / 8 ), ch->max_hit );
update.c:	ch_next = ch->next;
update.c:	if ( ch->in_room == NULL )
update.c:	if ( ch->fighting == NULL && IS_SET( ch->plr, PLR_FLEE ) )
update.c:	    REMOVE_BIT( ch->plr, PLR_FLEE );
update.c:        if ( ch->timer > 30 && !IS_IMMORTAL(ch))
update.c:        if ( ch->timer > 500 && !IS_OPTIVISION(ch))
update.c:	  || ( ch->in_room->sector_type == SECT_WATER_SWIM && !IS_AFFECTED( ch, AFF_FLYING|AFF_LEVITATE ) ) )
update.c:	    for ( obj = ch->carrying ; obj != NULL ; obj = obj_next )
update.c:	for ( obj = ch->carrying ; obj != NULL ; obj = obj_next )
update.c:	if (ch->timer < 12 ) /*Not in void */
update.c:	if ( ch->pcdata != NULL && ch->pcdata->debt != NULL )
update.c:	if ( ch->timer < 12 && IS_AFFECTED( ch, AFF_COLD ) && !IS_IMMORTAL( ch ) )
update.c:	    if ( ch->position == POS_SLEEPING )
update.c:	    for ( rch = ch->in_room->people ; rch != NULL ; rch = rch->next_in_room )
update.c:	    	if ( IS_SET( rch->res_flags, RES_WATER ) )
update.c:	    	else if ( IS_SET( rch->vuln_flags, VULN_WATER ) )
update.c:		  && !IS_SET( rch->imm_flags, IMM_WATER )
update.c:	if (ch->pcdata != NULL && ch->pcdata->home_timer < 100 )
update.c:	    ch->pcdata->home_timer++;
update.c:	if (ch->gos_timer > 0 )
update.c:	    ch->gos_timer--;
update.c:	if (ch->position != POS_FIGHTING && ch->level > 5 && !IS_IMMORTAL( ch ) )
update.c:	  ch->happy_hour++; /* Used for No food or Water while socializing */
update.c:	  if (ch->happy_hour == 10 )
update.c:	if (ch->happy_hour > 500 )
update.c:	   ch->happy_hour = 11;
update.c:	ch->happy_hour = 0;
update.c:	if (ch->outfit_timer > 0 )
update.c:	    ch->outfit_timer--;
update.c:	    if (ch->logon_data != NULL)
update.c:		if ( str_cmp(ch->logon_data->exit, "Lost-link") )
update.c:		    ch->logon_data->time_end = current_time;
update.c:		if ( str_cmp(ch->logon_data->exit,"Lost-link"))
update.c:		    if ( str_cmp(ch->logon_data->exit,"Logged-IN"))
update.c:		    	strncpy( ch->logon_data->exit, "Logged-IN", 30 );
update.c:	if (ch->timer < 12 ) /*Not in void */
update.c:	if (ch->timer < 12 ) /*Not in void */
update.c:	if ( ch->position == POS_STUNNED || ch->position == POS_INCAP)
update.c:	ch->timer++;
update.c:	    if ( ch->timer >= 12 )
update.c:		if ( ch->was_in_room == NULL && ch->in_room != NULL )
update.c:		    ch->was_in_room = ch->in_room;
update.c:		    if ( ch->fighting != NULL )
update.c:		    if (ch->level > 1)
update.c:	    if ( (ch->timer < 12 && ch->happy_hour < 6) 
update.c:	    || (race_table[ch->race][ch->sex].world == 0 ) ) /* Not in void */
update.c:	    if (ch->timer < 12 && ch->happy_hour < 6)
update.c:   if ( ch->timer < 12 && ch->happy_hour < 6) /* Not in void */
update.c:   if ( ch->timer < 12 ) /* Not in void */
update.c:	for ( paf = ch->affected; paf != NULL; paf = paf_next )
update.c:		    if ( !IS_NPC( ch ) && ch->desc == NULL )
update.c:			    ch->name,ch->in_room->vnum );
update.c:			for ( paf = ch->affected; paf != NULL; paf = paf_next)
update.c:		        ch->affected_by	= ch->pcdata->perm_aff;
update.c:		        ch->armor = 100;
update.c:		        REMOVE_BIT(ch->plr, PLR_THIEF);
update.c:    			REMOVE_BIT(ch->plr, PLR_BOUGHT_PET);
update.c:	    if (ch->in_room == NULL)
update.c:            for ( af = ch->affected; af != NULL; af = af_next )
update.c:            	REMOVE_BIT(ch->affected_by,AFF_PLAGUE);
update.c:            for ( vch = ch->in_room->people; vch != NULL; vch = vch->next_in_room)
update.c:	    dam = UMIN(ch->level,5);
update.c:	    ch->mana[ 0 ] -= dam;
update.c:	    ch->mana[ 1 ] -= dam;
update.c:	    ch->mana[ 2 ] -= dam;
update.c:	    ch->mana[ 3 ] -= dam;
update.c:	    ch->mana[ 4 ] -= dam;
update.c:	    ch->move -= dam;
update.c:	else if ( ch->position == POS_INCAP && number_range(0,4) == 0)
update.c:	else if ( ch->position == POS_MORTAL )
update.c:       ch_next = ch->next;
update.c:	if (ch->desc != NULL && ch->desc->descriptor % 30 == save_number)
update.c:	    	for ( rch = obj->in_room->people ; rch != NULL ; rch = rch->next_in_room )
update.c:	    	for ( rch = to_room->people ; rch != NULL ; rch = rch->next_in_room )
update.c:		    	for ( ch = char_list ; ch != NULL && ( !IS_NPC( ch ) || ch->pIndexData->vnum != vnum ) ; ch = ch->next );
update.c:		    	to_room = ch->in_room;
update.c: 	wch_next = wch->next;
update.c:	||   wch->in_room == NULL )
update.c:	for ( ch = wch->in_room->people; ch != NULL; ch = ch_next )
update.c:	    ch_next	= ch->next_in_room;
update.c:	    ||   (  !IS_SET(ch->act, ACT_ATTACK_WORLD)
update.c:	          &&  !IS_SET(ch->act, ACT_AGGRESSIVE ) 
update.c:		  && !IS_SET( ch->act2, ACT2_ATTACK_GUILD )
update.c:		  && !IS_SET( ch->act2, ACT2_SMART_AGGRESSIVE )
update.c:		  && ch->dislikes[0] == '\0' 
update.c:		  && ch->hunting[0] == '\0' )
update.c:	    ||   IS_SET(ch->in_room->room_flags,ROOM_SAFE)
update.c:	    ||   ch->fighting != NULL
update.c:	    ||   ( IS_SET(ch->act, ACT_WIMPY) && IS_AWAKE(wch)
update.c:		  && ch->hit <= ch->max_hit * 2 / 3 )
update.c:	    if ( ch->dislikes[0] != '\0' )
update.c:	    if ( is_name( ch->dislikes, wch->name ) )
update.c:		    do_shadowstrike( ch, wch->name );
update.c:		    ch->fighting = wch;
update.c:	    for ( vch = wch->in_room->people; vch != NULL; vch = vch_next )
update.c:		vch_next = vch->next_in_room;
update.c:		&&  ( !IS_SET(ch->act, ACT_WIMPY) 
update.c:		&&  ( (IS_SET(ch->act, ACT_AGGRESSIVE) 
update.c:		    || IS_SET(ch->act2, ACT2_SMART_AGGRESSIVE) )
update.c:		||  ( IS_SET( ch->act2, ACT2_ATTACK_GUILD ) 
update.c:		    && !IS_SET( ch->guilds, vch->guilds ) )
update.c:		||  ( !IS_SET( vch->guilds, MAJHERE ) 
update.c:		    && IS_SET( ch->act, ACT_ATTACK_WORLD )
update.c:		    && race_table[ ch->race ][ ch->sex ].world != race_table[ vch->race ][ vch->sex ].world ) ) )
update.c:		  if ( IS_SET(ch->act2, ACT2_SMART_AGGRESSIVE ) )
update.c:			chance=chance + ((ch->level - vch->level)*20);
update.c:			chance+=vch->max_hit/vch->hit;
update.c:	    		for ( cch = wch->in_room->people; cch != NULL; cch = cch_next )
update.c:			    cch_next = cch->next_in_room;
update.c:			    if ( IS_SET( cch->off_flags, ASSIST_ALL ) 
update.c:            		     || ( ch->race == cch->race && IS_SET( cch->off_flags, ASSIST_RACE ) )
update.c:            		     || ( ch->pIndexData->vnum == cch->pIndexData->vnum && IS_SET( cch->off_flags, ASSIST_VNUM ) ))
update.c:			     	chance=chance + ((cch->level - vch->level)*10);
update.c:	    if ( victim->mount != NULL && victim->mount->in_room == ch->in_room && dice(1,5) < 4 )
update.c:	        ch->fighting = victim;
update.c:    task = ch->task;
update.c:	    sprintf(buf,"Bad char Task: %s Mob: %ld.\n\r",ch->task,ch->pIndexData->vnum);
update.c:	    bug(buf,ch->pIndexData->vnum);
update.c:	    strncpy( ch->task, task, 80 );
update.c:	    ch->task[0] = '\0';
update.c:	    if ( ch->position == POS_STANDING )
update.c:	    if ( ch->position == POS_STANDING )
update.c:	    if ( ch->position == POS_STANDING )
update.c:	    if ( ch->position == POS_STANDING )
update.c:	    if ( ch->position == POS_STANDING )
update.c:	    if ( ch->position == POS_STANDING )
update.c:	    ch->wait += PULSE_MOBILE;
update.c:	    ch->wait += PULSE_MOBILE*2;
update.c:	    ch->wait += PULSE_MOBILE*3;
update.c:	    ch->wait += PULSE_MOBILE*4;
update.c:	    ch->wait += PULSE_MOBILE*5;
update.c:	    ch->wait += PULSE_MOBILE*6;
update.c:	    ch->wait += PULSE_MOBILE*7;
update.c:	    ch->wait += PULSE_MOBILE*8;
update.c:	    ch->wait += PULSE_MOBILE*9;
update.c:    strncpy( ch->task, buf, 80 );
